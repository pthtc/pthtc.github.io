<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Hexo博客Next主题正文不显示的解决方法]]></title>
      <url>http://pengtianhao.com/2016/11/15/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E6%AD%A3%E6%96%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近这个博客突然显示不正常，研究了半天才找到了解决方法，这里记录一下</p>
</blockquote>
<a id="more"></a>
<h1 id="u73B0_u8C61"><a href="#u73B0_u8C61" class="headerlink" title="现象"></a>现象</h1><p>Next主题，Hexo驱动的博客只能显示页码，正文等显示为白色，实际已经加载。</p>
<h1 id="u539F_u56E0"><a href="#u539F_u56E0" class="headerlink" title="原因"></a>原因</h1><p>发生这个情况是因为Github升级了Jekyll，详情可以看这个公告:<a href="https://github.com/blog/2277-what-s-new-in-github-pages-with-jekyll-3-3" target="_blank" rel="external">What’s new in GitHub Pages with Jekyll 3.3</a></p>
<p>Github在这个公告里说:</p>
<blockquote>
<p>Finally, to make it easier to vendor third-party dependencies via package managers like Bundler or NPM (or Yarn), <strong>Jekyll now ignores the vendor and node_modules directories by default</strong>, speeding up build times and avoiding potential errors. If you need those directories included in your site, set exclude: [] in your site’s configuration file.</p>
</blockquote>
<p>意思是他们默认无视了vendor文件夹，最终导致样式加载不上去</p>
<h1 id="u89E3_u51B3_u65B9_u6CD5"><a href="#u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="解决方法"></a>解决方法</h1><p>方法很简单，把vendor改名，再修改指向就可以了，下面是具体做法</p>
<p>假设hexo项目的文件夹是<code>Blog</code></p>
<ol>
<li>进入<code>Blog/themes/next/source</code></li>
<li>找到文件夹<code>vendor</code>，改名为<code>lib</code></li>
<li>打开<code>Blog/themes/next/_config.yml</code></li>
<li>找到字段<code>vendors:</code></li>
<li>将<code>vendor</code>字段下面<code>_internal: vendor</code>修改为<code>_internal: lib</code></li>
<li><code>hexo clean</code></li>
<li><code>hexo d -g</code></li>
</ol>
<p><strong>搞定!</strong></p>
<h1 id="u5982_u679C_u4F60_u627E_u4E0D_u5230vendor_u5B57_u6BB5"><a href="#u5982_u679C_u4F60_u627E_u4E0D_u5230vendor_u5B57_u6BB5" class="headerlink" title="如果你找不到vendor字段"></a>如果你找不到vendor字段</h1><p>解决方法是到<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">hexo-theme-next</a>下载最新的next主题版本，替换掉<code>Blog/themes/next</code>里面所有的文件(<strong>注意是theme里面的文件</strong>)，然后再按照上面的步骤重新操作，就可以了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[托福笔记]]></title>
      <url>http://pengtianhao.com/2016/11/13/%E6%89%98%E7%A6%8F%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>托福上课的一些记录</p>
</blockquote>
<a id="more"></a>
<h1 id="u5199_u4F5C"><a href="#u5199_u4F5C" class="headerlink" title="写作"></a>写作</h1><h2 id="u6B65_u9AA4"><a href="#u6B65_u9AA4" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>定观点</li>
<li>想观点</li>
<li>想论证</li>
<li>想例子</li>
<li>让步</li>
</ol>
<h2 id="u6CE8_u610F_u70B9"><a href="#u6CE8_u610F_u70B9" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>语法准确</li>
<li>用词准确</li>
<li>衔接性好</li>
<li>句式丰富</li>
<li>表达简洁</li>
</ul>
<h2 id="u9488_u5BF9_u8003_u8BD5"><a href="#u9488_u5BF9_u8003_u8BD5" class="headerlink" title="针对考试"></a>针对考试</h2><ul>
<li>无纠错</li>
<li>键盘</li>
<li>倒计时情况下练习</li>
</ul>
<h2 id="u8BC4_u5206_u6807_u51C6"><a href="#u8BC4_u5206_u6807_u51C6" class="headerlink" title="评分标准"></a>评分标准</h2><ul>
<li>针对话题完成任务——(跑题、缺少因果关系、没注意限定)</li>
<li>能充分展开，使用适当解释和例证</li>
<li>结构清晰</li>
<li>连贯性(衔接词)</li>
<li>局势丰富，用词合适</li>
</ul>
<h2 id="u5BA1_u9898_u56DB_u6B65_u6CD5"><a href="#u5BA1_u9898_u56DB_u6B65_u6CD5" class="headerlink" title="审题四步法"></a>审题四步法</h2><ol>
<li>翻译</li>
<li>寻找题目中有无限定</li>
<li>判断题型(是否是比较，如果不是，再看别的题型)</li>
<li><p>判断写法</p>
<ul>
<li>理由切入</li>
<li>场景切入</li>
</ul>
</li>
</ol>
<h2 id="u53E5_u5F0F"><a href="#u53E5_u5F0F" class="headerlink" title="句式"></a>句式</h2><p> 句式变化:形似主语、存现句、从句、后置定语、人/物做主语、倒装、分词作状语、动词名词化、插入句</p>
<p><strong>变化</strong></p>
<pre><code>studying in the us is my dream.
I dream that I can study in the US.
I dream of studying in the US.
studying in the us which is my dream, is always comes to my mind.
It is my dream that
</code></pre><p><strong>倒装</strong></p>
<pre><code>only by learning English well can we communicate with an american.
By no means should we betray our country.
</code></pre><p><strong>分词作状语</strong></p>
<pre><code>Being addicted to computer games,I failed the exams.
</code></pre><p><strong>动词名词化</strong></p>
<pre><code>Eating too much sugar will make people fat.
Obesity is a result of excessive intake of sugar.

Beijing residents are victims of smoggy weather.

the morning fog is an indication of a nice day.
</code></pre><h2 id="u9898_u76EE_u5206_u7C7B"><a href="#u9898_u76EE_u5206_u7C7B" class="headerlink" title="题目分类"></a>题目分类</h2><h3 id="u6309_u8BDD_u9898_u5206_u7C7B"><a href="#u6309_u8BDD_u9898_u5206_u7C7B" class="headerlink" title="按话题分类"></a>按话题分类</h3><ul>
<li>社会</li>
<li>教育(教育方法)</li>
<li>媒体(电视电影、广告媒体)</li>
<li>生活(休闲娱乐、旅游度假、交友)</li>
<li>工作(个人成功、团队合作、工作家庭)</li>
</ul>
<h3 id="u9898_u578B_u5206_u7C7B"><a href="#u9898_u578B_u5206_u7C7B" class="headerlink" title="题型分类"></a>题型分类</h3><ul>
<li>应该或者不应该题</li>
<li>现象证明题</li>
<li>比较题</li>
<li>结论题</li>
</ul>
<h2 id="u6587_u7AE0_u7ED3_u6784"><a href="#u6587_u7AE0_u7ED3_u6784" class="headerlink" title="文章结构"></a>文章结构</h2><h3 id="u72EC_u7ACB_u5199_u4F5C"><a href="#u72EC_u7ACB_u5199_u4F5C" class="headerlink" title="独立写作"></a>独立写作</h3><h4 id="u67B6_u6784"><a href="#u67B6_u6784" class="headerlink" title="架构"></a>架构</h4><p>400字</p>
<ul>
<li>开头：80——6min</li>
<li>中间段1：100——7min</li>
<li>中间段2：100——7min</li>
<li>让步段：80——6min</li>
<li>结尾段：40——3min</li>
</ul>
<h4 id="u6BB5_u843D_u5185_u5BB9"><a href="#u6BB5_u843D_u5185_u5BB9" class="headerlink" title="段落内容"></a>段落内容</h4><ol>
<li>introduction: 话题引入+他人观点+明确立场+过渡句</li>
<li>body: 中间段(理由/场景): 主题句+说理论证+细节例子|让步段：承认漏洞+堵漏</li>
<li>conclusion: 重申观点+归纳理由/场景</li>
</ol>
<h5 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h5><ul>
<li>话题引入: 寻找核心词+结合核心词介绍背景</li>
<li>他人观点: 有些人认为(<code>some claim that</code> <code>A wealth of folks hold the view that...</code> <code>A majority of individuals give their priority to the view that...</code>)/引发热议(<code>thus an interesting discussion has arisen/With this phenomenon comes a heated discussion</code>)/当涉及…，通常有…几种方式(<code>when it comes to… , there are usually 3 approaches</code>)</li>
<li>明确立场: <code>as far as I am concerned, this assertion is arbitrary and unilateral</code> <code>I cast my preference to the opinion that ...</code></li>
<li>过渡句: 原因切入(<code>My reasons and example are given below.</code>)  场景切入(<code>I am going to present two typical cases to illustrate my point of view.</code>)</li>
</ul>
<h5 id="body"><a href="#body" class="headerlink" title="body"></a>body</h5><p>主题句(15)+论证(40)+论据(50)</p>
<p><strong>主题句</strong></p>
<p>无细节，与主观点有直接关系！</p>
<p><strong>论证</strong></p>
<ol>
<li>正面论述： <code>It is because ___</code></li>
<li>反面论述： <code>If that’s the case___</code></li>
<li>对比论述：  <code>But nowadays</code> 例子可以举过去的例子或者现在的例子，一个</li>
</ol>
<p><strong>举例方法</strong></p>
<ol>
<li>找到主题句中的要素</li>
<li>具象化</li>
</ol>
<p><code>According to a recent survey/investigation conducted by...</code></p>
<p><code>A recent research carried out by... manifests/suggests</code></p>
<p><strong>让步段</strong></p>
<ol>
<li>提出解决方案，消除顾虑</li>
<li>指出次要问题</li>
<li>转换思维</li>
</ol>
<p><code>Admittedly,I am not denying the value of xxx</code><br><code>However, on balance, the issue above pales in comparison with ___ because</code><br><code>However,as long as I ___,there will be nothing to worry about.</code></p>
<h5 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h5><p><code>In a nutshell</code> </p>
<p><strong>原因切入</strong></p>
<p><code>It is not only because ___ but also because ___</code></p>
<p><strong>场景切入</strong></p>
<p><code>I believe the case of ___ and ___ have already proven the validity of my point of view.</code></p>
<p><strong>升华主题</strong></p>
<p>名言+解读</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Just <span class="keyword">as</span> a chinese proverb goes, only <span class="keyword">by</span> considering the past shall we know the <span class="keyword">future</span>.A good command <span class="keyword">of</span> history helps us live well <span class="keyword">for</span> the present <span class="keyword">and</span> make full preparations <span class="keyword">for</span> the <span class="keyword">future</span>.</span><br></pre></td></tr></table></figure>
<h3 id="u7EFC_u5408_u5199_u4F5C"><a href="#u7EFC_u5408_u5199_u4F5C" class="headerlink" title="综合写作"></a>综合写作</h3><ul>
<li>考试时间：25min</li>
<li>步骤：看(3)-&gt;听(2)-&gt;写(20)</li>
<li>字数：150~225 <strong>不能超字数！</strong></li>
</ul>
<h4 id="u542C_u529B_u4E0E_u5199_u4F5C_u7684_u5173_u7CFB"><a href="#u542C_u529B_u4E0E_u5199_u4F5C_u7684_u5173_u7CFB" class="headerlink" title="听力与写作的关系"></a>听力与写作的关系</h4><p>阅读部分重点是<strong>三个分论点</strong><br>听力反驳分为：先扬后抑，针锋相对，你有病我有药。听力侧重<strong>细节</strong>，即论据</p>
<h4 id="u9605_u8BFB"><a href="#u9605_u8BFB" class="headerlink" title="阅读"></a>阅读</h4><p>总分结构，一总三分</p>
<ol>
<li><strong>只</strong>记录主观点(主谓宾)和核心理由(主谓宾，because of 原因)</li>
<li>总观点位于<strong>第一段段尾</strong></li>
<li>分论点一般位于二、三、四段段首或段尾</li>
<li>对听力进行预判</li>
<li>专有名词</li>
<li>对听力所反驳的细节一定要记</li>
</ol>
<h4 id="u542C_u529B"><a href="#u542C_u529B" class="headerlink" title="听力"></a>听力</h4><p><strong>表格法</strong> 因为踩点给分，语法正确即可</p>
<table>
<thead>
<tr>
<th style="text-align:center">阅读主观点</th>
<th style="text-align:center">听力主观点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">非A</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">非B</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">非C</td>
</tr>
</tbody>
</table>
<ol>
<li>总观点与分论点逐一反驳阅读，每个给出1-3个证据</li>
<li>只记录evidence</li>
<li>序数词是段落分界线</li>
<li>开头段让步提问不记笔记</li>
<li>经常用反证法:如果如你所说，事实不应该是这样的</li>
</ol>
<h4 id="u5199_u4F5C-1"><a href="#u5199_u4F5C-1" class="headerlink" title="写作"></a>写作</h4><p>表格横向截取，每行一段</p>
<ol>
<li>一总三分四段式，不需要总结段</li>
<li>原话主动转被动，被动转主动</li>
<li>修改动词形容词，不改名词</li>
</ol>
<h5 id="u5173_u952E_u8BCD"><a href="#u5173_u952E_u8BCD" class="headerlink" title="关键词"></a>关键词</h5><ul>
<li><strong>阅读/听力:</strong> writer professor</li>
<li><strong>指出:</strong> claim believe hold mention say</li>
<li><strong>反驳:</strong> argue suggest point out refute ut by stating that</li>
<li><strong>然而:</strong> while whereas but however nevertheless on the contrary by contrast conversely</li>
</ul>
<h5 id="u5199_u4F5C_u7ED3_u6784"><a href="#u5199_u4F5C_u7ED3_u6784" class="headerlink" title="写作结构"></a>写作结构</h5><ul>
<li><strong>第一段</strong> 呈现双方对立观点(the writer claims that <strong><em> ,while the professor disagree </em></strong> )</li>
<li><strong>后三段</strong> Firstly/secondly/lastly,the writer holds that <strong><em>.However,the propfessor argues that </em></strong></li>
</ul>
<h1 id="u53E3_u8BED"><a href="#u53E3_u8BED" class="headerlink" title="口语"></a>口语</h1><h2 id="u7B2C_u4E00_u3001_u4E8C_u9898"><a href="#u7B2C_u4E00_u3001_u4E8C_u9898" class="headerlink" title="第一、二题"></a>第一、二题</h2><p>原因+阐释， <strong>不用管逻辑！！</strong></p>
<pre><code>When it comes to ___.

There are N ways to solve it./There are pros and cons about it.

Personally speaking,apprently,it&apos;s an effective way for ____ to do sth.By doing this,it allows ___ to ___ ,which means ____.

Additionally/However, there is no doubt that ___ ,which is significantly beneficial/harmful.In that case, ___

Based on what I said, that&apos;s why I feel this way.
</code></pre><h2 id="u7B2C_u4E09_u9898"><a href="#u7B2C_u4E09_u9898" class="headerlink" title="第三题"></a>第三题</h2><h3 id="B_u73ED_u53E5_u5F0F"><a href="#B_u73ED_u53E5_u5F0F" class="headerlink" title="B班句式"></a>B班句式</h3><p>肯定分为两种原因，支持+反对，表达结果是<strong>全盘复述正反方观点</strong></p>
<p>以观点为主</p>
<p><strong>阅读部分(控制在20s)</strong> 谁|干什么|为什么（其他对于为什么的细节将呼应听力部分）</p>
<p><strong>听力部分(40s)</strong> 对于所有细节做笔记（原则是关键词），如果有细节没记住就用such as</p>
<p><code>the man/woman from the conversation agree/disagree with this proposal</code></p>
<pre><code>sb/sth do sth，since first reason and second reason
The man/woman from the conversation agree/disagree with this.First xxx.Second xxx.
</code></pre><h3 id="C_u73ED_u53E5_u5F0F"><a href="#C_u73ED_u53E5_u5F0F" class="headerlink" title="C班句式"></a>C班句式</h3><pre><code>In the reading passage, a student proposes that __ | The university plans to ____ for the following reasons.Firstly,__ Moreover_____
In the listening, the woman/ man think it&apos;s a good/bad idea.
First of all, What he believe is that  ___ . __ which makes a lot of sense.
Besides,It&apos;s worth mentioning that _____.
</code></pre><h2 id="u7B2C_u56DB_u9898"><a href="#u7B2C_u56DB_u9898" class="headerlink" title="第四题"></a>第四题</h2><h3 id="u9605_u8BFB-1"><a href="#u9605_u8BFB-1" class="headerlink" title="阅读"></a>阅读</h3><ol>
<li>看标题</li>
<li>记录下标题的概念</li>
</ol>
<h3 id="u542C_u529B-1"><a href="#u542C_u529B-1" class="headerlink" title="听力"></a>听力</h3><p>记录全部细节</p>
<h3 id="u7B54_u9898_u683C_u5F0F"><a href="#u7B54_u9898_u683C_u5F0F" class="headerlink" title="答题格式"></a>答题格式</h3><pre><code>The lecture talks about &quot;title&quot; which means _____.

The professor uses his own experience/one example to further explain.

Examples.
</code></pre><h3 id="u5B9E_u9A8C_u9898"><a href="#u5B9E_u9A8C_u9898" class="headerlink" title="实验题"></a>实验题</h3><pre><code>There are two groups of students.

The first group be shown/given/asked ___
The second group.....
later /then/afterward
As a result, it turned out that 1. 2. 3. Because ___
</code></pre><h3 id="marketing/bussiness"><a href="#marketing/bussiness" class="headerlink" title="marketing/bussiness"></a>marketing/bussiness</h3><p><strong>product</strong></p>
<ul>
<li>price</li>
<li>quality</li>
<li>appearance</li>
<li>feature</li>
<li>brand</li>
<li>design - user friendly</li>
<li>service</li>
</ul>
<h2 id="u7B2C_u4E94_u9898"><a href="#u7B2C_u4E94_u9898" class="headerlink" title="第五题"></a>第五题</h2><p>记下所有细节即可</p>
<h3 id="u7B54_u9898_u683C_u5F0F-1"><a href="#u7B54_u9898_u683C_u5F0F-1" class="headerlink" title="答题格式"></a>答题格式</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In <span class="keyword">this</span> conversation there <span class="keyword">is</span> <span class="keyword">this</span> problem <span class="literal">that</span> ___</span><br><span class="line"></span><br><span class="line">There are two possible solutions. One <span class="keyword">is</span> <span class="literal">that</span>  ___ . The other <span class="keyword">is</span> <span class="literal">that</span> ___ </span><br><span class="line"></span><br><span class="line"><span class="number">30s</span></span><br><span class="line"></span><br><span class="line">Personally speaking, I would prefer ___ <span class="keyword">for</span> the following reasons.</span><br><span class="line"></span><br><span class="line">Firstly, the most obvious reason <span class="keyword">is</span> <span class="literal">that</span> ___ (好处)</span><br><span class="line"></span><br><span class="line">In addition,although ___ . ___ (担忧的解决方法)</span><br></pre></td></tr></table></figure>
<h2 id="u7B2C_u516D_u9898"><a href="#u7B2C_u516D_u9898" class="headerlink" title="第六题"></a>第六题</h2><h3 id="u7B54_u9898_u683C_u5F0F-2"><a href="#u7B54_u9898_u683C_u5F0F-2" class="headerlink" title="答题格式"></a>答题格式</h3><h4 id="business"><a href="#business" class="headerlink" title="business"></a>business</h4><h4 id="u751F_u7269_u5B66"><a href="#u751F_u7269_u5B66" class="headerlink" title="生物学"></a>生物学</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The lecture talks about ____</span><br><span class="line"></span><br><span class="line">Firstly, ____ <span class="keyword">For</span> example, there <span class="keyword">is</span> this animal named ___ <span class="keyword">with</span> ___ which allows them <span class="keyword">to</span> ___ .</span><br><span class="line">Secondly, ____ <span class="keyword">For</span> instance,the professor mentioned another <span class="keyword">type</span> <span class="keyword">of</span> animal ___ that have ___ permitting them <span class="keyword">to</span> ___ .</span><br></pre></td></tr></table></figure>
<h2 id="u542C_u529B-2"><a href="#u542C_u529B-2" class="headerlink" title="听力"></a>听力</h2><h3 id="u7B2C_u4E00_u9898_28_u4E3B_u65E8_u9898_29"><a href="#u7B2C_u4E00_u9898_28_u4E3B_u65E8_u9898_29" class="headerlink" title="第一题(主旨题)"></a>第一题(主旨题)</h3><h3 id="u7EC6_u8282_u9898"><a href="#u7EC6_u8282_u9898" class="headerlink" title="细节题"></a>细节题</h3><h2 id="u9605_u8BFB-2"><a href="#u9605_u8BFB-2" class="headerlink" title="阅读"></a>阅读</h2><h3 id="u7EC6_u8282_u9898-1"><a href="#u7EC6_u8282_u9898-1" class="headerlink" title="细节题"></a>细节题</h3><p>定位 不稳定性 形容词&gt;动词&gt;名词</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络笔记]]></title>
      <url>http://pengtianhao.com/2016/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>计算机网络的课堂笔记</p>
</blockquote>
<a id="more"></a>
<h2 id="u534F_u8BAE_u56FE"><a href="#u534F_u8BAE_u56FE" class="headerlink" title="协议图"></a>协议图</h2><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/463z3S3E1A3o04323l0K/1366100130_5972.jpg?v=34777df0" alt=""></p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1T0H2M0I1d2F0i36063O/0_1325744597WM32.gif?v=e4566c46" alt=""></p>
<h2 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h2><h3 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p><strong>网络</strong> 由节点和链路组成 <strong>点和线都很重要</strong></p>
</li>
<li><p><strong>计算机网络</strong> 一个互相连接、自治的计算机集合</p>
</li>
<li><p><strong>互联网（internet）</strong> 网络的网络，使用任意协议</p>
</li>
<li><p><strong>英特网（Internet）</strong> 一种互联网，使用TCP/IP协议，世界上最大的计算机网络</p>
</li>
<li><p><strong>以太网</strong> 采用CSMA/CD协议的局域网</p>
</li>
<li><p><strong>上网</strong> 通过ISP获得IP地址</p>
</li>
<li><p><strong>协议</strong> 为网络数据交换而建立的规则</p>
</li>
<li><p><strong>交换机</strong> 为接入交换机的任意两个网络节点提供独享的电信号通路，其实就是<strong>分配信号的东西</strong></p>
</li>
<li><p><strong>路由</strong> 分组从源到目的地时，决定端到端路径的网络范围的进程，<strong>家里的那种其实是交换机和路由器的集合</strong></p>
</li>
<li><p><strong>路由器</strong> 节点交换机</p>
</li>
<li><p><strong>WAN</strong> 广域网</p>
</li>
<li><p><strong>LAN</strong> 局域网</p>
</li>
<li><p><strong>ISP</strong> 因特网服务供应商，有申请IP地址的能力，比如<strong>电信、移动、联通</strong></p>
</li>
<li><p><strong>IP</strong> 网络协议</p>
</li>
<li><p><strong>IXP</strong> 互联网交换点，为了低级ISP之间转发方便设置</p>
</li>
<li><p><strong>TCP</strong> 传输控制协议，保证信息传达完整，比较慢</p>
</li>
<li><p><strong>UDP</strong> 用户数据报协议，不保证信息转达完整，比较快</p>
</li>
<li><p><strong>ICP</strong> 网络内容服务商</p>
</li>
<li><p><strong>时延（延迟）</strong> 数据从网络一端到另一端所需的时间，转发中要排队造成<br><code>总时延 = 发送时延（主机发送数据帧的时间）+传播时延（电磁波在信道中传播一定距离的时间）+处理时延+排队时延</code></p>
</li>
</ul>
<h3 id="u82F1_u7279_u7F51_u7684_u7EC4_u6210"><a href="#u82F1_u7279_u7F51_u7684_u7EC4_u6210" class="headerlink" title="英特网的组成"></a>英特网的组成</h3><h4 id="u4E92_u8054_u7F51_u8FB9_u7F18_u90E8_u5206"><a href="#u4E92_u8054_u7F51_u8FB9_u7F18_u90E8_u5206" class="headerlink" title="互联网边缘部分"></a>互联网边缘部分</h4><p>进行由各种终端组成（PC/某个ISP/互联网摄像头等）</p>
<ul>
<li><p><strong>客户-服务器通信(C/S)</strong> 客户（Client）和服务器（Server）都指进程</p>
</li>
<li><p><strong>对等通信（P2P）</strong> </p>
</li>
</ul>
<h5 id="u670D_u52A1_u5668_u8F6F_u4EF6"><a href="#u670D_u52A1_u5668_u8F6F_u4EF6" class="headerlink" title="服务器软件"></a>服务器软件</h5><p>一种同时处理多个远程和本地客户的请求的程序</p>
<ul>
<li><strong>一直运行</strong></li>
<li><strong>被动等待</strong></li>
</ul>
<h4 id="u4E92_u8054_u7F51_u6838_u5FC3_u90E8_u5206"><a href="#u4E92_u8054_u7F51_u6838_u5FC3_u90E8_u5206" class="headerlink" title="互联网核心部分"></a>互联网核心部分</h4><p>由网络和路由器等组成，起特殊作用的是<strong>路由器</strong>，用于转发收到的分组</p>
<h5 id="u8DEF_u7531_u5668"><a href="#u8DEF_u7531_u5668" class="headerlink" title="路由器"></a>路由器</h5><p><strong>路由器的输入输出端口间没有直接连线</strong></p>
<p>路由器处理分组的过程：</p>
<ul>
<li><p>收到的分组放入缓存</p>
</li>
<li><p>查找转发表</p>
</li>
<li><p>把分组送到合适的端口转发出去</p>
</li>
</ul>
<h5 id="u5404_u79CD_u4EA4_u6362"><a href="#u5404_u79CD_u4EA4_u6362" class="headerlink" title="各种交换"></a>各种交换</h5><ul>
<li><p><strong>交换</strong> 建立连接——通信——释放连接</p>
</li>
<li><p><strong>分组</strong> 将数据打包分块，也就是<strong>包</strong>，分组的头部叫做<strong>包头</strong></p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>分组交换</strong> 单个分组传送到节点，储存下来后查找转发表，转发下一个节点</p>
</li>
<li><p><strong>报文交换</strong> 整个报文先传送到相邻节点，全部储存下来后查找转发表，转发下一个节点</p>
</li>
<li><p><strong>电路交换</strong> 持续地连续从源点直达终点，一直占用资源</p>
</li>
</ul>
<h3 id="u534F_u8BAE"><a href="#u534F_u8BAE" class="headerlink" title="协议"></a>协议</h3><h4 id="u534F_u8BAE_u7684_u7EC4_u6210"><a href="#u534F_u8BAE_u7684_u7EC4_u6210" class="headerlink" title="协议的组成"></a>协议的组成</h4><ul>
<li><strong>语法</strong> 格式结构</li>
<li><strong>语义</strong> 定义发出的信息和应该做出的响应</li>
<li><strong>同步</strong> 事件实现顺序</li>
</ul>
<h4 id="u4E94_u7EA7_u4F53_u7CFB_u7ED3_u6784"><a href="#u4E94_u7EA7_u4F53_u7CFB_u7ED3_u6784" class="headerlink" title="五级体系结构"></a>五级体系结构</h4><ul>
<li><p><strong>物理层</strong> 网线等，与链路层组成<code>局域网</code></p>
</li>
<li><p><strong>链路层</strong> 交换机、路由器等发挥作用的地方</p>
</li>
<li><p><strong>网络层</strong> IP</p>
</li>
<li><p><strong>运输层</strong> TCP/UDP</p>
</li>
<li><p><strong>应用层</strong> DNS/FTP/HTTP/URL/SMTP/POP3/IMAP等，交换的数据单元叫<strong>报文</strong></p>
</li>
</ul>
<h4 id="TCP/IP"><a href="#TCP/IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p><strong>体系结构</strong> 将五级结构的物理层和链路层合并</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0W3I081S0r1m3Y3C0c2h/020009362228293.png" alt=""></p>
<p><strong>沙漏型</strong> 应用层和网络接口层都有很多协议，IP层很小，所以各种协议都向下汇聚到IP协议中</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0V0k0k3M440i3Y0O0F2K/d6ca7bcb0a46f21fd656b015f7246b600c33ae12.jpg" alt=""></p>
<h2 id="u7269_u7406_u5C42"><a href="#u7269_u7406_u5C42" class="headerlink" title="物理层"></a>物理层</h2><p>物理层考虑的是</p>
<ul>
<li><strong>如何在链接各种计算机的传输媒体上传输数据bit流</strong></li>
<li><strong>如何使数据链层无法感受到传输媒体和通信手段的差异</strong></li>
</ul>
<p>通过<strong>串行传输</strong>传输数据（成本考虑）</p>
<h3 id="u6570_u636E_u901A_u4FE1"><a href="#u6570_u636E_u901A_u4FE1" class="headerlink" title="数据通信"></a>数据通信</h3><h4 id="u7EC4_u6210_u6210_u5206"><a href="#u7EC4_u6210_u6210_u5206" class="headerlink" title="组成成分"></a>组成成分</h4><ul>
<li><strong>源系统：</strong> 源点、发送器</li>
<li><strong>传输系统</strong></li>
<li><strong>目的系统：</strong> 接收器、终点</li>
</ul>
<h4 id="u4E00_u4E9B_u6982_u5FF5"><a href="#u4E00_u4E9B_u6982_u5FF5" class="headerlink" title="一些概念"></a>一些概念</h4><ul>
<li><strong>消息</strong> 数据的本来面目（语音、图像）</li>
<li><strong>数据</strong> 有意义的符号序列（01010？）</li>
<li><strong>信号</strong> 电磁表现（1.<strong>模拟信号：</strong> 取值连续 2. <strong>数字信号：</strong>取值离散）</li>
<li><strong>信道</strong> 单向数据通路，通信电路包含两条信道（接收、发送）</li>
<li><strong>单向通信</strong> 没有方向的通信，不期望回复(广播、电视)</li>
<li><strong>双向交替通信</strong> 字面意思，同一时间一方只能接收或者发送，需要两条信道</li>
<li><strong>双向同时通信</strong> 字面意思，两条信道</li>
<li><strong>调幅AM</strong> 振幅</li>
<li><strong>调频FM</strong> 频率</li>
<li><strong>调相</strong> 初始相位</li>
<li><strong>码间串扰</strong> 码元传输速率太高导致接收到的信号失去了清晰的界限</li>
<li><p><strong>信噪比（S/N）</strong> 信号平均功率和噪声平均功率之比，单位是分贝</p>
<p>  <code>信噪比(db) = 10*lg(S/N)</code> </p>
</li>
<li><strong>极限传输速率</strong> <code>C = Wlog2(1+S/N)</code></li>
</ul>
<h4 id="u4F20_u8F93_u5A92_u4F53"><a href="#u4F20_u8F93_u5A92_u4F53" class="headerlink" title="传输媒体"></a>传输媒体</h4><h5 id="u5F15_u5BFC_u578B"><a href="#u5F15_u5BFC_u578B" class="headerlink" title="引导型"></a>引导型</h5><ul>
<li><strong>双绞线</strong></li>
<li><strong>同轴电缆</strong></li>
<li><strong>光缆</strong></li>
</ul>
<h5 id="u975E_u5F15_u5BFC_u578B"><a href="#u975E_u5F15_u5BFC_u578B" class="headerlink" title="非引导型"></a>非引导型</h5><p>各种无线电波通信</p>
<h4 id="u4FE1_u9053_u590D_u7528_u6280_u672F"><a href="#u4FE1_u9053_u590D_u7528_u6280_u672F" class="headerlink" title="信道复用技术"></a>信道复用技术</h4><h5 id="u9891_u5206_u590D_u7528_u3001_u65F6_u5206_u590D_u7528_u3001_u7EDF_u8BA1_u65F6_u5206_u590D_u7528"><a href="#u9891_u5206_u590D_u7528_u3001_u65F6_u5206_u590D_u7528_u3001_u7EDF_u8BA1_u65F6_u5206_u590D_u7528" class="headerlink" title="频分复用、时分复用、统计时分复用"></a>频分复用、时分复用、统计时分复用</h5><ul>
<li><strong>频分复用FDM</strong> 所有用户占用不同的频带（频率区域）</li>
<li><strong>时分复用TDM</strong> 每个用户在TDM帧中占用固定序号的时隙</li>
<li><strong>统计时分复用STDM</strong> 低速信号充满缓存之后发送，保证利用率</li>
<li><strong>波分复用</strong> 就是光的频分复用</li>
<li><strong>码分复用</strong> </li>
<li><strong>复用器、分用器</strong> 见图</li>
</ul>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0X2G1j3I1g2d030b3r1b/003shoMnzy6NmKBEc6X2f&amp;690.png?v=3553ba49" alt=""> </p>
<h2 id="u6570_u636E_u94FE_u8DEF_u5C42"><a href="#u6570_u636E_u94FE_u8DEF_u5C42" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul>
<li><p><strong>点对点信道</strong> </p>
</li>
<li><p><strong>广播信道</strong> </p>
</li>
<li><p><strong>链路</strong> 一个节点到相邻点的一段物理线路（有线或无线）</p>
</li>
<li><p><strong>数据链路</strong> 通过通信协议控制数据的软硬件</p>
</li>
</ul>
<h3 id="u70B9_u5BF9_u70B9_u4FE1_u9053_u7684_u6570_u636E_u94FE_u8DEF_u5C42"><a href="#u70B9_u5BF9_u70B9_u4FE1_u9053_u7684_u6570_u636E_u94FE_u8DEF_u5C42" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h3><ol>
<li>节点A把网络层给的IP数据报添加首尾封装成帧</li>
<li>A把帧发送给B</li>
<li>B确认无差错，就从帧中提出IP数据报给网络层</li>
</ol>
<h3 id="u5C01_u88C5_u6210_u5E27"><a href="#u5C01_u88C5_u6210_u5E27" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>在一段数据前后添加首部和尾部，用于<strong>帧界定</strong>（如果首尾不全，那么就是垃圾数据，应该丢弃）</p>
<p><strong>每个帧长度要小于最大传送单元MTU</strong></p>
<p>特殊：ASCII要用SOH(00000001)和EOT(00000100)界定</p>
<h3 id="u900F_u660E_u4F20_u8F93"><a href="#u900F_u660E_u4F20_u8F93" class="headerlink" title="透明传输"></a>透明传输</h3><ul>
<li><p><strong>定义:</strong> 保证<strong>无论哪种数据都能完好无损地传输(即使和界定符长得一样)</strong></p>
</li>
<li><p><strong>手段:</strong> 通过在字节前加转义字符(ESC) </p>
</li>
</ul>
<h3 id="u5DEE_u9519_u68C0_u6D4B"><a href="#u5DEE_u9519_u68C0_u6D4B" class="headerlink" title="差错检测"></a>差错检测</h3><p>差错检测只能做到<strong>凡是接受的帧都无差错</strong>，但无法保证<strong>帧丢失、重复、失序</strong>，因此不是<strong>可靠传输</strong></p>
<h4 id="u5FAA_u73AF_u5197_u4F59_u68C0_u6D4BCRC"><a href="#u5FAA_u73AF_u5197_u4F59_u68C0_u6D4BCRC" class="headerlink" title="循环冗余检测CRC"></a>循环冗余检测CRC</h4><ol>
<li>数据划分成组M，每组k位</li>
<li>在每组数据后加n位冗余码</li>
</ol>
<h5 id="u5197_u4F59_u7801_u5F97_u51FA_u65B9_u6CD5"><a href="#u5197_u4F59_u7801_u5F97_u51FA_u65B9_u6CD5" class="headerlink" title="冗余码得出方法"></a>冗余码得出方法</h5><ol>
<li>在M后添加n个0，得到X <code>M = 101001,n = 3</code> <code>X = 101001000</code></li>
<li>X除以事先规定的<code>n+1</code>位的P <code>P = 1101</code></li>
<li>得到商Q(没卵用)、余数R(所求的<strong>冗余码FCS</strong>)</li>
<li>得到拼接后的</li>
</ol>
<h5 id="u63A5_u6536_u7AEF_u68C0_u9A8C_u65B9_u6CD5"><a href="#u63A5_u6536_u7AEF_u68C0_u9A8C_u65B9_u6CD5" class="headerlink" title="接收端检验方法"></a>接收端检验方法</h5><p>把每一帧都除以P，检查得到余数R</p>
<p>如果R等于0，就通过</p>
<h3 id="u70B9_u5BF9_u70B9_u534F_u8BAEPPP"><a href="#u70B9_u5BF9_u70B9_u534F_u8BAEPPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h3><p>PC和ISP进行通讯时所使用的数据链路层协议</p>
<h4 id="u6240_u9700_u7279_u70B9"><a href="#u6240_u9700_u7279_u70B9" class="headerlink" title="所需特点"></a>所需特点</h4><ol>
<li>简单</li>
<li>封装成帧</li>
<li>透明</li>
<li>多种网络层协议</li>
<li>多种类型链路</li>
<li>差错检测</li>
<li>检测连接状态</li>
<li>最大传送单元</li>
<li>网络层地址协商</li>
<li>数据压缩协商</li>
</ol>
<h4 id="PPP_u7684_u5E27_u683C_u5F0F"><a href="#PPP_u7684_u5E27_u683C_u5F0F" class="headerlink" title="PPP的帧格式"></a>PPP的帧格式</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3w2U3O411F2A221Z1r1s/%E4%B8%8B%E8%BD%BD.jpeg?v=a9245ac9" alt=""></p>
<!--待续-->
<h3 id="u4F7F_u7528_u5E7F_u64AD_u4FE1_u9053_u7684_u6570_u636E_u94FE_u8DEF_u5C42"><a href="#u4F7F_u7528_u5E7F_u64AD_u4FE1_u9053_u7684_u6570_u636E_u94FE_u8DEF_u5C42" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><p>共享信道的两种方法</p>
<ol>
<li><strong>静态划分</strong> 内容见<strong>信道复用技术</strong></li>
<li><strong>动态媒体接入控制(多点接入)</strong> 随机介入、受控接入 </li>
</ol>
<p>逻辑链路两个子层</p>
<ul>
<li><strong>LLC:</strong> 逻辑链路控制</li>
<li><strong>MAC:</strong> 媒体接入控制</li>
</ul>
<p><strong>硬件地址、网卡地址、mac地址、物理地址相等</strong></p>
<ul>
<li><strong>适配器</strong> 将计算机内部并行的数据转换成适合网络传输串行数据(缓存区)</li>
</ul>
<h4 id="CSMA/CD_u534F_u8BAE"><a href="#CSMA/CD_u534F_u8BAE" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h4><ul>
<li><strong>以太网使用不可靠交付</strong> 尽最大能力交付，不负责查错，要是TCP发现错误，就要求重传，重传的帧被当做新的帧</li>
<li><strong>双向交替通讯</strong> 因为不能有冲突</li>
<li><strong>发送的不确定性</strong> 发送之后不一定会发送成功，所以需要</li>
<li><strong>争用期</strong> 碰撞窗口，以太网端到端往返的时间(2t)，经过争用期还未发生碰撞，意味着不会发生碰撞</li>
<li><strong>总线占用总时间</strong> A发送数据到发现碰撞时间(2μ-t)+人为干扰信号发送时间+单程端到端时间μ</li>
<li><strong>比特时间</strong> 1bit数据发送的时间</li>
<li><strong>帧间最小间隔</strong> 9.6μs，用于接收到数据的站清理缓存</li>
<li><strong>曼彻斯特编码</strong> </li>
</ul>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0q1W1E1m0F1q2C0j2t1z/bki-20100925171759-2006568241.jpg?v=794cd182" alt=""></p>
<h5 id="u591A_u70B9_u63A5_u5165"><a href="#u591A_u70B9_u63A5_u5165" class="headerlink" title="多点接入"></a>多点接入</h5><p>以太网是一种总线型网络</p>
<h5 id="u8F7D_u6CE2_u76D1_u542C"><a href="#u8F7D_u6CE2_u76D1_u542C" class="headerlink" title="载波监听"></a>载波监听</h5><p>市值是检测信道是否被占用，以此判断是否拥有发送权</p>
<h5 id="u78B0_u649E_u68C0_u6D4B"><a href="#u78B0_u649E_u68C0_u6D4B" class="headerlink" title="碰撞检测"></a>碰撞检测</h5><p>适配器边发送边监听信道上电压变化(两个信号叠加电压会增加)</p>
<h5 id="u4F20_u64AD_u65F6_u5EF6_u5BF9_u4E8E_u8F7D_u6CE2_u76D1_u542C_u7684_u5F71_u54CD"><a href="#u4F20_u64AD_u65F6_u5EF6_u5BF9_u4E8E_u8F7D_u6CE2_u76D1_u542C_u7684_u5F71_u54CD" class="headerlink" title="传播时延对于载波监听的影响"></a>传播时延对于载波监听的影响</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1r0K101y1N1N1u1G1W2U/2012070816390787.png?v=09baf204" alt=""></p>
<h5 id="u622A_u65AD_u4E8C_u8FDB_u5236_u7B97_u6CD5"><a href="#u622A_u65AD_u4E8C_u8FDB_u5236_u7B97_u6CD5" class="headerlink" title="截断二进制算法"></a>截断二进制算法</h5><ol>
<li>争用期t，是51.2μs，对于10Mb/s以太网，就是<code>64字节 == 512bit == 512比特时间</code></li>
<li>从[0~(2^k)-1]随机取出一个数r，重传应推后rt时间，<code>k = Min[重传次数，10]</code></li>
<li>当重传16次还没成功的话，就丢弃该帧，向高层报告</li>
</ol>
<h5 id="u5F3A_u5316_u78B0_u649E"><a href="#u5F3A_u5316_u78B0_u649E" class="headerlink" title="强化碰撞"></a>强化碰撞</h5><p>一旦数据站检测到发生碰撞，就连续发送32、48比特的人为干扰信号，以便让所有用户知道碰撞以发生。</p>
<h3 id="u4F7F_u7528_u5E7F_u64AD_u4FE1_u9053_u7684_u4EE5_u592A_u7F51"><a href="#u4F7F_u7528_u5E7F_u64AD_u4FE1_u9053_u7684_u4EE5_u592A_u7F51" class="headerlink" title="使用广播信道的以太网"></a>使用广播信道的以太网</h3><ul>
<li><strong>集线器</strong> 模拟线缆工作，实质上仍是总线型网络</li>
<li><strong>协议</strong> 使用CSMA/CD协议</li>
</ul>
<h4 id="u4FE1_u9053_u5229_u7528_u7387"><a href="#u4FE1_u9053_u5229_u7528_u7387" class="headerlink" title="信道利用率"></a>信道利用率</h4><ul>
<li><strong>以太网单程端到端时延</strong> τ</li>
<li><strong>帧发送时间</strong> T0</li>
<li><strong>参数a</strong> <code>a = τ/T0</code>，对于a -&gt; 0，一旦发生碰转就能立即被检出</li>
<li><strong>信道利用率</strong> 如果没有碰撞:<code>T0/(T0+τ) -&gt; 1/(1+a)</code></li>
</ul>
<h4 id="u4EE5_u592A_u7F51MAC_u5C42"><a href="#u4EE5_u592A_u7F51MAC_u5C42" class="headerlink" title="以太网MAC层"></a>以太网MAC层</h4><p><strong>MAC地址(硬件地址)</strong> 固化在硬件里的地址，前24位由IEEE指定，后24位由厂家指定，实质是<strong>适配器地址</strong></p>
<h5 id="MAC_u5E27_u683C_u5F0F"><a href="#MAC_u5E27_u683C_u5F0F" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0a1F0V0n252n2O103N3g/0_1328795116sk0V.gif.png?v=467c7e89" alt=""></p>
<h3 id="u4EE5_u592A_u7F51_u7684_u6269_u5C55"><a href="#u4EE5_u592A_u7F51_u7684_u6269_u5C55" class="headerlink" title="以太网的扩展"></a>以太网的扩展</h3><h4 id="u7269_u7406_u5C42_u6269_u5C55"><a href="#u7269_u7406_u5C42_u6269_u5C55" class="headerlink" title="物理层扩展"></a>物理层扩展</h4><p>通过一个主干集线器，将之前独立的以太网连接在一起</p>
<p><strong>带来的问题</strong></p>
<ol>
<li>扩大了碰撞域，但是带宽没变，大大降低了吞吐量</li>
<li>如果几个以太网使用技术不同，就不能用集线器扩展</li>
</ol>
<h4 id="u6570_u636E_u94FE_u8DEF_u5C42_u6269_u5C55"><a href="#u6570_u636E_u94FE_u8DEF_u5C42_u6269_u5C55" class="headerlink" title="数据链路层扩展"></a>数据链路层扩展</h4><ul>
<li><strong>网桥</strong> 工作在数据链路层，接到帧以后就检测目标MAC地址，查表决定接口或者丢弃</li>
</ul>
<h5 id="u7F51_u6865_u5185_u90E8_u7ED3_u6784"><a href="#u7F51_u6865_u5185_u90E8_u7ED3_u6784" class="headerlink" title="网桥内部结构"></a>网桥内部结构</h5><p>网桥通过<strong>转发表</strong>来转发帧，如果对不上就丢弃</p>
<p>网桥不改变源地址</p>
<h5 id="u4F18_u7F3A_u70B9"><a href="#u4F18_u7F3A_u70B9" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p><strong>优点</strong></p>
<ol>
<li>碰撞域减小</li>
<li>扩大以太网工作站数目</li>
<li>某个网挂了不影响其它</li>
<li>不同物理层、Mac子层、不同速率的以太网可以连在一起</li>
</ol>
</li>
<li><p><strong>缺点</strong></p>
<ol>
<li>增加时延</li>
<li>网桥缓存小可能溢出，导致丢帧</li>
<li>用户量大的时候可能导致阻塞</li>
</ol>
</li>
</ul>
<h5 id="u900F_u660E_u7F51_u6865"><a href="#u900F_u660E_u7F51_u6865" class="headerlink" title="透明网桥"></a>透明网桥</h5><ol>
<li>通过自学习算法建立转发表(记录帧首部的源地址)，或者更新转发表</li>
<li>存储</li>
<li>CRC校验，丢弃</li>
<li>转发(根据帧首部的目的地址)</li>
</ol>
<h5 id="u4EA4_u6362_u5F0F_u96C6_u7EBF_u5668_28_u4EE5_u592A_u7F51_u4EA4_u6362_u673A_29"><a href="#u4EA4_u6362_u5F0F_u96C6_u7EBF_u5668_28_u4EE5_u592A_u7F51_u4EA4_u6362_u673A_29" class="headerlink" title="交换式集线器(以太网交换机)"></a>交换式集线器(以太网交换机)</h5><p>就是一种多接口网桥，每一对相互通信的主机都无碰撞地传递数据</p>
<h2 id="u7F51_u7EDC_u5C42"><a href="#u7F51_u7EDC_u5C42" class="headerlink" title="网络层"></a>网络层</h2><p>网络层提供最大交付，不提供差错检验。</p>
<h3 id="u7F51_u9645_u534F_u8BAEIP"><a href="#u7F51_u9645_u534F_u8BAEIP" class="headerlink" title="网际协议IP"></a>网际协议IP</h3><h4 id="u4E00_u4E9B_u6982_u5FF5-1"><a href="#u4E00_u4E9B_u6982_u5FF5-1" class="headerlink" title="一些概念"></a>一些概念</h4><ul>
<li><strong>ARP</strong> 地址解析协议</li>
<li><strong>ICMP</strong> 网际控制报文协议</li>
<li><strong>网际组管理协议</strong> IGMP</li>
</ul>
<h4 id="u5404_u79CD_u8BBE_u5907"><a href="#u5404_u79CD_u8BBE_u5907" class="headerlink" title="各种设备"></a>各种设备</h4><ul>
<li><strong>物理层</strong> 转发器(集线器？)</li>
<li><strong>数据链路层</strong> 网桥(以太网网桥，交换机)</li>
<li><strong>网络层</strong> 路由器</li>
<li><strong>网络层以上</strong> 网关</li>
</ul>
<h4 id="IP_u5730_u5740_u7EC4_u6210"><a href="#IP_u5730_u5740_u7EC4_u6210" class="headerlink" title="IP地址组成"></a>IP地址组成</h4><ul>
<li><p><strong>IP地址由<code>&lt;网络号&gt;:&lt;主机号&gt;</code>组成</strong> 不过现在ABC这种分类已经成为历史</p>
<p>  <img src="https://d17oy1vhnax1f7.cloudfront.net/items/0o0M261t313V2m211b08/ip-di-zhi-fen-lei_clip_image001.png?v=90d0ab8a" alt=""></p>
</li>
<li><p><strong>IP地址是32位的二进制代码</strong></p>
</li>
</ul>
<h4 id="IP_u5730_u5740_u7279_u70B9"><a href="#IP_u5730_u5740_u7279_u70B9" class="headerlink" title="IP地址特点"></a>IP地址特点</h4><ol>
<li>IP地址是一个分等级的地址结构，路由器转发时候只根据网络号</li>
<li>IP地址是一个主机和一条链路的接口，因此路由器至少连接两个网络，所以至少拥有两个IP地址</li>
<li>IP地址中，所有网络号都是平等的</li>
</ol>
<h4 id="IP_u5730_u5740_u4E0E_u786C_u4EF6_u5730_u5740"><a href="#IP_u5730_u5740_u4E0E_u786C_u4EF6_u5730_u5740" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h4><p>硬件地址在<strong>数据链路层和物理层</strong>使用<br>IP地址在<strong>网络层和和以上各层</strong>使用</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1n3u223M3F0c0N1Q0P1T/082256050466766.png?v=06a62735" alt=""></p>
<ol>
<li>IP层只能见到IP层，数据链路层只看到数据链路层的帧</li>
<li>路由器只根据目的IP进行转发</li>
</ol>
<h4 id="u5730_u5740_u89E3_u6790_u534F_u8BAEARP"><a href="#u5730_u5740_u89E3_u6790_u534F_u8BAEARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><ul>
<li><p><strong>目的</strong> ARP用于<strong>通过IP找到对应的MAC地址</strong>(ARP攻击)</p>
</li>
<li><p><strong>方法</strong> </p>
</li>
</ul>
<ol>
<li>在主机ARP高速缓存中存放一个<strong>动态更新的IP-MAC地址映射表</strong></li>
<li>发送数据时，如果未记录某IP的地址，就广播(内容为<strong>自己的IP+自己的MAC+对方IP</strong>)</li>
<li>对应IP的主机接到广播回复MAC地址，顺便记下IP地址</li>
</ol>
<ul>
<li><strong>生存时间</strong> 10~20min之后删除映射关系</li>
</ul>
<h4 id="IP_u6570_u636E_u62A5_u683C_u5F0F"><a href="#IP_u6570_u636E_u62A5_u683C_u5F0F" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2g201G2K270U3o2E2U1L/1358164183_8713.png?v=c4463809" alt=""></p>
<p>TTL 就是生存时间，每次转发-1，变0就扔掉</p>
<h4 id="IP_u8F6C_u53D1_u5206_u7EC4_u7684_u6D41_u7A0B"><a href="#IP_u8F6C_u53D1_u5206_u7EC4_u7684_u6D41_u7A0B" class="headerlink" title="IP转发分组的流程"></a>IP转发分组的流程</h4><ul>
<li><strong>路由表只记录网络地址</strong></li>
<li><strong>路由表是下一跳地址、目的网络地址</strong></li>
<li><strong>特定主机路由</strong> 为特定目的主机指明路由</li>
<li><strong>默认路由</strong> 只要目的网络不是特定网络，全部交付给默认路由</li>
</ul>
<h5 id="u5206_u7EC4_u8F6C_u53D1_u7B97_u6CD5"><a href="#u5206_u7EC4_u8F6C_u53D1_u7B97_u6CD5" class="headerlink" title="分组转发算法"></a>分组转发算法</h5><ol>
<li>从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。</li>
<li>若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。</li>
<li>报告转发分组出错。 </li>
</ol>
<h3 id="u5212_u5206_u5B50_u7F51"><a href="#u5212_u5206_u5B50_u7F51" class="headerlink" title="划分子网"></a>划分子网</h3><p><code>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}</code></p>
<ul>
<li>子网对外仍是一个网络</li>
</ul>
<h3 id="u5B50_u7F51_u63A9_u7801"><a href="#u5B50_u7F51_u63A9_u7801" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul>
<li><p>子网掩码与IP进行与运算，1的部分为网络号，由此算出网络地址</p>
</li>
<li><p>路由器交换和记录信息，都要使用子网掩码</p>
</li>
</ul>
<h4 id="u5212_u5206_u5B50_u7F51_u60C5_u51B5_u4E0B_u8F6C_u53D1_u7B97_u6CD5"><a href="#u5212_u5206_u5B50_u7F51_u60C5_u51B5_u4E0B_u8F6C_u53D1_u7B97_u6CD5" class="headerlink" title="划分子网情况下转发算法"></a>划分子网情况下转发算法</h4><ol>
<li>从收到的分组的首部提取目的 IP 地址 D。</li>
<li>先用各网络的子网掩码和 D 逐位相“与”，看是否和<br>  相应的网络地址匹配。若匹配，则将分组直接交付。<br>  否则就是间接交付，执行(3)。</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则将<br>  分组传送给指明的下一跳路由器；否则，执行(4)。</li>
<li>对路由表中的每一行的子网掩码和 D 逐位相“与”，<br>  若其结果与该行的目的网络地址匹配，则将分组传送<br>  给该行指明的下一跳路由器；否则，执行(5)。</li>
<li>若路由表中有一个默认路由，则将分组传送给路由表<br>  中所指明的默认路由器；否则，执行(6)。</li>
<li>报告转发分组出错。</li>
</ol>
<h3 id="CIDR_u65E0_u5206_u7C7B_u5730_u5740"><a href="#CIDR_u65E0_u5206_u7C7B_u5730_u5740" class="headerlink" title="CIDR无分类地址"></a>CIDR无分类地址</h3><p><code>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}</code></p>
<p><code>128.14.32.0/20</code> 地址块的最小地址：<code>128.14.32.0</code><br><code>128.14.32.0/20</code> 地址块的最大地址：<code>128.14.47.255</code></p>
<p>转发时候，使用最长前缀匹配</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1t0X2q360A0B1g2k3x2T/屏幕快照%202016-11-28%20下午2.52.43.png?v=a59e9db2" alt=""></p>
<h3 id="ICMP__u7F51_u9645_u63A7_u5236_u62A5_u6587_u534F_u8BAE"><a href="#ICMP__u7F51_u9645_u63A7_u5236_u62A5_u6587_u534F_u8BAE" class="headerlink" title="ICMP 网际控制报文协议"></a>ICMP 网际控制报文协议</h3><ul>
<li>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去</li>
</ul>
<h4 id="ICMP_u7684_u534F_u8BAE"><a href="#ICMP_u7684_u534F_u8BAE" class="headerlink" title="ICMP的协议"></a>ICMP的协议</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0q1J1n2s3g2V0a0H3J0Y/屏幕快照%202016-11-28%20下午3.09.51.png?v=576c013c" alt=""></p>
<h4 id="u5E94_u7528"><a href="#u5E94_u7528" class="headerlink" title="应用"></a>应用</h4><ul>
<li>PING 测试连通性</li>
</ul>
<h4 id="ICMP_u62A5_u6587_u79CD_u7C7B"><a href="#ICMP_u62A5_u6587_u79CD_u7C7B" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h4><ul>
<li>ICMP差错报告报文</li>
<li>ICMP询问报文 </li>
</ul>
<h5 id="u5DEE_u9519_u62A5_u544A"><a href="#u5DEE_u9519_u62A5_u544A" class="headerlink" title="差错报告"></a>差错报告</h5><h6 id="u79CD_u7C7B"><a href="#u79CD_u7C7B" class="headerlink" title="种类"></a>种类</h6><ul>
<li>终点不可达 </li>
<li>源点抑制(Source quench)  </li>
<li>时间超过 </li>
<li>参数问题 </li>
<li>改变路由（重定向）(Redirect)  </li>
</ul>
<h6 id="ICMP_u683C_u5F0F"><a href="#ICMP_u683C_u5F0F" class="headerlink" title="ICMP格式"></a>ICMP格式</h6><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2U1P1K2r1x3p1g1G3J3K/屏幕快照%202016-11-28%20下午3.17.35.png?v=9a38c40d" alt=""></p>
<h6 id="u4E0D_u53D1_u9001_u7684_u60C5_u51B5"><a href="#u4E0D_u53D1_u9001_u7684_u60C5_u51B5" class="headerlink" title="不发送的情况"></a>不发送的情况</h6><ul>
<li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li>
<li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</li>
<li>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</li>
<li>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li>
</ul>
<h5 id="u8BE2_u95EE_u62A5_u6587"><a href="#u8BE2_u95EE_u62A5_u6587" class="headerlink" title="询问报文"></a>询问报文</h5><h6 id="u79CD_u7C7B-1"><a href="#u79CD_u7C7B-1" class="headerlink" title="种类"></a>种类</h6><p>回送请求和回答报文<br>时间戳请求和回答报文</p>
<h6 id="u4E0D_u518D_u4F7F_u7528_u7684_u60C5_u51B5"><a href="#u4E0D_u518D_u4F7F_u7528_u7684_u60C5_u51B5" class="headerlink" title="不再使用的情况"></a>不再使用的情况</h6><p>信息请求与回答报文<br>掩码地址请求和回答报文<br>路由器询问和通告报文 </p>
<h3 id="u56E0_u7279_u7F51_u8DEF_u7531_u9009_u62E9_u534F_u8BAE"><a href="#u56E0_u7279_u7F51_u8DEF_u7531_u9009_u62E9_u534F_u8BAE" class="headerlink" title="因特网路由选择协议"></a>因特网路由选择协议</h3><h4 id="u5185_u90E8_u7F51_u5173_u534F_u8BAERIP"><a href="#u5185_u90E8_u7F51_u5173_u534F_u8BAERIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h4><ul>
<li><strong>距离</strong> 到达该网络的经历的最少路由器数量，最多15个</li>
</ul>
<p>每个路由器维护自己到每一个目的网络的距离记录</p>
<h5 id="u8981_u70B9"><a href="#u8981_u70B9" class="headerlink" title="要点"></a>要点</h5><ol>
<li>仅和相邻路由器交换信息。 </li>
<li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 </li>
<li>按固定的时间间隔交换路由信息，例如每隔30秒。 </li>
<li>多级交换以后每个路由器都获得了到达所有网络的最短距离和下一条路由器地址</li>
</ol>
<h5 id="u8DDD_u79BB_u76F8_u90BB_u7B97_u6CD5"><a href="#u8DDD_u79BB_u76F8_u90BB_u7B97_u6CD5" class="headerlink" title="距离相邻算法"></a>距离相邻算法</h5><p>收到相邻路由器（其地址为 X）的一个 RIP 报文：</p>
<ol>
<li>将此RIP报文中的项目下一跳地址都改为X，距离+1</li>
<li><p>对修改后的RIP报文中的每一个项目，重复以下步骤：</p>
<p> 若项目中的目的网络不在路由表中，则把该项目加到路由表中。</p>
<p> 否则</p>
<p> 若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。</p>
<p> 否则 </p>
<p> 若收到项目中的距离小于路由表中的距离，则进行更新，</p>
<p> 否则，什么也不做。</p>
</li>
<li><p>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（距离为16表示不可达）。</p>
</li>
<li>返回。</li>
</ol>
<h5 id="u62A5_u6587_u683C_u5F0F"><a href="#u62A5_u6587_u683C_u5F0F" class="headerlink" title="报文格式"></a>报文格式</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0q1R0v0k2d1x3O3P0w03/屏幕快照%202016-11-28%20下午3.17.35.png?v=9b0935e1" alt=""></p>
<h5 id="u7F3A_u70B9"><a href="#u7F3A_u70B9" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>故障反馈慢，好消息传播快</li>
<li>开销小，随着网络增大二增大</li>
<li>最大距离15</li>
</ul>
<h4 id="u5185_u90E8_u7F51_u5173_u534F_u8BAEOSPF"><a href="#u5185_u90E8_u7F51_u5173_u534F_u8BAEOSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h4><p>使用Dijkstra算法(最短路径)</p>
<h5 id="u8981_u70B9-1"><a href="#u8981_u70B9-1" class="headerlink" title="要点"></a>要点</h5><ul>
<li>向所有路由器发送信息，通过洪泛法(每一个接到包的节点，如果不是给自己的，就直接丢给所有相邻节点)</li>
<li>每个路由器都能建立一个链路状态数据库，内容等于全网的拓扑结构图</li>
<li>通过IP数据报传输，数据很短</li>
<li></li>
</ul>
<h5 id="u533A_u57DF"><a href="#u533A_u57DF" class="headerlink" title="区域"></a>区域</h5><ul>
<li>划分区域是为了洪泛法局限于每个区域而不是整个网络</li>
<li>路由器只知道自己区域的拓扑图</li>
<li>主干区域，用于连通不同区域</li>
</ul>
<h5 id="u5206_u7C7B"><a href="#u5206_u7C7B" class="headerlink" title="分类"></a>分类</h5><ol>
<li>问候分组</li>
<li>数据库描述分组</li>
<li>链路状态分组</li>
<li>链路状态更新分组</li>
<li>链路状态确认分组</li>
</ol>
<h4 id="u5916_u90E8_u7F51_u5173_u534F_u8BAEBGP"><a href="#u5916_u90E8_u7F51_u5173_u534F_u8BAEBGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h4><p>BGP 是不同自治系统的路由器之间交换路由信息的协议</p>
<h5 id="BGP_u53D1_u8A00_u4EBA"><a href="#BGP_u53D1_u8A00_u4EBA" class="headerlink" title="BGP发言人"></a>BGP发言人</h5><ul>
<li><strong>BGP发言人</strong> 两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是 BGP 边界路由器，但也可以不是BGP边界路由器</li>
<li><strong>BGP交换路由信息</strong> 通过发言人之间的建立TCP连接交换</li>
</ul>
<h5 id="u5206_u7C7B-1"><a href="#u5206_u7C7B-1" class="headerlink" title="分类"></a>分类</h5><ol>
<li>打开报文</li>
<li>更新报文</li>
<li>保活报文</li>
<li>通知报文</li>
</ol>
<h4 id="u8DEF_u7531_u5668_u7ED3_u6784"><a href="#u8DEF_u7531_u5668_u7ED3_u6784" class="headerlink" title="路由器结构"></a>路由器结构</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/292B0e021L2E1g113J3t/QQ20161219-134848@2x.png?v=f4513b7b" alt=""></p>
<h4 id="u591A_u64AD"><a href="#u591A_u64AD" class="headerlink" title="多播"></a>多播</h4><p>IP多播流量发送到单个目标IP地址，但是由多个IP主机接收和处理，而不管这些主机在IP互联网络上所处的位置。一个主机侦听一个特定的IP多播地址，并接收发送到该IP地址的所有数据包。</p>
<h2 id="u4F20_u8F93_u5C42"><a href="#u4F20_u8F93_u5C42" class="headerlink" title="传输层"></a>传输层</h2><p>网络服务最高层，用户功能最底层，路由器用不着</p>
<h3 id="u5E94_u7528_u95F4_u901A_u8BAF"><a href="#u5E94_u7528_u95F4_u901A_u8BAF" class="headerlink" title="应用间通讯"></a>应用间通讯</h3><ul>
<li><strong>IP</strong> 提供主机间通讯</li>
<li><strong>TCP/UDP</strong> 提供进程间通讯</li>
</ul>
<h3 id="UDP_u548CTCP_u533A_u522B"><a href="#UDP_u548CTCP_u533A_u522B" class="headerlink" title="UDP和TCP区别"></a>UDP和TCP区别</h3><ul>
<li>UDP传输数据前不需要建立连接，TCP需要先三次握手</li>
<li>UDP传输UDP报文+用户数据报，TCP传输TCP报文</li>
</ul>
<h3 id="u7AEF_u53E3"><a href="#u7AEF_u53E3" class="headerlink" title="端口"></a>端口</h3><p>对外代表进程，是通信的终点，剩下的事情由TCP完成</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>不可靠交付，在IP数据报服务上增加了<strong>端口和差错</strong>检测功能</p>
<h4 id="u7279_u70B9"><a href="#u7279_u70B9" class="headerlink" title="特点"></a>特点</h4><ul>
<li>传输数据前不需要建立连接</li>
<li>尽最大努力交付</li>
<li>面向报文，没有拥塞控制(应用层给什么就传什么，一次就一个发送报文)</li>
<li>内部开销8字节</li>
<li>拥有<strong>伪首部</strong>，作用是计算检验和</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="u7279_u70B9-1"><a href="#u7279_u70B9-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>面向连接</li>
<li>只能点对点</li>
<li>可靠交付</li>
<li>全双工</li>
<li>是一种虚连接</li>
<li>可以根据情况划分报文段长短</li>
</ul>
<h4 id="u8FDE_u63A5"><a href="#u8FDE_u63A5" class="headerlink" title="连接"></a>连接</h4><ul>
<li>TCP的端点叫做<strong>套接字:socket</strong><br><code>TCP = {socket1,sockt2} = {(IP1:port1),(IP2,port2)}</code></li>
</ul>
<h4 id="u62A5_u6587_u6BB5_u683C_u5F0F"><a href="#u62A5_u6587_u6BB5_u683C_u5F0F" class="headerlink" title="报文段格式"></a>报文段格式</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0F2y131E3U3D3Z0w0c1D/QQ20161219-201439@2x.png?v=1b50d1e0" alt=""></p>
<h3 id="u53EF_u9760_u4F20_u8F93_u7684_u539F_u7406"><a href="#u53EF_u9760_u4F20_u8F93_u7684_u539F_u7406" class="headerlink" title="可靠传输的原理"></a>可靠传输的原理</h3><h4 id="u505C_u6B62_u7B49_u5F85_u534F_u8BAE"><a href="#u505C_u6B62_u7B49_u5F85_u534F_u8BAE" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><ul>
<li>分组和确认分组要<strong>编号</strong></li>
<li>发送完分组需要保存副本</li>
<li>这种可靠传输协议被称为<strong>自动重传请求ARQ</strong></li>
</ul>
<h5 id="u65E0_u5DEE_u9519_u60C5_u51B5"><a href="#u65E0_u5DEE_u9519_u60C5_u51B5" class="headerlink" title="无差错情况"></a>无差错情况</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0t2p3r3i172x2u0U3n0a/QQ20161219-193030@2x.png?v=ad616a92" alt=""></p>
<h5 id="u8D85_u65F6_u91CD_u4F20"><a href="#u8D85_u65F6_u91CD_u4F20" class="headerlink" title="超时重传"></a>超时重传</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2A0n3c3Q2G1y2A1F3h37/QQ20161219-193045@2x.png?v=3e827cfb" alt=""></p>
<h5 id="u786E_u8BA4_u4E22_u5931"><a href="#u786E_u8BA4_u4E22_u5931" class="headerlink" title="确认丢失"></a>确认丢失</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1W3B0U2D2U2G0S1g0b2W/QQ20161219-193401@2x.png?v=1bc6b101" alt=""></p>
<h5 id="u786E_u8BA4_u8FDF_u5230"><a href="#u786E_u8BA4_u8FDF_u5230" class="headerlink" title="确认迟到"></a>确认迟到</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3d0k0A0W1x0w2E3K0W0V/QQ20161219-193430@2x.png?v=14828d31" alt=""></p>
<h4 id="u6D41_u6C34_u7EBF_u4F20_u8F93"><a href="#u6D41_u6C34_u7EBF_u4F20_u8F93" class="headerlink" title="流水线传输"></a>流水线传输</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3R3U3K1p1u0L2U3l1T2o/QQ20161219-194233@2x.png?v=8a7bbfe6" alt=""></p>
<h5 id="u8FDE_u7EEDARQ_u534F_u8BAE"><a href="#u8FDE_u7EEDARQ_u534F_u8BAE" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h5><p>每次一口气发N组数据(例如0~5)，如果收到一个确认之后就移动一格(1~6)</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3D2w2S1P2u1A091Y3M2u/QQ20161219-195411@2x.png?v=c0d53922" alt=""></p>
<h5 id="u7D2F_u8BA1_u786E_u8BA4"><a href="#u7D2F_u8BA1_u786E_u8BA4" class="headerlink" title="累计确认"></a>累计确认</h5><p>每次回复表示，这个分组之前都确认收到了，确认之后，发送窗口后沿前移到回复位置</p>
<p><strong>缺点</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息</p>
<p><strong>Go-back-N</strong> 如果发送方发送了前5个分组，而中间的第3个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</p>
<h4 id="u5177_u4F53_u5B9E_u73B0"><a href="#u5177_u4F53_u5B9E_u73B0" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="u6CE8_u610F_u70B9"><a href="#u6CE8_u610F_u70B9" class="headerlink" title="注意点"></a>注意点</h5><ul>
<li>TCP连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口</li>
<li>TCP的可靠传输机制用字节的序号进行控制。TCP所有的确认都是基于序号而不是基于报文段</li>
<li>TCP两端的四个窗口经常处于动态变化之中</li>
<li>TCP连接的往返时间<em>RTT</em>也不是固定不变的。需要使用特定的算法估算较为合理的重传时间</li>
<li>接收窗口和发送窗口同步滑动</li>
</ul>
<h3 id="TCP_u62E5_u585E_u63A7_u5236"><a href="#TCP_u62E5_u585E_u63A7_u5236" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>对资源需求的总和 &gt; 可用资源时出现<strong>拥塞</strong></p>
<p>无拥塞控制会导致<strong>死锁</strong></p>
<h4 id="u6162_u5F00_u59CB_u548C_u62E5_u585E_u907F_u514D"><a href="#u6162_u5F00_u59CB_u548C_u62E5_u585E_u907F_u514D" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>发送方维持一个叫做<strong>拥塞窗口</strong>的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口</p>
<ul>
<li><strong>原则</strong> 只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数</li>
</ul>
<h5 id="u5B9E_u73B0"><a href="#u5B9E_u73B0" class="headerlink" title="实现"></a>实现</h5><p><strong>拥塞避免算法</strong></p>
<ol>
<li>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。</li>
<li>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。</li>
<li>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 </li>
</ol>
<p><strong>慢开始算法</strong></p>
<p>每个轮次，cwnd翻倍</p>
<p><strong>事实上</strong></p>
<p>有一个ssthresh上限</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法</li>
<li>一旦拥塞，ssthresh/2</li>
<li>一旦受到所有报文段确认，cwnd+1</li>
</ul>
<h4 id="u5FEB_u91CD_u4F20_u548C_u5FEB_u6062_u590D"><a href="#u5FEB_u91CD_u4F20_u548C_u5FEB_u6062_u590D" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。 </p>
<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</p>
<h5 id="u5B9E_u73B0-1"><a href="#u5B9E_u73B0-1" class="headerlink" title="实现"></a>实现</h5><ol>
<li>当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法</li>
<li>由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大</li>
</ol>
<h3 id="TCP_u8FD0_u8F93_u7BA1_u7406"><a href="#TCP_u8FD0_u8F93_u7BA1_u7406" class="headerlink" title="TCP运输管理"></a>TCP运输管理</h3><h4 id="u8FD0_u8F93_u4E09_u4E2A_u9636_u6BB5"><a href="#u8FD0_u8F93_u4E09_u4E2A_u9636_u6BB5" class="headerlink" title="运输三个阶段"></a>运输三个阶段</h4><ol>
<li>建立连接</li>
<li>数据传送</li>
<li>释放链接</li>
</ol>
<p>主动建立连接的进程叫『客户』，被动等待连接建立的叫『服务器』</p>
<h4 id="u8FDE_u63A5_u8FC7_u7A0B"><a href="#u8FDE_u63A5_u8FC7_u7A0B" class="headerlink" title="连接过程"></a>连接过程</h4><ol>
<li>客户发送请求(<code>SYN = 1,seq = x</code>)</li>
<li>服务器曲儿请求(<code>SYN = 1, ACK = 1, seq = y, ack= x + 1</code>)</li>
<li>客户机回复确认(<code>ACK = 1, seq = x + 1, ack = y + 1</code>)</li>
<li>数据传送</li>
<li>A发送释放请求(<code>FIN = 1, seq = u</code>)</li>
<li>B确认A的释放请求(<code>ACK = 1, seq = v, ack= u + 1</code>)，此时B还可以发送数据，A不可以发送数据</li>
<li>如果B也没有数据，通知TCP释放链接(<code>FIN = 1, ACK = 1, seq = w, ack= u + 1</code>)</li>
<li>A确认B的释放请求(<code>ACK = 1, seq = u + 1, ack = w + 1</code>)</li>
<li>B收到A的请求后彻底关闭，A等待2MSL后关闭</li>
</ol>
<h3 id="TCP_u72B6_u6001_u673A"><a href="#TCP_u72B6_u6001_u673A" class="headerlink" title="TCP状态机"></a>TCP状态机</h3><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2s0A0f2U0A0t2J2c3M1G/QQ20161221-081208@2x.png?v=e0e177f2" alt=""></p>
<h2 id="u5E94_u7528_u5C42"><a href="#u5E94_u7528_u5C42" class="headerlink" title="应用层"></a>应用层</h2><h3 id="u57DF_u540D_u7CFB_u7EDF"><a href="#u57DF_u540D_u7CFB_u7EDF" class="headerlink" title="域名系统"></a>域名系统</h3><h4 id="u57DF_u540D_u670D_u52A1_u5668"><a href="#u57DF_u540D_u670D_u52A1_u5668" class="headerlink" title="域名服务器"></a>域名服务器</h4><ul>
<li>一个服务器所负责管辖的（或有权限的）范围叫做区(zone)。</li>
<li>各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。</li>
<li>每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。</li>
<li>DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。  </li>
</ul>
<h5 id="u6839_u670D_u52A1_u5668"><a href="#u6839_u670D_u52A1_u5668" class="headerlink" title="根服务器"></a>根服务器</h5><p>根域名服务器并不直接把域名直接转换成 IP 地址,在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的 IP 地址告诉本地域名服务器</p>
<h5 id="u9876_u7EA7_u57DF_u540D_u670D_u52A1_u5668_28TLD__u670D_u52A1_u5668_29"><a href="#u9876_u7EA7_u57DF_u540D_u670D_u52A1_u5668_28TLD__u670D_u52A1_u5668_29" class="headerlink" title="顶级域名服务器(TLD 服务器)"></a>顶级域名服务器(TLD 服务器)</h5><p>负责一个区的域名服务器,当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户，下一步应当找哪一个权限域名服务器</p>
<h5 id="u672C_u5730_u57DF_u540D_u670D_u52A1_u5668"><a href="#u672C_u5730_u57DF_u540D_u670D_u52A1_u5668" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h5><p>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器</p>
<h4 id="u57DF_u540D_u89E3_u6790"><a href="#u57DF_u540D_u89E3_u6790" class="headerlink" title="域名解析"></a>域名解析</h4><h5 id="u8FED_u4EE3_u67E5_u8BE2"><a href="#u8FED_u4EE3_u67E5_u8BE2" class="headerlink" title="迭代查询"></a>迭代查询</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1Q1t2x1a1u1R1K3i371Y/QQ20161221-090518@2x.png?v=27712a19" alt=""></p>
<h5 id="u9012_u5F52_u67E5_u8BE2"><a href="#u9012_u5F52_u67E5_u8BE2" class="headerlink" title="递归查询"></a>递归查询</h5><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2j3H0X2h3o1B1o2H1m0A/QQ20161221-085458@2x.png?v=d9647859" alt=""></p>
<h3 id="u6587_u4EF6_u4F20_u9001_u534F_u8BAE"><a href="#u6587_u4EF6_u4F20_u9001_u534F_u8BAE" class="headerlink" title="文件传送协议"></a>文件传送协议</h3><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><h5 id="u7AEF_u53E3-1"><a href="#u7AEF_u53E3-1" class="headerlink" title="端口"></a>端口</h5><ul>
<li>21端口用于建立连接</li>
<li>20端口用于数据传输</li>
</ul>
<p><strong>不同端口是的协议更加简单，传输文件时还可以进行控制</strong></p>
<h4 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h4><h5 id="u7279_u70B9-2"><a href="#u7279_u70B9-2" class="headerlink" title="特点"></a>特点</h5><ol>
<li>使用UDP</li>
<li>只支持传输</li>
<li>每次传&lt;512字节</li>
<li>可对文件读写</li>
<li>支持ASCII 码或二进制传送</li>
</ol>
<h5 id="u5DE5_u4F5C"><a href="#u5DE5_u4F5C" class="headerlink" title="工作"></a>工作</h5><ol>
<li>发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号</li>
<li>发完数据后在规定时间内收不到确认就要重发数据PDU</li>
<li>发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败</li>
</ol>
<h3 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h3><p>通过 TCP 连接注册（即登录）到远地的另一个主机上</p>
<h3 id="u4E07_u7EF4_u7F51www"><a href="#u4E07_u7EF4_u7F51www" class="headerlink" title="万维网www"></a>万维网www</h3><p>万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息——这种访问方式称为<strong>链接</strong></p>
<p>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议HTTP</strong></p>
<p><strong>超文本标记语言 HTML</strong>使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><h4 id="u683C_u5F0F"><a href="#u683C_u5F0F" class="headerlink" title="格式"></a>格式</h4><p><code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></p>
<p>例如:<code>ftp://192.168.0.1:21/12334</code></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="u64CD_u4F5C_u8FC7_u7A0B"><a href="#u64CD_u4F5C_u8FC7_u7A0B" class="headerlink" title="操作过程"></a>操作过程</h4><ol>
<li>建立TCP连接</li>
<li>http请求</li>
<li>http相应报文</li>
<li>释放TCP</li>
</ol>
<h4 id="u70B9_u51FB_u9F20_u6807_u540E_u53D1_u751F_u7684_u4E8B"><a href="#u70B9_u51FB_u9F20_u6807_u540E_u53D1_u751F_u7684_u4E8B" class="headerlink" title="点击鼠标后发生的事"></a>点击鼠标后发生的事</h4><ol>
<li>浏览器分析超链接指向页面的url</li>
<li>浏览器向DNS请求url的IP地址</li>
<li>DNS返回解析出来的IP地址</li>
<li>服务器与客户机建立TCP连接</li>
<li>浏览器发出取文件命令 <code>GET xxx/index.htm</code></li>
<li>服务器给出响应，把index.htm发给浏览器</li>
<li>TCP释放</li>
<li>浏览器显示</li>
</ol>
<h4 id="u4EE3_u7406_u670D_u52A1_u5668"><a href="#u4EE3_u7406_u670D_u52A1_u5668" class="headerlink" title="代理服务器"></a>代理服务器</h4><p>万维网高速缓存,代表服务器发出http请求</p>
<h4 id="http_u62A5_u6587"><a href="#http_u62A5_u6587" class="headerlink" title="http报文"></a>http报文</h4><ol>
<li>请求报文 开始行(<code>方法+空格+URL+空格+版本</code>)</li>
<li>响应报文 开始行(<code>版本+空格+状态码+空格+短语</code>)</li>
</ol>
<ul>
<li>状态码 1开头: 通知信息 2开头: 成功 3开头: 重定向 4开头: 客户差错 5开头: 服务器差错</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie 被用于跟踪用户，状态信息</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机组成笔记]]></title>
      <url>http://pengtianhao.com/2016/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>计算机组成的一些总结，持续更新</p>
</blockquote>
<a id="more"></a>
<h2 id="u7EEA_u8BBA"><a href="#u7EEA_u8BBA" class="headerlink" title="绪论"></a>绪论</h2><h3 id="u51AF_u8BFA_u4F9D_u66FC_u6A21_u578B"><a href="#u51AF_u8BFA_u4F9D_u66FC_u6A21_u578B" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h3><p>原来以ALU为中心，现代以存储器为中心</p>
<ul>
<li>输入输出IO</li>
<li>控制CU</li>
<li>算数逻辑ALU</li>
<li>存储Memory</li>
</ul>
<h3 id="u8BA1_u7B97_u673A_u7684_u57FA_u672C_u7ED3_u6784"><a href="#u8BA1_u7B97_u673A_u7684_u57FA_u672C_u7ED3_u6784" class="headerlink" title="计算机的基本结构"></a>计算机的基本结构</h3><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3U2U050v1a3C0z1S012x/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-27%20%E4%B8%8B%E5%8D%886.45.26.png?v=4f85efc9" alt=""></p>
<h3 id="u8BA1_u7B97_u673A_u5C42_u6B21_u7ED3_u6784"><a href="#u8BA1_u7B97_u673A_u5C42_u6B21_u7ED3_u6784" class="headerlink" title="计算机层次结构"></a>计算机层次结构</h3><ol>
<li>应用语言虚拟机</li>
<li>高级语言虚拟机</li>
<li>汇编语言虚拟机</li>
<li>操作系统虚拟机</li>
<li>机器语言机器</li>
<li>微程序机器</li>
</ol>
<h3 id="u6027_u80FD_u8BC4_u4EF7_u6307_u6807"><a href="#u6027_u80FD_u8BC4_u4EF7_u6307_u6807" class="headerlink" title="性能评价指标"></a>性能评价指标</h3><ul>
<li><strong>字长</strong> 一个word由几个byte组成</li>
<li><strong>主存容量</strong> 以byte为单位</li>
<li><strong>处理速度</strong> 每条指令平均时钟周期CPI,百万条指令每秒 MIPS</li>
<li><strong>主频</strong> 每秒时钟周期数</li>
</ul>
<h2 id="u8BA1_u7B97_u673A_u4E2D_u4FE1_u606F_u7684_u8868_u793A_u4E0E_u8FD0_u7B97"><a href="#u8BA1_u7B97_u673A_u4E2D_u4FE1_u606F_u7684_u8868_u793A_u4E0E_u8FD0_u7B97" class="headerlink" title="计算机中信息的表示与运算"></a>计算机中信息的表示与运算</h2><h3 id="u6570_u636E_u7684_u8868_u793A"><a href="#u6570_u636E_u7684_u8868_u793A" class="headerlink" title="数据的表示"></a>数据的表示</h3><h4 id="u5B9A_u70B9_u6570_u7684_u8868_u793A"><a href="#u5B9A_u70B9_u6570_u7684_u8868_u793A" class="headerlink" title="定点数的表示"></a>定点数的表示</h4><h5 id="u539F_u7801_u8868_u793A_u6CD5"><a href="#u539F_u7801_u8868_u793A_u6CD5" class="headerlink" title="原码表示法"></a>原码表示法</h5><p>字节的最高位为符号位</p>
<ul>
<li><p><strong>定点整数</strong> 范围 <code>-(2^(n-1)+1) ~ 2^(N-1)-1</code></p>
<pre><code>+1010000 = 0,1010000
-1010000 = 1,1010000
</code></pre></li>
<li><p><strong>定点小数</strong> 范围 <code>-(1-2^-(n-1)) ~ 1-2^-(N-1)</code></p>
<pre><code>+0.1010000 = 0.1010000
-0.1010000 = 1.1010000
</code></pre></li>
</ul>
<h5 id="u8865_u7801_u8868_u793A_u6CD5"><a href="#u8865_u7801_u8868_u793A_u6CD5" class="headerlink" title="补码表示法"></a>补码表示法</h5><ul>
<li><strong>转换方法</strong> 正数的补码就是原码，复数的补码是除符号位外取反，最低位加一</li>
<li><strong>注意</strong> 10000000，被用作表示-128</li>
</ul>
<h5 id="u53CD_u7801_u8868_u793A_u6CD5"><a href="#u53CD_u7801_u8868_u793A_u6CD5" class="headerlink" title="反码表示法"></a>反码表示法</h5><ul>
<li><strong>转换方法</strong> 正数与原码相同，负数时逐位取反，再加上符号位</li>
</ul>
<h5 id="u79FB_u7801_u8868_u793A_u6CD5_28_u4EC5_u9488_u5BF9_u5B9A_u70B9_u6574_u6570_29"><a href="#u79FB_u7801_u8868_u793A_u6CD5_28_u4EC5_u9488_u5BF9_u5B9A_u70B9_u6574_u6570_29" class="headerlink" title="移码表示法(仅针对定点整数)"></a>移码表示法(仅针对定点整数)</h5><p>最高位+1，用于比大小</p>
<h4 id="u6D6E_u70B9_u6570_u7684_u8868_u793A"><a href="#u6D6E_u70B9_u6570_u7684_u8868_u793A" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><p>使用科学计数法 <code>N = M*R^E</code></p>
<table>
<thead>
<tr>
<th>Es</th>
<th style="text-align:center">E1</th>
<th style="text-align:right">E2</th>
<th>…</th>
<th style="text-align:center">Em</th>
<th style="text-align:right">Ms</th>
<th>M1</th>
<th style="text-align:center">M2</th>
<th style="text-align:right">…</th>
<th>M(n-1)</th>
<th style="text-align:center">Mn</th>
</tr>
</thead>
<tbody>
<tr>
<td>阶符</td>
<td style="text-align:center">阶值</td>
<td style="text-align:right">阶值</td>
<td>…</td>
<td style="text-align:center">阶值</td>
<td style="text-align:right">尾符</td>
<td>尾数绝对值</td>
<td style="text-align:center">尾数绝对值</td>
<td style="text-align:right">…</td>
<td>尾数绝对值</td>
<td style="text-align:center">尾数绝对值</td>
</tr>
</tbody>
</table>
<h5 id="u89C4_u683C_u5316"><a href="#u89C4_u683C_u5316" class="headerlink" title="规格化"></a>规格化</h5><p>要求尾数最高位为1，溢出条件是阶码变全零</p>
<ul>
<li><strong>下溢</strong> 规格化导致阶码小于零(其实就是数字太小导致机器读不出来)，此时尾数被强制置零，称为<strong>机器零</strong>，此时机器<strong>正常运行</strong></li>
<li><strong>上溢</strong> 规格化导致阶码全1后又变为全0，发生<strong>溢出错误</strong>，产生中断</li>
</ul>
<h4 id="u5B9A_u70B9_u6570_u7684_u8BA1_u7B97"><a href="#u5B9A_u70B9_u6570_u7684_u8BA1_u7B97" class="headerlink" title="定点数的计算"></a>定点数的计算</h4><h5 id="u903B_u8F91_u8FD0_u7B97"><a href="#u903B_u8F91_u8FD0_u7B97" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><ol>
<li>与(逻辑乘)</li>
<li>或(逻辑加)</li>
<li>非</li>
<li>异或</li>
</ol>
<h5 id="u79FB_u4F4D_u8FD0_u7B97"><a href="#u79FB_u4F4D_u8FD0_u7B97" class="headerlink" title="移位运算"></a>移位运算</h5><p><strong>规则</strong> 在<strong><em>原码</em></strong>情况下，先丢掉符号位，其他位左右移，空位补0</p>
<p><strong>补码的右移，反码</strong>情况下补1</p>
<h5 id="u52A0_u51CF_u6CD5"><a href="#u52A0_u51CF_u6CD5" class="headerlink" title="加减法"></a>加减法</h5><p>加减法都需在<strong><em>补码</em></strong>下使用，注意字长</p>
<pre><code>[X+Y]补 = [X]补+[Y]补
[X-Y]补 = [X]补+[-Y]补
</code></pre><ul>
<li><strong>求<code>[-Y]</code>的方法</strong> 连同符号位逐位取反，末位加一</li>
</ul>
<h6 id="u53CC_u7B26_u53F7_u4F4D"><a href="#u53CC_u7B26_u53F7_u4F4D" class="headerlink" title="双符号位"></a>双符号位</h6><p>双符号位可以保存溢出状态，<strong>双符号位不同</strong>，发生溢出</p>
<p>实际状态下，加法器还是使用单符号位，通过对进位和最高符号位进行<strong>异或</strong>(可以看作先使用双符号位，异或之后抛弃最高位)</p>
<h5 id="u4E58_u6CD5_u8FD0_u7B97"><a href="#u4E58_u6CD5_u8FD0_u7B97" class="headerlink" title="乘法运算"></a>乘法运算</h5><p>乘数A，被乘数B，部分积 x = 0</p>
<h6 id="u539F_u7801_u4E00_u4F4D_u4E58"><a href="#u539F_u7801_u4E00_u4F4D_u4E58" class="headerlink" title="原码一位乘"></a>原码一位乘</h6><ul>
<li><strong>方法</strong> A乘以B的末位，加x，左移一位，得到新的部分积</li>
</ul>
<h6 id="u8865_u7801_u4E00_u4F4D_u4E58"><a href="#u8865_u7801_u4E00_u4F4D_u4E58" class="headerlink" title="补码一位乘"></a>补码一位乘</h6><p>略</p>
<h5 id="u9664_u6CD5_u8FD0_u7B97"><a href="#u9664_u6CD5_u8FD0_u7B97" class="headerlink" title="除法运算"></a>除法运算</h5><h6 id="u539F_u7801_u6062_u590D_u4F59_u6570_u6CD5"><a href="#u539F_u7801_u6062_u590D_u4F59_u6570_u6CD5" class="headerlink" title="原码恢复余数法"></a>原码恢复余数法</h6><ul>
<li>这个方法使用<strong>双符号位</strong></li>
<li>被除数用绝对值运算，最后再带符号</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统笔记]]></title>
      <url>http://pengtianhao.com/2016/10/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>操作系统的一些总结，持续更新</p>
</blockquote>
<a id="more"></a>
<h2 id="u5BFC_u8BBA"><a href="#u5BFC_u8BBA" class="headerlink" title="导论"></a>导论</h2><p>操作系统提供了使用各种计算机资源的方法，可以看作资源分配器。</p>
<p><strong>控制和分配I/O资设备资源的功能集合</strong></p>
<h3 id="u5185_u6838"><a href="#u5185_u6838" class="headerlink" title="内核"></a>内核</h3><p>为减少系统本身的开销，往往将一些与硬件紧密相关的（如中断处理程序、设备驱动程序等）、基本的、公共的、运行频率较高的模块（如时钟管理、进程调度等）以及关键性数据结构独立开来，使之常驻内存，并对他们进行保护。通常把这一部分称之为操作系统的内核</p>
<p>严格来说，内核并不是必须的，只不过为了方便把这些功能绑在一起。</p>
<h3 id="u4E2D_u65AD_u548C_u9677_u9631"><a href="#u4E2D_u65AD_u548C_u9677_u9631" class="headerlink" title="中断和陷阱"></a>中断和陷阱</h3><h4 id="u4E2D_u65AD"><a href="#u4E2D_u65AD" class="headerlink" title="中断"></a>中断</h4><p><strong>出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。</strong></p>
<p>程序中断是由外部设备通过CPU的中断请求线向CPU提出的。在一定条件下，CPU响应中断后，暂停源程序的执行，转至为外设服务的中断处理程序。中断处理程序可以按照所要完成的任务编写与过程类似的程序段。在程序段最后执行一条中断返回指令返回主程序，继续按原顺序执行。</p>
<h4 id="u9677_u9631"><a href="#u9677_u9631" class="headerlink" title="陷阱"></a>陷阱</h4><p><strong>指的是当异常或者中断发生时，处理器捕捉到一个执行线程，并且将控制权转移到操作系统中某一个固定地址的机制。</strong></p>
<p>计算机有两种运行模式：用户态， 内核态。 其中操作系统运行在内核态，在内核态中，操作系统具有对所有硬件的完全访问权限，可以使机器运行任何指令；相反，用户程序运行在用户态，在用户态下，软件只能使用少数指令，它们并不具备直接访问硬件的权限。这就出现了问题，假如软件需要访问硬件或者需要调用内核中的函数该怎么办呢，这就是陷阱的作用了。陷阱指令可以使执行流程从用户态陷入内核（这也就是为什么叫做陷阱，而不是捕猎的陷阱）并把控制权转移给操作系统，使得用户程序可以调用内核函数和使用硬件从而获得操作系统所提供的服务，比如用视频软件放一个电影，视频软件就发出陷阱使用显示器和声卡从而访问硬件。</p>
<h3 id="u5B58_u50A8_u7ED3_u6784_u548CI/O"><a href="#u5B58_u50A8_u7ED3_u6784_u548CI/O" class="headerlink" title="存储结构和I/O"></a>存储结构和I/O</h3><p>存储以RAM为中心</p>
<p>I/O分大块数据和少量数据</p>
<ul>
<li><p><strong>少量数据</strong> 直接产生中断，比如鼠标键盘操作</p>
</li>
<li><p><strong>大块数据</strong> 设备通过DMA(直接内存访问)访问内存，按块产生中断，提高CPU效率，比如传输文件</p>
</li>
</ul>
<h3 id="u64CD_u4F5C_u7CFB_u7EDF_u7ED3_u6784"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u7ED3_u6784" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul>
<li><strong>多道程序设计</strong> 通过组织作业使得cpu总有事情做（其实就是把进程放在一件事情做完了立即）</li>
<li><strong>分时系统</strong> 是多道程序设计的延伸（其实就是通过不断地中断，不断wait和ready来实现的）</li>
<li><strong>作业池</strong> 所有驻留在磁盘等待分配内存的作业的集合（也就是备胎~~）</li>
<li><strong>作业调度</strong> 多个作业需要调入内存但是没有内存，操作系统做出选择的行为</li>
<li><strong>CPU调度</strong> 多个任务需要同时执行，操作系统做出选择的行为</li>
</ul>
<h3 id="u53CC_u91CD_u6A21_u5F0F"><a href="#u53CC_u91CD_u6A21_u5F0F" class="headerlink" title="双重模式"></a>双重模式</h3><ul>
<li><p>分为<strong>用户模式</strong>和<strong>系统模式</strong></p>
</li>
<li><p>双重模式主要是区分<strong>系统代码</strong>和<strong>用户代码</strong></p>
</li>
<li><p>设置一个<strong>模式位(一个flag)</strong>来标记当前模式:用户模式=1，系统模式=0</p>
</li>
<li><p>当用户程序需要操作系统服务的时候，使用系统调用，然后转到内核模式</p>
</li>
</ul>
<p>大概就是下面这个图，来源是msdn</p>
<p><img src="https://i-msdn.sec.s-msft.com/dynimg/IC535109.png" alt=""></p>
<h4 id="u7528_u6237_u6A21_u5F0F"><a href="#u7528_u6237_u6A21_u5F0F" class="headerlink" title="用户模式"></a>用户模式</h4><h4 id="u7CFB_u7EDF_u6A21_u5F0F_uFF08_u8FDB_u7A0B_u6A21_u5F0F_u3001_u5185_u6838_u6A21_u5F0F_uFF09"><a href="#u7CFB_u7EDF_u6A21_u5F0F_uFF08_u8FDB_u7A0B_u6A21_u5F0F_u3001_u5185_u6838_u6A21_u5F0F_uFF09" class="headerlink" title="系统模式（进程模式、内核模式）"></a>系统模式（进程模式、内核模式）</h4><ul>
<li><strong>特权指令</strong> 能引起损害的机器指令</li>
</ul>
<h2 id="u64CD_u4F5C_u7CFB_u7EDF_u7ED3_u6784-1"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u7ED3_u6784-1" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p><strong>系统调用 -&gt; API函数 -&gt; 库函数 -&gt; SHELL</strong></p>
<h3 id="u64CD_u4F5C_u7CFB_u7EDF_u670D_u52A1"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u670D_u52A1" class="headerlink" title="操作系统服务"></a>操作系统服务</h3><ul>
<li>用户界面</li>
<li>程序执行</li>
<li>I/O操作</li>
<li>文件系统操作</li>
<li>通信</li>
<li>错误检测</li>
<li>资源分配</li>
<li>统计</li>
<li>保护</li>
</ul>
<h3 id="u64CD_u4F5C_u7CFB_u7EDF_u7684_u7528_u6237_u63A5_u53E3"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u7684_u7528_u6237_u63A5_u53E3" class="headerlink" title="操作系统的用户接口"></a>操作系统的用户接口</h3><p>也就是命令解释程序——外壳（shell）</p>
<p>现在已经不属于操作系统，以前是。为了方便修改外壳，变成各种操作系统（比如安卓）</p>
<h3 id="u7CFB_u7EDF_u8C03_u7528"><a href="#u7CFB_u7EDF_u8C03_u7528" class="headerlink" title="系统调用"></a>系统调用</h3><p>内核提供一系列具备预定功能的函数，通过一组称为系统调用（system call)的接口呈现给用户</p>
<ul>
<li><p><strong>程序通过API访问系统调用</strong> （为什么？<strong>将常用操作的系统调用封装起来，方便调用</strong>）</p>
</li>
<li><p><strong>API、系统调用和操作系统的关系</strong>程序运行函数-&gt;用户模式切换到内核模式-&gt;执行系统调用-&gt;返回</p>
</li>
<li><p><strong>参数传递：</strong></p>
</li>
</ul>
<ol>
<li>寄存器传递（参数较少）</li>
<li>块传递，将参数房内存块中，将块地址传给寄存器</li>
<li>堆栈传递，参数压栈，调用时弹出</li>
</ol>
<ul>
<li><strong>类型</strong> </li>
</ul>
<ol>
<li>进程控制</li>
<li>文件管理</li>
<li>设备管理</li>
<li>信息维护</li>
<li>通信</li>
</ol>
<h3 id="u64CD_u4F5C_u7CFB_u7EDF_u7ED3_u6784-2"><a href="#u64CD_u4F5C_u7CFB_u7EDF_u7ED3_u6784-2" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><h4 id="u7B80_u5355_u7ED3_u6784"><a href="#u7B80_u5355_u7ED3_u6784" class="headerlink" title="简单结构"></a>简单结构</h4><p>上一层可以访问下面所有层</p>
<h5 id="MS-DOS"><a href="#MS-DOS" class="headerlink" title="MS-DOS"></a>MS-DOS</h5><p>单任务操作系统</p>
<p><strong>层级：</strong> BIOS设备驱动-&gt;MS-DOS设备驱动-&gt;常驻系统程序-&gt;应用程序</p>
<ul>
<li><strong>系统启动时</strong> 装入内核，命令解释程序，剩下大量内存空间</li>
<li><strong>程序运行时</strong> 压缩命令解释程序，内存中装入进程</li>
</ul>
<h5 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h5><p><strong>层级：</strong> 设备驱动程序-&gt;内核-&gt;shell之类的-&gt;应用程序</p>
<h4 id="u5206_u5C42_u7ED3_u6784"><a href="#u5206_u5C42_u7ED3_u6784" class="headerlink" title="分层结构"></a>分层结构</h4><ul>
<li>模块化，每一级只能访问下一集（不停地封装？）</li>
</ul>
<p><strong>层级：</strong> 内核和系统调用-&gt;系统程序-&gt;外壳-&gt;应用程序</p>
<h4 id="u5FAE_u5185_u6838"><a href="#u5FAE_u5185_u6838" class="headerlink" title="微内核"></a>微内核</h4><ul>
<li><p>只保留进程、内存管理、进程之间通讯</p>
</li>
<li><p>代码少，易移植，稳定性高</p>
</li>
</ul>
<h4 id="u6A21_u5757_u5316_u5185_u6838"><a href="#u6A21_u5757_u5316_u5185_u6838" class="headerlink" title="模块化内核"></a>模块化内核</h4><ul>
<li><p>面向对象方法</p>
</li>
<li><p>核组件直接相互独立</p>
</li>
<li><p>模块之间可以互相调用</p>
</li>
</ul>
<p>Mac OS 采用了模块化和微内核的混合</p>
<h3 id="u865A_u62DF_u673A"><a href="#u865A_u62DF_u673A" class="headerlink" title="虚拟机"></a>虚拟机</h3><ul>
<li><p>其实是一个跑在主操作系统上的进程</p>
</li>
<li><p>将硬件资源抽象成若干不同的执行环境</p>
</li>
<li><p>提供裸机相同接口</p>
</li>
<li><p>通过CPU调度和虚拟内存，使每个内存都认为有自己的处理器和自己的内存</p>
</li>
</ul>
<h2 id="u8FDB_u7A0B"><a href="#u8FDB_u7A0B" class="headerlink" title="进程"></a>进程</h2><h3 id="u6982_u5FF5"><a href="#u6982_u5FF5" class="headerlink" title="概念"></a>概念</h3><p>进程是执行中的程序，现代分时系统（多任务系统？）的工作单元</p>
<p>进程不是代码，是代码段和指令、文件、堆栈段、数据段、堆等</p>
<h4 id="u8FDB_u7A0B_u7684_u72B6_u6001"><a href="#u8FDB_u7A0B_u7684_u72B6_u6001" class="headerlink" title="进程的状态"></a>进程的状态</h4><ul>
<li>新建：进程创建中</li>
<li>运行：指令正在被执行</li>
<li>等待：等待某事件出现（I/O完成或收到某个信号）</li>
<li>就绪：进程等待被分配给处理器</li>
<li>终止：执行完毕</li>
</ul>
<p>一般的话流程是</p>
<p>new-&gt;ready-&gt;running(1. 中断，回到ready 2. 等待I/O或者事件，到waiting，之后又回到ready)-&gt;terminated</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1T1S443f3P471j0o312x/timg.jpeg?v=f8f55afc" alt="流程图"></p>
<p>每个时刻<strong>只有一个进程</strong>处于运行状态，其他进程都处于就绪或者等待状态</p>
<h4 id="u8FDB_u7A0B_u63A7_u5236_u5757_28PCB_29"><a href="#u8FDB_u7A0B_u63A7_u5236_u5757_28PCB_29" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h4><p>每个进程在操作系统内部都有一个进程控制块</p>
<p>包含内容有:</p>
<ul>
<li>进程状态：new、ready等</li>
<li>程序计数器：下一条指令地址</li>
<li>cpu寄存器：</li>
<li>cpu调度信息：进程优先级、调度队列之真</li>
<li>内存管理信息机制寄存器，内存范围等</li>
<li>记账信息：cpu时间、实际使用时间等</li>
<li>I/O状态信息：I/O</li>
<li>指针用于进程调度</li>
</ul>
<h3 id="u8FDB_u7A0B_u8C03_u5EA6"><a href="#u8FDB_u7A0B_u8C03_u5EA6" class="headerlink" title="进程调度"></a>进程调度</h3><p><strong>进程调度</strong> 选择一个可用进程到CPU执行</p>
<h4 id="u8C03_u5EA6_u961F_u5217"><a href="#u8C03_u5EA6_u961F_u5217" class="headerlink" title="调度队列"></a>调度队列</h4><p>作业队列-&gt;就绪队列</p>
<h4 id="u8C03_u5EA6_u7A0B_u5E8F"><a href="#u8C03_u5EA6_u7A0B_u5E8F" class="headerlink" title="调度程序"></a>调度程序</h4><p>进程选择是由<strong>调度程序</strong>执行的</p>
<ul>
<li><p><strong>长期调度程序</strong> </p>
<p>  <strong>方向</strong> 从存储设备缓冲池中选择进程，并装入内存执行</p>
<p>  <strong>作用</strong> 增加内存进程数量</p>
<p>  <strong>触发条件</strong> 有进程离开内存</p>
<p>  <strong>频率</strong> 几秒到几分钟</p>
<p>  <strong>原则</strong> 维护系统稳定，合理搭配以IO为主和以CPU为主的进程</p>
</li>
<li><p><strong>短期调度程序</strong> </p>
<p>  <strong>方向</strong> 就绪队列-&gt;CPU</p>
<p>  <strong>作用</strong> 提高CPU利用率</p>
<p>  <strong>触发条件</strong> CPU空闲</p>
<p>  <strong>频率</strong> 几毫秒</p>
<p>  <strong>原则</strong> 取决于调度算法</p>
</li>
</ul>
<h4 id="u4E0A_u4E0B_u6587_u5207_u6362"><a href="#u4E0A_u4E0B_u6587_u5207_u6362" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>当中断发生时候，需要<strong>状态保存</strong>，并且在中断结束之后，<strong>状态恢复</strong></p>
<p>将CPU切换到另一个进程需要保存当前进程的状态并回复另一个进程的状态，这叫上下文切换</p>
<h3 id="u8FDB_u7A0B_u64CD_u4F5C"><a href="#u8FDB_u7A0B_u64CD_u4F5C" class="headerlink" title="进程操作"></a>进程操作</h3><h4 id="u8FDB_u7A0B_u521B_u5EFA"><a href="#u8FDB_u7A0B_u521B_u5EFA" class="headerlink" title="进程创建"></a>进程创建</h4><p>进程能通过创建多个新进程</p>
<p>创建进程称为<strong>父进程</strong></p>
<p>新进程称为<strong>子进程</strong></p>
<p><strong>pid</strong> 进程标识符</p>
<p><strong>fork()</strong> 创建进程</p>
<pre><code>pid_t pid;
pid = fork();//这时候子进程创建，此时父线程的pid == 子线程标识符，子线程 pid == 0
</code></pre><p><strong>wait()</strong> 主进程使用wait等待子进程结束</p>
<p>父进程和子进程都继续执行fork()之后的代码</p>
<h4 id="u8FDB_u7A0B_u95F4_u901A_u8BAF"><a href="#u8FDB_u7A0B_u95F4_u901A_u8BAF" class="headerlink" title="进程间通讯"></a>进程间通讯</h4><p>系统的执行进程分为协作进程和独立进程，协作进程需要进行进程间通讯</p>
<ol>
<li><strong>共享内存</strong> A与B进程都从某块内存读取数据，比较快</li>
<li><strong>消息传递</strong> A把消息传到内核，B从内核中获取，简单无冲突，适合少量数据</li>
</ol>
<h5 id="u6D88_u606F_u4F20_u9012_u7CFB_u7EDF"><a href="#u6D88_u606F_u4F20_u9012_u7CFB_u7EDF" class="headerlink" title="消息传递系统"></a>消息传递系统</h5><ol>
<li><strong>直接or间接</strong> 直接通信：发送接收有明确进程名称<code>send(P,message)/receive(Q(id),message)</code> 间接通信：收发都在指定邮箱A进行<code>send(A,message)/receive(A,message)</code></li>
<li><strong>同步或异步通信（阻塞或非阻塞）</strong> 接收都可以选择是否阻塞</li>
<li><strong>自动或显式缓冲</strong> 零容量、有限容量、无限容量，原理就是如果容量满，就必须阻塞发送 </li>
</ol>
<h2 id="u7EBF_u7A0B"><a href="#u7EBF_u7A0B" class="headerlink" title="线程"></a>线程</h2><p><strong>进程和进程的区别</strong></p>
<ol>
<li>进程拥有独立的地址空间，线程共享进程的地址空间</li>
<li>线程之间共享进程的代码数据和文件。寄存器和栈不共享</li>
<li>线程不能独立存在必须依附于进程，一个进程可以创建多个线程</li>
<li>进程是操作系统分配资源的单位，线程是cpu调度中的单位</li>
</ol>
<h3 id="u591A_u7EBF_u7A0B_u6A21_u578B"><a href="#u591A_u7EBF_u7A0B_u6A21_u578B" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>内核线程和用户线程之间的关系</p>
<h4 id="u591A_u5BF9_u4E00_u6A21_u578B"><a href="#u591A_u5BF9_u4E00_u6A21_u578B" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>将多个用户线程映射到一个内核线程，任意时刻<strong>只有一个线程能访问内核</strong></p>
<ul>
<li><strong>优点：</strong> 效率较高</li>
<li><strong>缺点：</strong> 一旦内核阻塞，这个进程就阻塞</li>
</ul>
<h4 id="u4E00_u5BF9_u4E00_u6A21_u578B"><a href="#u4E00_u5BF9_u4E00_u6A21_u578B" class="headerlink" title="一对一模型"></a>一对一模型</h4><p>每个用户线程映射一个内核线程</p>
<ul>
<li><strong>优点：</strong> 高并发</li>
<li><strong>缺点：</strong> 每一个用户线程就要创建一个内核线程，创建内核线程的开销降低了应用程序性能，因此<strong>程序不能有太多线程</strong></li>
</ul>
<h4 id="u591A_u5BF9_u591A_u6A21_u578B"><a href="#u591A_u5BF9_u591A_u6A21_u578B" class="headerlink" title="多对多模型"></a>多对多模型</h4><p>多个用户线程映射多个内核线程</p>
<ul>
<li><strong>优点</strong> 兼具高并发和高效率</li>
</ul>
<h4 id="u7EBF_u7A0B_u5E93"><a href="#u7EBF_u7A0B_u5E93" class="headerlink" title="线程库"></a>线程库</h4><!--待续-->
<h2 id="CPU_u8C03_u5EA6"><a href="#CPU_u8C03_u5EA6" class="headerlink" title="CPU调度"></a>CPU调度</h2><h3 id="u6982_u5FF5-1"><a href="#u6982_u5FF5-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p><strong>COU区间</strong>进程在CPU区间和IO区间切换，大量的短CPU区间夹杂少量长CPU区间</p>
</li>
<li><p><strong>短期调度程序</strong> CPU空闲的时候，从就绪队列选择进程的程序</p>
</li>
<li><p><strong>抢占和非抢占</strong> 当调度只在进程切换到等待或者停止时进行，是非抢占，否则是抢占</p>
</li>
<li><p><strong>CPU利用率</strong> 40%~90%</p>
</li>
<li><p><strong>吞吐量</strong> 单位时间完成的进程数量</p>
</li>
<li><p><strong>周转时间</strong> 从进程提交到完成的时间</p>
</li>
<li><p><strong>等待时间</strong> 就绪队列中等待所花费的时间</p>
</li>
<li><p><strong>响应时间</strong> 提交进程到第一响应的时间</p>
</li>
</ul>
<h3 id="u8C03_u5EA6_u7B97_u6CD5"><a href="#u8C03_u5EA6_u7B97_u6CD5" class="headerlink" title="调度算法"></a>调度算法</h3><p><strong>画甘特图、算平均周转时间</strong></p>
<h4 id="FCFS_28_u5148_u6765_u5148_u670D_u52A1_29"><a href="#FCFS_28_u5148_u6765_u5148_u670D_u52A1_29" class="headerlink" title="FCFS(先来先服务)"></a>FCFS(先来先服务)</h4><ul>
<li><strong>缺点：</strong> 护航效应，小进程需等待较长时间，平均等待时间较长</li>
<li><strong>特点：</strong> 非抢占</li>
</ul>
<h4 id="SJF_28_u6700_u77ED_u4F5C_u4E1A_u4F18_u5148_29"><a href="#SJF_28_u6700_u77ED_u4F5C_u4E1A_u4F18_u5148_29" class="headerlink" title="SJF(最短作业优先)"></a>SJF(最短作业优先)</h4><ul>
<li><strong>缺点：</strong> 无法准确预测每一个作业所需要的时间，无法再短期调度层次上实现</li>
<li><strong>优点：</strong> 最高效</li>
<li><strong>特点：</strong> 抢占或非抢占</li>
</ul>
<h4 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h4><ul>
<li><strong>缺点：</strong> 可能导致饥饿，低优先级进程永远无法获得CPU用控制权(解决方案:<strong>老化，过一段时间把优先级比较低的进程提高优先级</strong>)</li>
<li><strong>优点：</strong> 应用最广，平均等待时间短</li>
<li><strong>特点：</strong> 抢占或非抢占</li>
</ul>
<h4 id="u8F6E_u8F6C_u8C03_u5EA6"><a href="#u8F6E_u8F6C_u8C03_u5EA6" class="headerlink" title="轮转调度"></a>轮转调度</h4><p>每一个进程服务一个时间片，一旦超过，就排队到队尾</p>
<ul>
<li><strong>优点：</strong> 响应速度加快</li>
<li><strong>特点：</strong> 抢占</li>
</ul>
<h4 id="Multilevel_Queue_28_u591A_u7EA7_u961F_u5217_u8C03_u5EA6_29"><a href="#Multilevel_Queue_28_u591A_u7EA7_u961F_u5217_u8C03_u5EA6_29" class="headerlink" title="Multilevel Queue(多级队列调度)"></a>Multilevel Queue(多级队列调度)</h4><ul>
<li><strong>核心思想：</strong> 将就绪队列划分几个独立队列，根据进程属性(内存大小、进程优先级等)，<strong>永久</strong>分配到一个独立队列，应用不同的算法</li>
</ul>
<h4 id="u591A_u7EA7_u53CD_u9988_u961F_u5217_u8C03_u5EA6"><a href="#u591A_u7EA7_u53CD_u9988_u961F_u5217_u8C03_u5EA6" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h4><ul>
<li><strong>核心思想：</strong> 高CPU占用的进程会逐渐被移到低优先级队列</li>
</ul>
<h2 id="u8FDB_u7A0B_u540C_u6B65"><a href="#u8FDB_u7A0B_u540C_u6B65" class="headerlink" title="进程同步"></a>进程同步</h2><p><strong>意义</strong> 当两个进程同时调用了某个寄存器时候，有可能会出错</p>
<p><strong>原子</strong> 不可中断的</p>
<h3 id="u4E34_u754C_u533A_u95EE_u9898"><a href="#u4E34_u754C_u533A_u95EE_u9898" class="headerlink" title="临界区问题"></a>临界区问题</h3><ul>
<li><strong>临界区</strong> 几个进程间有可能共同改变一个目标的代码段</li>
<li><p><strong>目的</strong> 设计一个以便进程协作的协议</p>
</li>
<li><p><strong>互斥</strong> 仅有一个进程可以进入临界区</p>
</li>
<li><strong>前进</strong> 临界区空闲时选择进程进入</li>
<li><strong>有限等待</strong> </li>
</ul>
<h4 id="u89E3_u51B3_u65B9_u6CD5"><a href="#u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>抢占内核 内核中的进程可以被抢占</li>
<li>非抢占内核 所有进程排队，等待内核中的进程完成或者退出</li>
</ol>
<h3 id="Peterson_u7B97_u6CD5"><a href="#Peterson_u7B97_u6CD5" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p><strong>作用</strong> 用于两个进程在临界区和剩余区间交替执行</p>
<h4 id="u5177_u4F53_u65B9_u6CD5"><a href="#u5177_u4F53_u65B9_u6CD5" class="headerlink" title="具体方法"></a>具体方法</h4><ul>
<li><p>进程P0，P1共享两个数据 </p>
<pre><code>int turn; //哪个进程可进入临界区
boolean flag[2]; //哪个进程想进入临界区

void procedure0() {
    while(true) {
        flag[0]=true;
        turn=1;
        while(flag[1] == 0 &amp;&amp; turn == 1) {
            //若flag[1]为false，P0就进入临界区
            //若flag[1]为tureP0循环等待，只要P1退出临界区，P0即可进入
        }
        visit();//访问临界区
        flag[0]=false;//访问临界区完成，procedure0释放出临界区
    }
}
</code></pre></li>
</ul>
<h3 id="u786C_u4EF6_u540C_u6B65"><a href="#u786C_u4EF6_u540C_u6B65" class="headerlink" title="硬件同步"></a>硬件同步</h3><h4 id="TestAndSet"><a href="#TestAndSet" class="headerlink" title="TestAndSet"></a>TestAndSet</h4><ul>
<li><p><strong>公用元素</strong> <code>boolean lock</code></p>
</li>
<li><p><strong>函数内容</strong></p>
<pre><code>boolean TestAndSet(boolean *target){
    boolean rv = *target;
    *target = true;//上锁，阻止后面进程进入临界区
    return rv;//返回锁的状态
}
</code></pre></li>
<li><p><strong>使用方法</strong></p>
<pre><code>while(true) {
    while(TestAndSet(&amp;Lock))；
    visit();//访问临界区
    Lock = flase;
    //访问剩余区
}
</code></pre></li>
</ul>
<h4 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h4><ul>
<li><p><strong>公用元素</strong> <code>boolean lock</code> <code>boolean key</code> </p>
</li>
<li><p><strong>函数内容</strong> <code>Swap(boolean *a, boolean *b)</code> 交换两个值</p>
</li>
<li><p><strong>使用方法</strong></p>
<pre><code>while(true) {
    key = true；
    while(key == true){
        Swap(&amp;lock，&amp;key);
        //当lock等于false的时候，将lock等于true,然后进入临界区
    }
    visit();//访问临界区
    Lock = flase;
    //访问剩余区
}
</code></pre></li>
</ul>
<h4 id="TestAndSet_u6709_u9650_u7B49_u5F85_u4E92_u65A5"><a href="#TestAndSet_u6709_u9650_u7B49_u5F85_u4E92_u65A5" class="headerlink" title="TestAndSet有限等待互斥"></a>TestAndSet有限等待互斥</h4><pre><code>while(true) {
    waiting[i] = true;
    key = true;
    while(key == true &amp;&amp; waiting[i] == true){
        key = TestAndSet(&amp;lock);
        //当lock为false时候，key为flase，上锁并且开始访问临界区
    }
    waiting[i] = false;//

    visit();//访问临界区

    j = (i+1)%n;
    //进程Pi处于等待获取锁的状态
    while(j!=i &amp;&amp; waiting[j] == 0){
        j = (j+1)%n;
    }
    if(j == i){
        lock = flase;
    }else{
        waiting[j] = false;
    }
    //访问剩余区
}
</code></pre><h3 id="u4FE1_u53F7_u91CF"><a href="#u4FE1_u53F7_u91CF" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li><strong>基本操作(原子！)</strong> <code>wait()</code> <code>signal()</code></li>
</ul>
<h4 id="u4E24_u4E2A_u57FA_u672C_u64CD_u4F5C"><a href="#u4E24_u4E2A_u57FA_u672C_u64CD_u4F5C" class="headerlink" title="两个基本操作"></a>两个基本操作</h4><p><strong>普通版</strong></p>
<pre><code>int S; 

wait(S){
    while (S &lt;= 0){
        //如果信号量小于零，就阻塞
    }
    S--;
} 

signal(S) {
    S++;
}
</code></pre><p> <strong>改进版</strong></p>
<pre><code>typedef struct{
    int value;
    struct process *list;
} semaphore;

wait(semaphore *S){
    S-&gt;value++;
    if(S-&gt;value&lt;=0){
        add P to list;//当前进程保存进list
        block();//挂起当前进程
    }
} 

signal(semaphore *S) {
    S-&gt;value--;
    if(S-&gt;value&lt;=0){
        remove P from list;
        wakeup(P);
    }
}
</code></pre><h4 id="u6B7B_u9501_u548C_u9965_u997F"><a href="#u6B7B_u9501_u548C_u9965_u997F" class="headerlink" title="死锁和饥饿"></a>死锁和饥饿</h4><ul>
<li><p>死锁</p>
<p>  P: <code>wait(S); wait(Q);</code><br>  Q: <code>wait(Q); wait(S);</code></p>
</li>
<li><p>饥饿</p>
<p>  无限期等待</p>
</li>
</ul>
<h3 id="u7ECF_u5178_u540C_u6B65_u95EE_u9898"><a href="#u7ECF_u5178_u540C_u6B65_u95EE_u9898" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><p>其实是信号量的补充</p>
<h4 id="u6709_u9650_u7F13_u51B2_u95EE_u9898"><a href="#u6709_u9650_u7F13_u51B2_u95EE_u9898" class="headerlink" title="有限缓冲问题"></a>有限缓冲问题</h4><ul>
<li><strong>公用元素</strong> </li>
</ul>
<p><code>int mutex = 1</code> 满足互斥要求</p>
<p><code>int empty = n</code> 空缓冲项个数</p>
<ul>
<li><p><strong>函数内容</strong> <code>Swap(boolean *a, boolean *b)</code> 交换两个值</p>
</li>
<li><p><strong>使用方法</strong></p>
<pre><code>while(true) {
    key = true；
    while(key == true){
        Swap(&amp;lock，&amp;key);
        //当lock等于false的时候，将lock等于true,然后进入临界区
    }
    visit();//访问临界区
    Lock = flase;
    //访问剩余区
}
</code></pre></li>
</ul>
<h4 id="u8BFB_u8005-_u5199_u8005_u95EE_u9898"><a href="#u8BFB_u8005-_u5199_u8005_u95EE_u9898" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><ul>
<li><p>写者要等到没有读者时才能去写文件</p>
</li>
<li><p>所有读者要等待写者完成写文件后才能去读文件</p>
</li>
<li><p><strong>公用元素</strong> </p>
<pre><code>semaphore mutex = 1 //保证互斥
semaphore wrt = 1 //供写者作为互斥信号量
int readcount = 0 //统计多少进程正在读对象
</code></pre></li>
<li><p><strong>代码</strong></p>
<pre><code>//写者
while(true) {
    wait(wrt);

    write();

    signal(wrt);
}

//读者
while(true){
    wait(mutex);
    readcount++;
    if(readcount == 1){
        wait(wrt);            
    }
    signal(mutex);

    read();

    wait(mutex);
    readcount--;
    if(readcount == 0){
        signal(wrt);
    }
    signal(mutex);
}
</code></pre></li>
</ul>
<h4 id="u54F2_u5B66_u5BB6_u8FDB_u9910_u95EE_u9898"><a href="#u54F2_u5B66_u5BB6_u8FDB_u9910_u95EE_u9898" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><ul>
<li><p><strong>公用元素</strong></p>
<pre><code>semaphore chopstick[5];
</code></pre></li>
<li><p><strong>代码</strong></p>
<pre><code>while(1){
    wait(chopstick[i]);
    wait(chopstick[i+1]%5);

    //eat

    signal(chopstick[i]);
    signal(chopstick[i+1]%5);

    //think
}
</code></pre></li>
</ul>
<h3 id="u7BA1_u7A0B"><a href="#u7BA1_u7A0B" class="headerlink" title="管程"></a>管程</h3><p>一种类，这个类在实现功能的前提下保证了互斥</p>
<h4 id="u54F2_u5B66_u5BB6_u8FDB_u9910_u4F8B_u5B50"><a href="#u54F2_u5B66_u5BB6_u8FDB_u9910_u4F8B_u5B50" class="headerlink" title="哲学家进餐例子"></a>哲学家进餐例子</h4><ul>
<li><strong>dp</strong> 管程</li>
<li><strong>i</strong> 哲学家编号<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp.pickup(i)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//eat</span><br><span class="line"></span><br><span class="line">dp.putdown(i)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u6587_u4EF6"><a href="#u6587_u4EF6" class="headerlink" title="文件"></a>文件</h2><h3 id="u6982_u5FF5-2"><a href="#u6982_u5FF5-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>信息存储的统一逻辑接口</p>
</li>
<li><p>逻辑外存的最小分配单元</p>
</li>
</ul>
<h2 id="u4F5C_u4E1A"><a href="#u4F5C_u4E1A" class="headerlink" title="作业"></a>作业</h2><h3 id="u7B2C_u4E00_u6B21_u4F5C_u4E1A"><a href="#u7B2C_u4E00_u6B21_u4F5C_u4E1A" class="headerlink" title="第一次作业"></a>第一次作业</h3><h4 id="1-10"><a href="#1-10" class="headerlink" title="1.10"></a>1.10</h4><p><strong>中断有何作用？陷阱和中断有什么区别？用户程序能否有意地生成陷阱？如果是，有什么目的？</strong></p>
<pre><code>1. 完成进程间切换，从而支持CPU和设备之间的并行。
2. 陷阱的发生时间是固定的，中断是不可预测的 
   CPU处理中断的过程中会屏蔽中断，不接受新的中断直
   到此次中断处理结束。而陷阱的发生并不屏蔽中断，可
   以接受新的中断。
3. 陷阱指令可以使执行流程从用户态陷入内核（这也就是
   为什么叫做陷阱，而不是捕猎的陷阱）并把控制权转移
   给操作系统，使得用户程序可以调用内核函数和使用硬
   件从而获得操作系统所提供的服务
</code></pre><h4 id="1-12"><a href="#1-12" class="headerlink" title="1.12"></a>1.12</h4><p><strong>有些计算机不支持硬件操作特权模式，能否为这些计算机系统构建一种安全的操作系统？</strong></p>
<pre><code>不能，因为无法调用一些系统调用，从而使得计算机很多功能无法实现
</code></pre><h4 id="1-13"><a href="#1-13" class="headerlink" title="1.13"></a>1.13</h4><p><strong>能给出高速缓存有用的两个理由。他们解决什么问题？这些问题产生的原因是什么？如果高速缓存的容量可以做成和要缓存的设备一样大，为什么不直接用同样容量的高速缓存代替呢？</strong></p>
<pre><code>1. 解决主存和cpu速度不匹配的问题
2. 原因是cpu速度超快，主存是电容充放电没办法这么快
3. 没钱，贵
</code></pre><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><p><strong>列出操作系统提供用户更为方便使用计算机系统的五个服务，并说明在哪些情况下用户级程序不能够提供这些服务</strong></p>
<pre><code>1. 用户界面
2. 程序执行
3. I/O操作
4. 文件系统操作
5. 通信
</code></pre><h4 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h4><p><strong>给出三种向操作系统传递参数的方法</strong></p>
<pre><code>1. 寄存器传递（参数较少）
2. 块传递，将参数房内存块中，将块地址传给寄存器
3. 堆栈传递，参数压栈，调用时弹出
</code></pre><h4 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h4><p>命令解释器的用途是什么？为什么它经常是与内核分开的？是否可能采用操作系统提供的系统调用接口开发一个新的命令解释器</p>
<pre><code>1. 命令行解释器是一个单独的软件程序，它可在用户
   和操作系统之间提供直接的通讯。命令行解释器是
   解释器的一种，用于对命令行进行解释执行。
2. 内核要尽量简洁
3. 可以
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【转】 Google Interview University 一套完整的学习手册帮助自己准备 Google 的面试]]></title>
      <url>http://pengtianhao.com/2016/10/13/Google%20Interview%20University/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>原文地址：<a href="https://github.com/jwasham/google-interview-university" target="_blank" rel="external">Google Interview University</a></li>
<li>原文作者：<a href="https://github.com/jwasham" target="_blank" rel="external">John Washam</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/aleen42" target="_blank" rel="external">Aleen</a>，<a href="https://github.com/Newt0n" target="_blank" rel="external">Newton</a>，<a href="https://github.com/bobmayuze" target="_blank" rel="external">bobmayuze</a>，<a href="https://github.com/laobie" target="_blank" rel="external">Jaeger</a>，<a href="https://github.com/sqrthree" target="_blank" rel="external">sqrthree</a></li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="u8FD9_u662F_uFF1F"><a href="#u8FD9_u662F_uFF1F" class="headerlink" title="这是？"></a>这是？</h2><p>这是我为了从 web 开发者（自学、非计算机科学学位）蜕变至 Google 软件工程师所制定的计划，其内容历时数月。</p>
<p><img src="https://dng5l3qzreal6.cloudfront.net/2016/Aug/coding_board_small-1470866369118.jpg" alt="白板上编程 ———— 来自 HBO 频道的剧集，“硅谷”"></p>
<p>这一长列表是从 <strong>Google 的指导笔记</strong> 中萃取出来并进行扩展。因此，有些事情你必须去了解一下。我在列表的底部添加了一些额外项，用于解决面试中可能会出现的问题。这些额外项大部分是来自于 Steve Yegge 的“<a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" target="_blank" rel="external">得到在 Google 工作的机会</a>”。而在 Google 指导笔记的逐字间，它们有时也会被反映出来。</p>
<hr>
<h2 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#这是">这是？</a></li>
<li><a href="#为何要用到它">为何要用到它？</a></li>
<li><a href="#如何使用它">如何使用它</a></li>
<li><a href="#拥有一名-googler-的心态">拥有一名 Googler 的心态</a></li>
<li><a href="#我得到了工作吗">我得到了工作吗？</a></li>
<li><a href="#跟随着我">跟随着我</a></li>
<li><a href="#不要自以为自己足够聪明">不要自以为自己足够聪明</a></li>
<li><a href="#关于-google">关于 Google</a></li>
<li><a href="#相关视频资源">相关视频资源</a></li>
<li><a href="#面试过程--通用的面试准备">面试过程 &amp; 通用的面试准备</a></li>
<li><a href="#为你的面试选择一种语言">为你的面试选择一种语言</a></li>
<li><a href="#在你开始之前">在你开始之前</a></li>
<li><a href="#你所看不到的">你所看不到的</a></li>
<li><a href="#日常计划">日常计划</a></li>
<li><a href="#必备知识">必备知识</a></li>
<li><a href="#算法复杂度--big-o--渐进分析法">算法复杂度 / Big-O / 渐进分析法</a></li>
<li><a href="#数据结构">数据结构</a><ul>
<li><a href="#数组arrays">数组（Arrays）</a></li>
<li><a href="#链表linked-lists">链表（Linked Lists）</a></li>
<li><a href="#堆栈stack">堆栈（Stack）</a></li>
<li><a href="#队列queue">队列（Queue）</a></li>
<li><a href="#哈希表hash-table">哈希表（Hash table）</a></li>
</ul>
</li>
<li><a href="#更多的知识">更多的知识</a><ul>
<li><a href="#二分查找binary-search">二分查找（Binary search）</a></li>
<li><a href="#按位运算bitwise-operations">按位运算（Bitwise operations）</a></li>
</ul>
</li>
<li><a href="#树trees">树（Trees）</a><ul>
<li><a href="#树--笔记--背景">树 —— 笔记 &amp; 背景</a></li>
<li><a href="#二叉查找树binary-search-treesbsts">二叉查找树（Binary search trees）：BSTs</a></li>
<li><a href="#堆heap--优先级队列priority-queue--二叉堆binary-heap">堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</a></li>
<li><a href="#字典树tries">字典树（Tries）</a></li>
<li><a href="#平衡查找树balanced-search-trees">平衡查找树（Balanced search trees）</a></li>
<li><a href="#n-叉树k-叉树m-叉树">N 叉树（K 叉树、M 叉树）</a></li>
</ul>
</li>
<li><a href="#排序sorting">排序</a></li>
<li><a href="#图graphs">图（Graphs）</a></li>
<li><a href="#更多知识">更多知识</a><ul>
<li><a href="#递归recursion">递归</a></li>
<li><a href="#动态规划dynamic-programming">动态规划</a></li>
<li><a href="#组合combinatorics-n-中选-k-个--概率probability">组合 &amp; 概率</a></li>
<li><a href="#np-np-完全和近似算法">NP, NP-完全和近似算法</a></li>
<li><a href="#缓存cache">缓存</a></li>
<li><a href="#进程processe和线程thread">进程和线程</a></li>
<li><a href="#系统设计可伸缩性数据处理">系统设计、可伸缩性、数据处理</a></li>
<li><a href="#论文">论文</a></li>
<li><a href="#测试">测试</a></li>
<li><a href="#调度">调度</a></li>
<li><a href="#实现系统例程">实现系统例程</a></li>
<li><a href="#字符串搜索和操作">字符串搜索和操作</a></li>
</ul>
</li>
<li><a href="#终面">终面</a></li>
<li><a href="#书籍">书籍</a></li>
<li><a href="#编码练习和挑战">编码练习和挑战</a></li>
<li><a href="#当你临近面试时">当你临近面试时</a></li>
<li><a href="#你的简历">你的简历</a></li>
<li><a href="#当面试来临的时候">当面试来临的时候</a></li>
<li><a href="#问面试官的问题">问面试官的问题</a></li>
<li><a href="#当你获得了梦想的职位">当你获得了梦想的职位</a></li>
</ul>
<p>—————- 下面的内容是可选的 —————-</p>
<ul>
<li><a href="#附加的学习">附加的学习</a><ul>
<li><a href="#unicode">Unicode</a></li>
<li><a href="#字节顺序">字节顺序</a></li>
<li><a href="#emacs-and-vim">Emacs and vi(m)</a></li>
<li><a href="#unix-命令行工具">Unix 命令行工具</a></li>
<li><a href="#信息资源-视频">信息资源 (视频)</a></li>
<li><a href="#奇偶校验位--汉明码-视频">奇偶校验位 &amp; 汉明码 (视频)</a></li>
<li><a href="#系统熵值系统复杂度">系统熵值（系统复杂度）</a></li>
<li><a href="#密码学">密码学</a></li>
<li><a href="#压缩">压缩</a></li>
<li><a href="#网络-视频">网络 (视频)</a></li>
<li><a href="#计算机安全">计算机安全</a></li>
<li><a href="#释放缓存">释放缓存</a></li>
<li><a href="#并行并发编程">并行/并发编程</a></li>
<li><a href="#设计模式">设计模式</a></li>
<li><a href="#信息传输-序列化和队列化的系统">信息传输, 序列化, 和队列化的系统</a></li>
<li><a href="#快速傅里叶变换">快速傅里叶变换</a></li>
<li><a href="#布隆过滤器">布隆过滤器</a></li>
<li><a href="#van-emde-boas-树">van Emde Boas 树</a></li>
<li><a href="#更深入的数据结构">更深入的数据结构</a></li>
<li><a href="#跳表">跳表</a></li>
<li><a href="#网络流">网络流</a></li>
<li><a href="#不相交集--联合查找">不相交集 &amp; 联合查找</a></li>
<li><a href="#math-for-fast-processing">快速处理数学</a></li>
<li><a href="#树堆-treap">树堆 (Treap)</a></li>
<li><a href="#线性规划linear-programming视频">线性规划</a></li>
<li><a href="#几何凸包geometry-convex-hull视频">几何：凸包（Geometry, Convex hull）</a></li>
<li><a href="#离散数学">离散数学</a></li>
<li><a href="#机器学习machine-learning">机器学习</a></li>
<li><a href="#go-语言">Go 语言</a></li>
</ul>
</li>
<li><a href="#一些主题的额外内容">一些主题的额外内容</a></li>
<li><a href="#视频系列">视频系列</a></li>
<li><a href="#计算机科学课程">计算机科学课程</a></li>
</ul>
<hr>
<h2 id="u4E3A_u4F55_u8981_u7528_u5230_u5B83_uFF1F"><a href="#u4E3A_u4F55_u8981_u7528_u5230_u5B83_uFF1F" class="headerlink" title="为何要用到它？"></a>为何要用到它？</h2><p>我一直都是遵循该计划去准备 Google 的面试。自 1997 年以来，我一直从事于 web 程序的构建、服务器的构建及创业型公司的创办。对于只有着一个经济学学位，而不是计算机科学学位（CS degree）的我来说，在职业生涯中所取得的都非常成功。然而，我想在 Google 工作，并进入大型系统中，真正地去理解计算机系统、算法效率、数据结构性能、低级别编程语言及其工作原理。可一项都不了解的我，怎么会被 Google 所应聘呢？</p>
<p>当我创建该项目时，我从一个堆栈到一个堆都不了解。那时的我，完全不了解 Big-O 、树，或如何去遍历一个图。如果非要我去编写一个排序算法的话，我只能说我所写的肯定是很糟糕。一直以来，我所用的任何数据结构都是内建于编程语言当中。至于它们在背后是如何运作，对此我一概不清楚。此外，以前的我并不需要对内存进行管理，最多就只是在一个正在执行的进程抛出了“内存不足”的错误后，采取一些权变措施。而在我的编程生活中，也甚少使用到多维数组，可关联数组却成千上万。而且，从一开始到现在，我都还未曾自己实现过数据结构。</p>
<p>就是这样的我，在经过该学习计划后，已然对被 Google 所雇佣充满信心。这是一个漫长的计划，以至于花费了我数月的时间。若您早已熟悉大部分的知识，那么也许能节省大量的时间。</p>
<h2 id="u5982_u4F55_u4F7F_u7528_u5B83"><a href="#u5982_u4F55_u4F7F_u7528_u5B83" class="headerlink" title="如何使用它"></a>如何使用它</h2><p>下面所有的东西都只是一个概述。因此，你需要由上而下逐一地去处理它。</p>
<p>在学习过程中，我是使用 GitHub 特殊的语法特性 markdown flavor 去检查计划的进展，包括使用任务列表。</p>
<ul>
<li>[x] 创建一个新的分支，以使得你可以像这样去检查计划的进展。直接往方括号中填写一个字符 x 即可：[x]</li>
</ul>
<p><a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown" target="_blank" rel="external">更多关于 Github-flavored markdown 的详情</a></p>
<h2 id="u62E5_u6709_u4E00_u540D_Googler__u7684_u5FC3_u6001"><a href="#u62E5_u6709_u4E00_u540D_Googler__u7684_u5FC3_u6001" class="headerlink" title="拥有一名 Googler 的心态"></a>拥有一名 Googler 的心态</h2><p>把一个（或两个）印有“<a href="https://github.com/jwasham/google-interview-university/blob/master/extras/future-googler.pdf" target="_blank" rel="external">future Googler</a>”的图案打印出来，并用你誓要成功的眼神盯着它。</p>
<p><a href="https://github.com/jwasham/google-interview-university/blob/master/extras/future-googler.pdf" target="_blank" rel="external"><img src="https://dng5l3qzreal6.cloudfront.net/2016/Oct/Screen_Shot_2016_10_04_at_10_13_24_AM-1475601104364.png" alt="future Googler sign"></a></p>
<h2 id="u6211_u5F97_u5230_u4E86_u5DE5_u4F5C_u5417_uFF1F"><a href="#u6211_u5F97_u5230_u4E86_u5DE5_u4F5C_u5417_uFF1F" class="headerlink" title="我得到了工作吗？"></a>我得到了工作吗？</h2><p>我还没去应聘。</p>
<p>因为我离完成学习（完成该疯狂的计划列表）还需要数天的时间，并打算在下周开始用一整天的时间，以编程的方式去解决问题。当然，这将会持续数周的时间。然后，我才通过使用在二月份所得到的一个介绍资格，去正式应聘 Google（没错，是二月份时就得到的）。</p>
<pre><code>感谢 JP 的这次介绍。
</code></pre><h2 id="u8DDF_u968F_u7740_u6211"><a href="#u8DDF_u968F_u7740_u6211" class="headerlink" title="跟随着我"></a>跟随着我</h2><p>目前我仍在该计划的执行过程中，如果你想跟随我脚步去学习的话，可以登进我在 <a href="https://googleyasheck.com/" target="_blank" rel="external">GoogleyAsHeck.com</a> 上所写的博客。</p>
<p>下面是我的联系方式：</p>
<ul>
<li>Twitter: <a href="https://twitter.com/googleyasheck" target="_blank" rel="external">@googleyasheck</a></li>
<li>Twitter: <a href="https://twitter.com/StartupNextDoor" target="_blank" rel="external">@StartupNextDoor</a></li>
<li>Google+: <a href="https://plus.google.com/+Googleyasheck" target="_blank" rel="external">+Googleyasheck</a></li>
<li>LinkedIn: <a href="https://www.linkedin.com/in/johnawasham" target="_blank" rel="external">johnawasham</a></li>
</ul>
<p><img src="https://dng5l3qzreal6.cloudfront.net/2016/Aug/book_stack_photo_resized_18_1469302751157-1472661280368.png" alt="John Washam - Google Interview University"></p>
<h2 id="u4E0D_u8981_u81EA_u4EE5_u4E3A_u81EA_u5DF1_u8DB3_u591F_u806A_u660E"><a href="#u4E0D_u8981_u81EA_u4EE5_u4E3A_u81EA_u5DF1_u8DB3_u591F_u806A_u660E" class="headerlink" title="不要自以为自己足够聪明"></a>不要自以为自己足够聪明</h2><ul>
<li>Google 的工程师都是才智过人的。但是，就算是工作在 Google 的他们，仍然会因为自己不够聪明而感到一种不安。</li>
<li><a href="https://www.youtube.com/watch?v=0SARbwvhupQ" target="_blank" rel="external">天才程序员的神话</a></li>
</ul>
<h2 id="u5173_u4E8E_Google"><a href="#u5173_u4E8E_Google" class="headerlink" title="关于 Google"></a>关于 Google</h2><ul>
<li>[ ] 面向学生 —— <a href="https://www.google.com/about/careers/students/guide-to-technical-development.html" target="_blank" rel="external">Google 的职业生涯：技术开发指导</a></li>
<li>[ ] Google 检索的原理：<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=mTBShTwCnD4" target="_blank" rel="external">Google 检索的发展史（视频）</a></li>
<li>[ ] <a href="https://www.google.com/insidesearch/howsearchworks/thestory/" target="_blank" rel="external">Google 检索的原理 —— 故事篇</a></li>
<li>[ ] <a href="https://www.google.com/insidesearch/howsearchworks/" target="_blank" rel="external">Google 检索的原理</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=BNHR6IQJGZs" target="_blank" rel="external">Google 检索的原理 —— Matt Cutts（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=J5RZOU6vK4Q" target="_blank" rel="external">Google 是如何改善其检索算法（视频）</a></li>
</ul>
</li>
<li>[ ] 系列文章：<ul>
<li>[ ] <a href="https://backchannel.com/how-google-search-dealt-with-mobile-33bc09852dc9" target="_blank" rel="external">Google 检索是如何处理移动设备</a></li>
<li>[ ] <a href="https://backchannel.com/googles-secret-study-to-find-out-our-needs-eba8700263bf" target="_blank" rel="external">Google 为了寻找大众需求的秘密研究</a></li>
<li>[ ] <a href="https://backchannel.com/google-search-will-be-your-next-brain-5207c26e4523" target="_blank" rel="external">Google 检索将成为你的下一个大脑</a></li>
<li>[ ] <a href="https://backchannel.com/the-deep-mind-of-demis-hassabis-156112890d8a" target="_blank" rel="external">Demis Hassabis 的心灵直白</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.amazon.com/How-Google-Works-Eric-Schmidt/dp/1455582344" target="_blank" rel="external">书籍：Google 公司是如何运作的</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=q4y0KOeXViI" target="_blank" rel="external">由 Google 通告所制作 —— 2016年10月（视频）</a></li>
</ul>
<h2 id="u76F8_u5173_u89C6_u9891_u8D44_u6E90"><a href="#u76F8_u5173_u89C6_u9891_u8D44_u6E90" class="headerlink" title="相关视频资源"></a>相关视频资源</h2><p>部分视频只能通过在 Coursera、Edx 或 Lynda.com class 上注册登录才能观看。这些视频被称为网络公开课程（MOOC）。即便是免费观看，部分课程可能会由于不在时间段内而无法获取。因此，你需要多等待几个月。</p>
<pre><code>很感谢您能帮我把网络公开课程的视频链接转换成公开的视频源，以代替那些在线课程的视频。此外，一些大学的讲座视频也是我所青睐的。
</code></pre><h2 id="u9762_u8BD5_u8FC7_u7A0B__26amp_3B__u901A_u7528_u7684_u9762_u8BD5_u51C6_u5907"><a href="#u9762_u8BD5_u8FC7_u7A0B__26amp_3B__u901A_u7528_u7684_u9762_u8BD5_u51C6_u5907" class="headerlink" title="面试过程 &amp; 通用的面试准备"></a>面试过程 &amp; 通用的面试准备</h2><ul>
<li><p>[ ] 视频：</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=oWbUtlUhwa8&amp;feature=youtu.be" target="_blank" rel="external">如何在 Google 工作 —— 考生指导课程（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=qc1owf2-220&amp;feature=youtu.be" target="_blank" rel="external">Google 招聘者所分享的技术面试小窍门（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=8npJLXkcmu8" target="_blank" rel="external">如何在 Google 工作：技术型简历的准备（视频）</a></li>
</ul>
</li>
<li><p>[ ] 文章：</p>
<ul>
<li>[ ] <a href="http://www.google.com/about/careers/lifeatgoogle/hiringprocess/" target="_blank" rel="external">三步成为 Googler</a></li>
<li>[ ] <a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" target="_blank" rel="external">得到在 Google 的工作机会</a><ul>
<li>所有他所提及的事情都列在了下面</li>
</ul>
</li>
<li>[ ] <em>（早已过期）</em> <a href="http://dondodge.typepad.com/the_next_big_thing/2010/09/how-to-get-a-job-at-google-interview-questions-hiring-process.html" target="_blank" rel="external">如何得到 Google 的一份工作，面试题，应聘过程</a></li>
<li>[ ] <a href="http://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions" target="_blank" rel="external">手机设备屏幕的问题</a></li>
</ul>
</li>
<li><p>[ ] 附加的（虽然 Google 不建议，但我还是添加在此）：</p>
<ul>
<li>[ ] <a href="https://medium.com/always-be-coding/abc-always-be-coding-d5f8051afce2#.4heg8zvm4" target="_blank" rel="external">ABC：永远都要去编程（Always Be Coding）</a></li>
<li>[ ] <a href="https://medium.com/always-be-coding/four-steps-to-google-without-a-degree-8f381aa6bd5e#.asalo1vfx" target="_blank" rel="external">四步成为 Google 里一名没有学位的员工</a></li>
<li>[ ] <a href="https://medium.com/@dpup/whiteboarding-4df873dbba2e#.hf6jn45g1" target="_blank" rel="external">共享白板（Whiteboarding）</a></li>
<li>[ ] <a href="http://www.kpcb.com/blog/lessons-learned-how-google-thinks-about-hiring-management-and-culture" target="_blank" rel="external">Google 是如何看待应聘、管理和公司文化</a></li>
<li>[ ] <a href="http://www.coderust.com/blog/2014/04/10/effective-whiteboarding-during-programming-interviews/" target="_blank" rel="external">程序开发面试中有效的白板（Whiteboarding）</a></li>
<li>[ ] 震撼开发类面试 第一集：<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=rEJzOhC5ZtQ" target="_blank" rel="external">Gayle L McDowell —— 震撼开发类面试（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=aClxtDcdpsQ" target="_blank" rel="external">震撼开发类面试 —— 作者 Gayle Laakmann McDowell（视频）</a></li>
</ul>
</li>
<li>[ ] 如何在世界四强企业中获得一份工作：<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=YJZCUhxNCv8" target="_blank" rel="external">“如何在世界四强企业中获得一份工作 —— Amazon、Facebook、Google 和 Microsoft”（视频）</a></li>
</ul>
</li>
<li>[ ] <a href="http://alexbowe.com/failing-at-google-interviews/" target="_blank" rel="external">面试 Google 失败</a></li>
</ul>
</li>
</ul>
<h2 id="u4E3A_u4F60_u7684_u9762_u8BD5_u9009_u62E9_u4E00_u79CD_u8BED_u8A00"><a href="#u4E3A_u4F60_u7684_u9762_u8BD5_u9009_u62E9_u4E00_u79CD_u8BED_u8A00" class="headerlink" title="为你的面试选择一种语言"></a>为你的面试选择一种语言</h2><p>在这，我就以下话题写一篇短文 —— <a href="https://googleyasheck.com/important-pick-one-language-for-the-google-interview/" target="_blank" rel="external">重点：为在 Google 的面试选择一种语言</a></p>
<p>在大多数公司的面试当中，你可以在编程这一环节，使用一种自己用起来较为舒适的语言去完成编程。但在 Google，你只有三种固定的选择：</p>
<ul>
<li>C++</li>
<li>Java</li>
<li>Python</li>
</ul>
<p>有时你也可以使用下面两种，但需要事先查阅说明。因为，说明中会有警告：</p>
<ul>
<li>JavaScript</li>
<li>Ruby</li>
</ul>
<p>你需要对你所选择的语言感到非常舒适且足够了解。</p>
<p>更多关于语言选择的阅读：</p>
<ul>
<li><a href="http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/" target="_blank" rel="external">http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/</a></li>
<li><a href="http://blog.codingforinterviews.com/best-programming-language-jobs/" target="_blank" rel="external">http://blog.codingforinterviews.com/best-programming-language-jobs/</a></li>
<li><a href="https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview" target="_blank" rel="external">https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview</a></li>
</ul>
<p><a href="programming-language-resources.md">在此查看相关语言的资源</a></p>
<p>由于，我正在学习C、C++ 和 Python。因此，在下面你会看到部分关于它们的学习资料。相关书籍请看文章的底部。</p>
<h2 id="u5728_u4F60_u5F00_u59CB_u4E4B_u524D"><a href="#u5728_u4F60_u5F00_u59CB_u4E4B_u524D" class="headerlink" title="在你开始之前"></a>在你开始之前</h2><p>该列表已经持续更新了很长的一段时间，所以，我们的确很容易会对其失去控制。</p>
<p>这里列出了一些我所犯过的错误，希望您不要重滔覆辙。</p>
<h3 id="1-__u4F60_u4E0D_u53EF_u80FD_u628A_u6240_u6709_u7684_u4E1C_u897F_u90FD_u8BB0_u4F4F"><a href="#1-__u4F60_u4E0D_u53EF_u80FD_u628A_u6240_u6709_u7684_u4E1C_u897F_u90FD_u8BB0_u4F4F" class="headerlink" title="1. 你不可能把所有的东西都记住"></a>1. 你不可能把所有的东西都记住</h3><p>就算我查看了数小时的视频，并记录了大量的笔记。几个月后的我，仍然会忘却其中大部分的东西。所以，我翻阅了我的笔记，并将可回顾的东西制作成抽认卡（flashcard）（请往下看）</p>
<h3 id="2-__u4F7F_u7528_u62BD_u8BA4_u5361"><a href="#2-__u4F7F_u7528_u62BD_u8BA4_u5361" class="headerlink" title="2. 使用抽认卡"></a>2. 使用抽认卡</h3><p>为了解决善忘的问题，我制作了一些关于抽认卡的页面，用于添加两种抽认卡：正常的及带有代码的。每种卡都会有不同的格式设计。</p>
<p>而且，我还以移动设备为先去设计这些网页，以使得在任何地方的我，都能通过我的手机及平板去回顾知识。</p>
<p>你也可以免费制作属于你自己的抽认卡网站：</p>
<ul>
<li><a href="https://github.com/jwasham/computer-science-flash-cards" target="_blank" rel="external">抽认卡页面的代码仓库</a></li>
<li><a href="https://github.com/jwasham/computer-science-flash-cards/blob/master/cards-jwasham.db" target="_blank" rel="external">我的抽认卡数据库</a>：有一点需要记住的是，我做事有点过头，以至于把卡片都覆盖到所有的东西上。从汇编语言和 Python 的细枝末节，乃至到机器学习和统计都被覆盖到卡片上。而这种做法，对于 Google 的要求来说，却是多余。</li>
</ul>
<p><strong>在抽认卡上做笔记：</strong> 若你第一次发现你知道问题的答案时，先不要急着把其标注成“已懂”。你需要做的，是去查看一下是否有同样的抽认卡，并在你真正懂得如何解决问题之前，多问自己几次。重复地问答可帮助您深刻记住该知识点。</p>
<h3 id="3-__u56DE_u987E_uFF0C_u56DE_u987E_uFF0C_u56DE_u987E"><a href="#3-__u56DE_u987E_uFF0C_u56DE_u987E_uFF0C_u56DE_u987E" class="headerlink" title="3. 回顾，回顾，回顾"></a>3. 回顾，回顾，回顾</h3><p>我留有一组 ASCII 码表、OSI 堆栈、Big-O 记号及更多的小抄纸，以便在空余的时候可以学习。</p>
<p>每编程半个小时就要休息一下，并去回顾你的抽认卡。</p>
<h3 id="4-__u4E13_u6CE8"><a href="#4-__u4E13_u6CE8" class="headerlink" title="4. 专注"></a>4. 专注</h3><p>在学习的过程中，往往会有许多令人分心的事占据着我们宝贵的时间。因此，专注和集中注意力是非常困难的。</p>
<h2 id="u4F60_u6240_u770B_u4E0D_u5230_u7684"><a href="#u4F60_u6240_u770B_u4E0D_u5230_u7684" class="headerlink" title="你所看不到的"></a>你所看不到的</h2><p>由于，这个巨大的列表一开始是作为我个人从 Google 面试指导笔记所形成的一个事件处理列表。因此，有一些我熟悉且普遍的技术在此都未被谈及到：</p>
<ul>
<li>SQL</li>
<li>Javascript</li>
<li>HTML、CSS 和其他前端技术</li>
</ul>
<h2 id="u65E5_u5E38_u8BA1_u5212"><a href="#u65E5_u5E38_u8BA1_u5212" class="headerlink" title="日常计划"></a>日常计划</h2><p>部分问题可能会花费一天的时间去学习，而部分则会花费多天。当然，有些学习并不需要我们懂得如何实现。</p>
<p>因此，每一天我都会在下面所列出的列表中选择一项，并查看相关的视频。然后，使用以下的一种语言去实现：</p>
<pre><code>C —— 使用结构体和函数，该函数会接受一个结构体指针 * 及其他数据作为参数。
C++ —— 不使用内建的数据类型。
C++ —— 使用内建的数据类型，如使用 STL 的 std::list 来作为链表。
Python ——  使用内建的数据类型（为了持续练习 Python），并编写一些测试去保证自己代码的正确性。有时，只需要使用断言函数 assert() 即可。
此外，你也可以使用 Java 或其他语言。以上只是我的个人偏好而已。
</code></pre><p>为何要在这些语言上分别实现一次？</p>
<pre><code>因为可以练习，练习，练习，直至我厌倦它，并完美地实现出来。（若有部分边缘条件没想到时，我会用书写的形式记录下来并去记忆）
因为可以在纯原生的条件下工作（不需垃圾回收机制的帮助下，分配/释放内存（除了 Python））
因为可以利用上内建的数据类型，以使得我拥有在现实中使用内建工具的经验（在生产环境中，我不会去实现自己的链表）
</code></pre><p>就算我没有时间去每一项都这么做，但我也会尽我所能的。</p>
<p>在这里，你可以查看到我的代码：</p>
<ul>
<li><a href="https://github.com/jwasham/practice-c" target="_blank" rel="external">C</a></li>
<li><a href="https://github.com/jwasham/practice-cpp" target="_blank" rel="external">C++</a></li>
<li><a href="https://github.com/jwasham/practice-python" target="_blank" rel="external">Python</a></li>
</ul>
<p>你不需要记住每一个算法的内部原理。</p>
<p>在一个白板上写代码，而不要直接在计算机上编写。在测试完部分简单的输入后，到计算机上再测试一遍。</p>
<h2 id="u5FC5_u5907_u77E5_u8BC6"><a href="#u5FC5_u5907_u77E5_u8BC6" class="headerlink" title="必备知识"></a>必备知识</h2><ul>
<li><p>[ ] <strong>计算机是如何处理一段程序：</strong></p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=42KTvGYQYnA" target="_blank" rel="external">CPU 是如何执行代码（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Mv2XQgpbTNE" target="_blank" rel="external">机器码指令（视频）</a></li>
</ul>
</li>
<li><p>[ ] <strong>编译器</strong></p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=IhC7sdYe-Jg" target="_blank" rel="external">编译器是如何在 ~1 分钟内工作（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=CSZLNYF4Klo" target="_blank" rel="external">Hardvard CS50 —— 编译器（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=twodd1KFfGk" target="_blank" rel="external">C++（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=FnGCDLhaxKU" target="_blank" rel="external">掌握编译器的优化（C++）（视频）</a></li>
</ul>
</li>
<li><p>[ ] <strong>浮点数是如何存储的：</strong></p>
<ul>
<li>[ ] 简单的 8-bit：<a href="https://www.youtube.com/watch?v=ji3SfClm8TU" target="_blank" rel="external">浮点数的表达形式　—— 1（视频 —— 在计算上有一个错误 —— 详情请查看视频的介绍）</a></li>
<li>[ ] 32 bit：<a href="https://www.youtube.com/watch?v=50ZYcZebIec" target="_blank" rel="external">IEEE754 32-bit 浮点二进制（视频）</a></li>
</ul>
</li>
</ul>
<h2 id="u7B97_u6CD5_u590D_u6742_u5EA6_/_Big-O_/__u6E10_u8FDB_u5206_u6790_u6CD5"><a href="#u7B97_u6CD5_u590D_u6742_u5EA6_/_Big-O_/__u6E10_u8FDB_u5206_u6790_u6CD5" class="headerlink" title="算法复杂度 / Big-O / 渐进分析法"></a>算法复杂度 / Big-O / 渐进分析法</h2><ul>
<li>并不需要实现</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=iOq5kSKqeR4" target="_blank" rel="external">Harvard CS50 —— 渐进表示（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=V6mKVRU1evU" target="_blank" rel="external">Big O 记号（通用快速教程）（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ei-A_wy5Yxw&amp;index=2&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN" target="_blank" rel="external">Big O 记号（以及 Omega 和 Theta）——  最佳数学解释（视频）</a></li>
<li>[ ] Skiena 算法：<ul>
<li><a href="https://www.youtube.com/watch?v=gSyDMtdPNpU&amp;index=2&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="external">视频</a></li>
<li><a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/2007/lecture2.pdf" target="_blank" rel="external">幻灯片</a></li>
</ul>
</li>
<li>[ ] <a href="http://discrete.gr/complexity/" target="_blank" rel="external">对于算法复杂度分析的一次详细介绍</a></li>
<li>[ ] <a href="https://class.coursera.org/algorithmicthink1-004/lecture/59" target="_blank" rel="external">增长阶数（Orders of Growth）（视频）</a></li>
<li>[ ] <a href="https://class.coursera.org/algorithmicthink1-004/lecture/61" target="_blank" rel="external">渐进性（Asymptotics）（视频）</a></li>
<li>[ ] <a href="https://youtu.be/VIS4YDpuP98" target="_blank" rel="external">UC Berkeley Big O（视频）</a></li>
<li>[ ] <a href="https://youtu.be/ca3e7UVmeUc" target="_blank" rel="external">UC Berkeley Big Omega（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=B3SpQZaAZP4&amp;index=10&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN" target="_blank" rel="external">平摊分析法（Amortized Analysis）（视频）</a></li>
<li>[ ] <a href="https://class.coursera.org/algorithmicthink1-004/lecture/63" target="_blank" rel="external">举证“Big O”（视频）</a></li>
<li>[ ] 高级编程（包括递归关系和主定理）：<ul>
<li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/" target="_blank" rel="external">计算性复杂度：第一部</a></li>
<li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-2/" target="_blank" rel="external">计算性复杂度：第二部</a></li>
</ul>
</li>
<li><p>[ ] <a href="http://bigocheatsheet.com/" target="_blank" rel="external">速查表（Cheat sheet）</a></p>
<p>  如果部分课程过于学术性，你可直接跳到文章底部，去查看离散数学的视频以获取相关背景知识。</p>
</li>
</ul>
<h2 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><h3 id="u6570_u7EC4_uFF08Arrays_uFF09"><a href="#u6570_u7EC4_uFF08Arrays_uFF09" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><ul>
<li>实现一个可自动调整大小的动态数组。</li>
<li>[ ] 介绍：<ul>
<li><a href="https://www.coursera.org/learn/data-structures/lecture/OsBSF/arrays" target="_blank" rel="external">数组（视频）</a></li>
<li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Basic-arrays/149042/177104-4.html" target="_blank" rel="external">数组的基础知识（视频）</a></li>
<li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Multidimensional-arrays/149042/177105-4.html" target="_blank" rel="external">多维数组（视频）</a></li>
<li><a href="https://www.coursera.org/learn/data-structures/lecture/EwbnV/dynamic-arrays" target="_blank" rel="external">动态数组（视频）</a></li>
<li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Jagged-arrays/149042/177106-4.html" target="_blank" rel="external">不规则数组（视频）</a></li>
<li><a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Resizable-arrays/149042/177108-4.html" target="_blank" rel="external">调整数组的大小（视频）</a></li>
</ul>
</li>
<li>[ ] 实现一个动态数组（可自动调整大小的可变数组）：<ul>
<li>[ ] 练习使用数组和指针去编码，并且指针是通过计算去跳转而不是使用索引</li>
<li>[ ] 通过分配内存来新建一个原生数据型数组<ul>
<li>可以使用 int 类型的数组，但不能使用其语法特性</li>
<li>从大小为16或更大的数（使用2的倍数 —— 16、32、64、128）开始编写</li>
</ul>
</li>
<li>[ ] size() —— 数组元素的个数</li>
<li>[ ] capacity() —— 可容纳元素的个数</li>
<li>[ ] is_empty()</li>
<li>[ ] at(index) —— 返回对应索引的元素，且若索引越界则愤然报错</li>
<li>[ ] push(item)</li>
<li>[ ] insert(index, item) —— 在指定索引中插入元素，并把后面的元素依次后移</li>
<li>[ ] prepend(item) —— 可以使用上面的 insert 函数，传参 index 为 0</li>
<li>[ ] pop() —— 删除在数组末端的元素，并返回其值</li>
<li>[ ] delete(index) —— 删除指定索引的元素，并把后面的元素依次前移</li>
<li>[ ] remove(item) —— 删除指定值的元素，并返回其索引（即使有多个元素）</li>
<li>[ ] find(item) —— 寻找指定值的元素并返回其中第一个出现的元素其索引，若未找到则返回 -1</li>
<li>[ ] resize(new_capacity) // 私有函数<ul>
<li>若数组的大小到达其容积，则变大一倍</li>
<li>获取元素后，若数组大小为其容积的1/4，则缩小一半</li>
</ul>
</li>
</ul>
</li>
<li>[ ] 时间复杂度<ul>
<li>在数组末端增加/删除、定位、更新元素，只允许占 O(1) 的时间复杂度（平摊（amortized）去分配内存以获取更多空间）</li>
<li>在数组任何地方插入/移除元素，只允许 O(n) 的时间复杂度</li>
</ul>
</li>
<li>[ ] 空间复杂度<ul>
<li>因为在内存中分配的空间邻近，所以有助于提高性能</li>
<li>空间需求 = （大于或等于 n 的数组容积）* 元素的大小。即便空间需求为 2n，其空间复杂度仍然是 O(n)</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u94FE_u8868_uFF08Linked_Lists_uFF09"><a href="#u94FE_u8868_uFF08Linked_Lists_uFF09" class="headerlink" title="链表（Linked Lists）"></a>链表（Linked Lists）</h3><ul>
<li>[ ] 介绍：<ul>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/kHhgK/singly-linked-lists" target="_blank" rel="external">单向链表（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=sJtJOtXCW_M&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=5" target="_blank" rel="external">CS 61B —— 链表（视频）</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=QN6FPiD0Gzo" target="_blank" rel="external">C 代码（视频）</a><ul>
<li>并非看完整个视频，只需要看关于节点结果和内存分配那一部分即可</li>
</ul>
</li>
<li>[ ] 链表 vs 数组：<ul>
<li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/rjBs9/core-linked-lists-vs-arrays" target="_blank" rel="external">基本链表 Vs 数组（视频）</a></li>
<li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/QUaUd/in-the-real-world-lists-vs-arrays" target="_blank" rel="external">在现实中，链表 Vs 数组（视频）</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo" target="_blank" rel="external">为什么你需要避免使用链表（视频）</a></li>
<li>[ ] 的确：你需要关于“指向指针的指针”的相关知识：（因为当你传递一个指针到一个函数时，该函数可能会改变指针所指向的地址）该页只是为了让你了解“指向指针的指针”这一概念。但我并不推荐这种链式遍历的风格。因为，这种风格的代码，其可读性和可维护性太低。<ul>
<li><a href="https://www.eskimo.com/~scs/cclass/int/sx8.html" target="_blank" rel="external">指向指针的指针</a></li>
</ul>
</li>
<li>[ ] 实现（我实现了使用尾指针以及没有使用尾指针这两种情况）：<ul>
<li>[ ] size() —— 返回链表中数据元素的个数</li>
<li>[ ] empty() —— 若链表为空则返回一个布尔值 true</li>
<li>[ ] value_at(index) —— 返回第 n 个元素的值（从0开始计算）</li>
<li>[ ] push_front(value) —— 添加元素到链表的首部</li>
<li>[ ] pop_front() —— 删除首部元素并返回其值</li>
<li>[ ] push_back(value) —— 添加元素到链表的尾部</li>
<li>[ ] pop_back() —— 删除尾部元素并返回其值</li>
<li>[ ] front() —— 返回首部元素的值</li>
<li>[ ] back() —— 返回尾部元素的值</li>
<li>[ ] insert(index, value) —— 插入值到指定的索引，并把当前索引的元素指向到新的元素</li>
<li>[ ] erase(index) —— 删除指定索引的节点</li>
<li>[ ] value_n_from_end(n) —— 返回倒数第 n 个节点的值</li>
<li>[ ] reverse() —— 逆序链表</li>
<li>[ ] remove_value(value) —— 删除链表中指定值的第一个元素</li>
</ul>
</li>
<li>[ ] 双向链表<ul>
<li><a href="https://www.coursera.org/learn/data-structures/lecture/jpGKD/doubly-linked-lists" target="_blank" rel="external">介绍（视频）</a></li>
<li>并不需要实现</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u5806_u6808_uFF08Stack_uFF09"><a href="#u5806_u6808_uFF08Stack_uFF09" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h3><ul>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/UdKzQ/stacks" target="_blank" rel="external">堆栈（视频）</a></li>
<li>[ ] <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-stacks-last-first-out/149042/177120-4.html" target="_blank" rel="external">使用堆栈 —— 后进先出（视频）</a></li>
<li>[ ] 可以不实现，因为使用数组来实现并不重要</li>
</ul>
</li>
<li><h3 id="u961F_u5217_uFF08Queue_uFF09"><a href="#u961F_u5217_uFF08Queue_uFF09" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><ul>
<li>[ ] <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-queues-first-first-out/149042/177122-4.html" target="_blank" rel="external">使用队列 —— 先进先出（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/EShpq/queue" target="_blank" rel="external">队列（视频）</a></li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="external">原型队列/先进先出（FIFO）</a></li>
<li>[ ] <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Priority-queues-deques/149042/177123-4.html" target="_blank" rel="external">优先级队列（视频）</a></li>
<li>[ ] 使用含有尾部指针的链表来实现:<ul>
<li>enqueue(value) —— 在尾部添加值</li>
<li>dequeue() —— 删除最早添加的元素并返回其值（首部元素）</li>
<li>empty()</li>
</ul>
</li>
<li>[ ] 使用固定大小的数组实现：<ul>
<li>enqueue(value) —— 在可容的情况下添加元素到尾部</li>
<li>dequeue() —— 删除最早添加的元素并返回其值</li>
<li>empty()</li>
<li>full()</li>
</ul>
</li>
<li>[ ] 花销：<ul>
<li>在糟糕的实现情况下，使用链表所实现的队列，其入列和出列的时间复杂度将会是 O(n)。因为，你需要找到下一个元素，以致循环整个队列</li>
<li>enqueue：O(1)（平摊（amortized）、链表和数组 [探测（probing）]）</li>
<li>dequeue：O(1)（链表和数组）</li>
<li>empty：O(1)（链表和数组）</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u54C8_u5E0C_u8868_uFF08Hash_table_uFF09"><a href="#u54C8_u5E0C_u8868_uFF08Hash_table_uFF09" class="headerlink" title="哈希表（Hash table）"></a>哈希表（Hash table）</h3><ul>
<li><p>[ ] 视频：</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=0M_kIqhwbFo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=8" target="_blank" rel="external">链式哈希表（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;index=9&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">Table Doubling 和 Karp-Rabin（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=rvdJDijO2Ro&amp;index=10&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">Open Addressing 和密码型哈希（Cryptographic Hashing）（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=C4Kc8xzcA68" target="_blank" rel="external">PyCon 2010：The Mighty Dictionary（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=z0lJ2k0sl1g&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=11" target="_blank" rel="external">（进阶）随机取样（Randomization）：全域哈希（Universal Hashing）&amp; 完美哈希（Perfect Hashing）（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=N0COwN14gt0&amp;list=PL2B4EEwhKD-NbwZ4ezj7gyc_3yNrojKM9&amp;index=4" target="_blank" rel="external">（进阶）完美哈希（Perfect hashing）（视频）</a></li>
</ul>
</li>
<li><p>[ ] 在线课程：</p>
<ul>
<li>[ ] <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Understanding-hash-functions/149042/177126-4.html" target="_blank" rel="external">哈希函数的掌握（视频）</a></li>
<li>[ ] <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Using-hash-tables/149042/177127-4.html" target="_blank" rel="external">使用哈希表（视频）</a></li>
<li>[ ] <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Supporting-hashing/149042/177128-4.html" target="_blank" rel="external">哈希表的支持（视频）</a></li>
<li>[ ] <a href="https://www.lynda.com/Developer-Programming-Foundations-tutorials/Language-support-hash-tables/149042/177129-4.html" target="_blank" rel="external">哈希表的语言支持（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/m7UuP/core-hash-tables" target="_blank" rel="external">基本哈希表（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/home/week/3" target="_blank" rel="external">数据结构（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/NYZZP/phone-book-problem" target="_blank" rel="external">电话薄问题（Phone Book Problem）（视频）</a></li>
<li>[ ] 分布式哈希表：<ul>
<li><a href="https://www.coursera.org/learn/data-structures/lecture/DvaIb/instant-uploads-and-storage-optimization-in-dropbox" target="_blank" rel="external">Dropbox 中的瞬时上传及存储优化（视频）</a></li>
<li><a href="https://www.coursera.org/learn/data-structures/lecture/tvH8H/distributed-hash-tables" target="_blank" rel="external">分布式哈希表（视频）</a></li>
</ul>
</li>
</ul>
</li>
<li><p>[ ] 使用线性探测的数组去实现</p>
<ul>
<li>hash(k, m) —— m 是哈希表的大小</li>
<li>add(key, value) —— 如果 key 已存在则更新值</li>
<li>exists(key)</li>
<li>get(key)</li>
<li>remove(key)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="u66F4_u591A_u7684_u77E5_u8BC6"><a href="#u66F4_u591A_u7684_u77E5_u8BC6" class="headerlink" title="更多的知识"></a>更多的知识</h2><ul>
<li><h3 id="u4E8C_u5206_u67E5_u627E_uFF08Binary_search_uFF09"><a href="#u4E8C_u5206_u67E5_u627E_uFF08Binary_search_uFF09" class="headerlink" title="二分查找（Binary search）"></a>二分查找（Binary search）</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=D5SrAga1pno" target="_blank" rel="external">二分查找（视频）</a></li>
<li>[ ] <a href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search" target="_blank" rel="external">二分查找（视频）</a></li>
<li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/" target="_blank" rel="external">详情</a></li>
<li>[ ] 实现：<ul>
<li>二分查找（在一个已排序好的整型数组中查找）</li>
<li>迭代式二分查找</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u6309_u4F4D_u8FD0_u7B97_uFF08Bitwise_operations_uFF09"><a href="#u6309_u4F4D_u8FD0_u7B97_uFF08Bitwise_operations_uFF09" class="headerlink" title="按位运算（Bitwise operations）"></a>按位运算（Bitwise operations）</h3><ul>
<li>[ ] <a href="https://github.com/jwasham/google-interview-university/blob/master/extras/cheat%20sheets/bits-cheat-cheet.pdf" target="_blank" rel="external">Bits 速查表</a><ul>
<li>你需要知道大量2的幂数值（从2^1 到 2^16 及 2^32）</li>
</ul>
</li>
<li>[ ] 好好理解位操作符的含义：&amp;、|、^、~、&gt;&gt;、&lt;&lt;<ul>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture" target="_blank" rel="external">字码（words）</a>)</li>
<li>[ ] 好的介绍：<br>  <a href="https://www.youtube.com/watch?v=7jkIUgLC29I" target="_blank" rel="external">位操作（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=d0AwjSpNXR0" target="_blank" rel="external">C 语言编程教程 2-10：按位运算（视频）</a></li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Bit_manipulation" target="_blank" rel="external">位操作</a></li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Bitwise_operation" target="_blank" rel="external">按位运算</a></li>
<li>[ ] <a href="https://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="external">Bithacks</a></li>
<li>[ ] <a href="http://bits.stephan-brumme.com/" target="_blank" rel="external">位元抚弄者（The Bit Twiddler）</a></li>
<li>[ ] <a href="http://bits.stephan-brumme.com/interactive.html" target="_blank" rel="external">交互式位元抚弄者（The Bit Twiddler Interactive）</a></li>
</ul>
</li>
<li>[ ] 一补数和补码<ul>
<li><a href="https://www.youtube.com/watch?v=lKTsv6iVxV4" target="_blank" rel="external">二进制：利 &amp; 弊（为什么我们要使用补码）（视频）</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ones%27_complement" target="_blank" rel="external">一补数（1s Complement）</a></li>
<li><a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="external">补码（2s Complement）</a></li>
</ul>
</li>
<li>[ ] 计算置位（Set Bits）<ul>
<li><a href="https://youtu.be/Hzuzo9NJrlc" target="_blank" rel="external">计算一个字节中置位（Set Bits）的四种方式（视频）</a></li>
<li><a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan" target="_blank" rel="external">计算比特位</a></li>
<li><a href="http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer" target="_blank" rel="external">如何在一个 32 位的整型中计算置位（Set Bits）的数量</a></li>
</ul>
</li>
<li>[ ] 四舍五入2的幂数：<ul>
<li><a href="http://bits.stephan-brumme.com/roundUpToNextPowerOfTwo.html" target="_blank" rel="external">四舍五入到2的下一幂数</a></li>
</ul>
</li>
<li>[ ] 交换值：<ul>
<li><a href="http://bits.stephan-brumme.com/swap.html" target="_blank" rel="external">交换（Swap）</a></li>
</ul>
</li>
<li>[ ] 绝对值：<ul>
<li><a href="http://bits.stephan-brumme.com/absInteger.html" target="_blank" rel="external">绝对整型（Absolute Integer）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="u6811_uFF08Trees_uFF09"><a href="#u6811_uFF08Trees_uFF09" class="headerlink" title="树（Trees）"></a>树（Trees）</h2><ul>
<li><h3 id="u6811__u2014_u2014__u7B14_u8BB0__26amp_3B__u80CC_u666F"><a href="#u6811__u2014_u2014__u7B14_u8BB0__26amp_3B__u80CC_u666F" class="headerlink" title="树 —— 笔记 &amp; 背景"></a>树 —— 笔记 &amp; 背景</h3><ul>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/ovovP/core-trees" target="_blank" rel="external">系列：基本树（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/95qda/trees" target="_blank" rel="external">系列：树（视频）</a></li>
<li>基本的树形结构</li>
<li>遍历</li>
<li>操作算法</li>
<li>BFS（广度优先检索，breadth-first search）<ul>
<li><a href="https://www.youtube.com/watch?v=s-CYnVz-uh4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=13" target="_blank" rel="external">MIT（视频）</a></li>
<li>层序遍历（使用队列的 BFS 算法）<ul>
<li>时间复杂度： O(n)</li>
<li>空间复杂度：<ul>
<li>最好情况： O(1)</li>
<li>最坏情况：O(n/2)=O(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>DFS（深度优先检索，depth-first search）<ul>
<li><a href="https://www.youtube.com/watch?v=AfSk24UTFS8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=14" target="_blank" rel="external">MIT（视频）</a></li>
<li>笔记：<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：<ul>
<li>最好情况：O(log n) - 树的平均高度</li>
<li>最坏情况：O(n)</li>
</ul>
</li>
</ul>
</li>
<li>中序遍历（DFS：左、节点本身、右）</li>
<li>后序遍历（DFS：左、右、节点本身）</li>
<li>先序遍历（DFS：节点本身、左、右）</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u4E8C_u53C9_u67E5_u627E_u6811_uFF08Binary_search_trees_uFF09_uFF1ABSTs"><a href="#u4E8C_u53C9_u67E5_u627E_u6811_uFF08Binary_search_trees_uFF09_uFF1ABSTs" class="headerlink" title="二叉查找树（Binary search trees）：BSTs"></a>二叉查找树（Binary search trees）：BSTs</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=x6At0nzX92o&amp;index=1&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="external">二叉查找树概览（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/p82sw/core-introduction-to-binary-search-trees" target="_blank" rel="external">系列（视频）</a><ul>
<li>从符号表开始到 BST 程序</li>
</ul>
</li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/E7cXP/introduction" target="_blank" rel="external">介绍（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=9Jry5-82I68" target="_blank" rel="external">MIT（视频）</a></li>
<li>C/C++:<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=COZK7NATh4k&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=28" target="_blank" rel="external">二叉查找树 —— 在 C/C++ 中实现（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=hWokyBoo0aI&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=29" target="_blank" rel="external">BST 的实现 —— 在堆栈和堆中的内存分配（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Ut90klNN264&amp;index=30&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="external">在二叉查找树中找到最小和最大的元素（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=_pnqMz5nrRs&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=31" target="_blank" rel="external">寻找二叉树的高度（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=9RHO6jU--GU&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=32" target="_blank" rel="external">二叉树的遍历 —— 广度优先和深度优先策略（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=86g8jAQug04&amp;index=33&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="external">二叉树：层序遍历（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=gm8DUJJhmY4&amp;index=34&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="external">二叉树的遍历：先序、中序、后序（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=yEwSGhSsT0U&amp;index=35&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="external">判断一棵二叉树是否为二叉查找树（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=gcULXE7ViZw&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=36" target="_blank" rel="external">从二叉查找树中删除一个节点（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=5cPbNCrdotA&amp;index=37&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="external">二叉查找树中序遍历的后继者（视频）</a></li>
</ul>
</li>
<li>[ ] 实现：<ul>
<li>[ ] insert    // 往树上插值</li>
<li>[ ] get_node_count // 查找树上的节点数</li>
<li>[ ] print_values // 从小到大打印树中节点的值</li>
<li>[ ] delete_tree</li>
<li>[ ] is_in_tree // 如果值存在于树中则返回 true</li>
<li>[ ] get_height // 返回节点所在的高度（如果只有一个节点，那么高度则为1）</li>
<li>[ ] get_min   // 返回树上的最小值</li>
<li>[ ] get_max   // 返回树上的最大值</li>
<li>[ ] is_binary_search_tree</li>
<li>[ ] delete_value</li>
<li>[ ] get_successor // 返回给定值的后继者，若没有则返回-1</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u5806_uFF08Heap_uFF09_/__u4F18_u5148_u7EA7_u961F_u5217_uFF08Priority_Queue_uFF09_/__u4E8C_u53C9_u5806_uFF08Binary_Heap_uFF09"><a href="#u5806_uFF08Heap_uFF09_/__u4F18_u5148_u7EA7_u961F_u5217_uFF08Priority_Queue_uFF09_/__u4E8C_u53C9_u5806_uFF08Binary_Heap_uFF09" class="headerlink" title="堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）"></a>堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</h3><ul>
<li>可视化是一棵树，但通常是以线性的形式存储（数组、链表）</li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="external">堆</a>)</li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/2OpTs/introduction" target="_blank" rel="external">介绍（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/z3l9N/naive-implementations" target="_blank" rel="external">无知的实现（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/GRV2q/binary-trees" target="_blank" rel="external">二叉树（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/supplement/S5xxz/tree-height-remark" target="_blank" rel="external">关于树高的讨论（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/0g1dl/basic-operations" target="_blank" rel="external">基本操作（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/gl5Ni/complete-binary-trees" target="_blank" rel="external">完全二叉树（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/HxQo9/pseudocode" target="_blank" rel="external">伪代码（视频）</a></li>
<li>[ ] <a href="https://youtu.be/odNJmw5TOEE?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3291" target="_blank" rel="external">堆排序 —— 跳到起点（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/hSzMO/heap-sort" target="_blank" rel="external">堆排序（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/dwrOS/building-a-heap" target="_blank" rel="external">构建一个堆（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=B7hVxCmfPtM&amp;index=4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">MIT：堆与堆排序（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=yIUFT6AKBGE&amp;index=24&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="external">CS 61B Lecture 24：优先级队列（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=MiyLo8adrWw" target="_blank" rel="external">构建线性时间复杂度的堆（大顶堆）</a></li>
<li>[ ] 实现一个大顶堆：<ul>
<li>[ ] insert</li>
<li>[ ] sift_up —— 用于插入元素</li>
<li>[ ] get_max —— 返回最大值但不移除元素</li>
<li>[ ] get_size() —— 返回存储的元素数量</li>
<li>[ ] is_empty() —— 若堆为空则返回 true</li>
<li>[ ] extract_max —— 返回最大值并移除</li>
<li>[ ] sift_down —— 用于获取最大值元素</li>
<li>[ ] remove(i) —— 删除指定索引的元素</li>
<li>[ ] heapify —— 构建堆，用于堆排序</li>
<li>[ ] heap_sort() —— 拿到一个未排序的数组，然后使用大顶堆进行就地排序<ul>
<li>注意：若用小顶堆可节省操作，但导致空间复杂度加倍。（无法做到就地）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u5B57_u5178_u6811_uFF08Tries_uFF09"><a href="#u5B57_u5178_u6811_uFF08Tries_uFF09" class="headerlink" title="字典树（Tries）"></a>字典树（Tries）</h3><ul>
<li>需要注意的是，字典树各式各样。有些有前缀，而有些则没有。有些使用字符串而不使用比特位来追踪路径。</li>
<li>阅读代码，但不实现。</li>
<li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Tries" target="_blank" rel="external">数据结构笔记及编程技术</a></li>
<li>[ ] 短课程视频：<ul>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/08Xyf/core-introduction-to-tries" target="_blank" rel="external">对字典树的介绍（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/PvlZW/core-performance-of-tries" target="_blank" rel="external">字典树的性能（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/DFvd3/core-implementing-a-trie" target="_blank" rel="external">实现一棵字典树（视频）</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure" target="_blank" rel="external">字典树：一个被忽略的数据结构</a></li>
<li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/" target="_blank" rel="external">高级编程 —— 使用字典树</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=TJ8SkcUSdbU" target="_blank" rel="external">标准教程（现实中的用例）（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=NinWEPPrkDQ&amp;index=16&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf" target="_blank" rel="external">MIT，高阶数据结构，使用字符串追踪路径（可事半功倍）</a></li>
</ul>
</li>
<li><h3 id="u5E73_u8861_u67E5_u627E_u6811_uFF08Balanced_search_trees_uFF09"><a href="#u5E73_u8861_u67E5_u627E_u6811_uFF08Balanced_search_trees_uFF09" class="headerlink" title="平衡查找树（Balanced search trees）"></a>平衡查找树（Balanced search trees）</h3><ul>
<li>掌握至少一种平衡查找树（并懂得如何实现）：</li>
<li>“在各种平衡查找树当中，AVL 树和2-3树已经成为了过去，而红黑树（red-black trees）看似变得越来越受人青睐。这种令人特别感兴趣的数据结构，亦称伸展树（splay tree）。它可以自我管理，且会使用轮换来移除任何访问过根节点的 key。” —— Skiena</li>
<li>因此，在各种各样的平衡查找树当中，我选择了伸展树来实现。虽然，通过我的阅读，我发现在 Google 的面试中并不会被要求实现一棵平衡查找树。但是，为了胜人一筹，我们还是应该看看如何去实现。在阅读了大量关于红黑树的代码后，我才发现伸展树的实现确实会使得各方面更为高效。<ul>
<li>伸展树：插入、查找、删除函数的实现，而如果你最终实现了红黑树，那么请尝试一下：</li>
<li>跳过删除函数，直接实现搜索和插入功能</li>
</ul>
</li>
<li>我希望能阅读到更多关于 B 树的资料，因为它也被广泛地应用到大型的数据库当中。</li>
<li><p>[ ] <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="external">自平衡二叉查找树</a></p>
</li>
<li><p>[ ] <strong>AVL 树</strong></p>
<ul>
<li>实际中：我能告诉你的是，该种树并无太多的用途，但我能看到有用的地方在哪里：AVL 树是另一种平衡查找树结构。其可支持时间复杂度为 O(log n) 的查询、插入及删除。它比红黑树严格意义上更为平衡，从而导致插入和删除更慢，但遍历却更快。正因如此，才彰显其结构的魅力。只需要构建一次，就可以在不重新构造的情况下读取，适合于实现诸如语言字典（或程序字典，如一个汇编程序或解释程序的操作码）。</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=FNeL18KsWPc&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=6" target="_blank" rel="external">MIT AVL 树 / AVL 树的排序（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/Qq5E0/avl-trees" target="_blank" rel="external">AVL 树（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/PKEBC/avl-tree-implementation" target="_blank" rel="external">AVL 树的实现（视频）</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/22BgE/split-and-merge" target="_blank" rel="external">分离与合并</a></li>
</ul>
</li>
<li><p>[ ] <strong>伸展树</strong></p>
<ul>
<li>实际中：伸展树一般用于缓存、内存分配者、路由器、垃圾回收者、数据压缩、ropes（字符串的一种替代品，用于存储长串的文本字符）、Windows NT（虚拟内存、网络及文件系统）等的实现。</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Najzh1rYQTo&amp;index=23&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd" target="_blank" rel="external">CS 61B：伸展树（Splay trees）（视频）</a></li>
<li>[ ] MIT 教程：伸展树（Splay trees）：<ul>
<li>该教程会过于学术，但请观看到最后的10分钟以确保掌握。</li>
<li><a href="https://www.youtube.com/watch?v=QnPl_Y6EqMo" target="_blank" rel="external">视频</a></li>
</ul>
</li>
</ul>
</li>
<li><p>[ ] <strong>2-3查找树</strong></p>
<ul>
<li>实际中：2-3树的元素插入非常快速，但却有着查询慢的代价（因为相比较 AVL 树来说，其高度更高）。</li>
<li>你会很少用到2-3树。这是因为，其实现过程中涉及到不同类型的节点。因此，人们更多地会选择红黑树。</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=C3SsdUqasD4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=2" target="_blank" rel="external">2-3树的直感与定义（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=iYvBtGKsqSg&amp;index=3&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="external">2-3树的二元观点</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=TOb1tuEZ2X4&amp;index=5&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="external">2-3树（学生叙述）（视频）</a></li>
</ul>
</li>
<li><p>[ ] <strong>2-3-4树 (亦称2-4树)</strong></p>
<ul>
<li>实际中：对于每一棵2-4树，都有着对应的红黑树来存储同样顺序的数据元素。在2-4树上进行插入及删除操作等同于在红黑树上进行颜色翻转及轮换。这使得2-4树成为一种用于掌握红黑树背后逻辑的重要工具。这就是为什么许多算法引导文章都会在介绍红黑树之前，先介绍2-4树，尽管<strong>2-4树在实际中并不经常使用</strong>。</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=zqrqYXkth6Q&amp;index=26&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="external">CS 61B Lecture 26：平衡查找树（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=DQdMYevEyE4&amp;index=4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="external">自底向上的2-4树（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=2679VQ26Fp4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=5" target="_blank" rel="external">自顶向下的2-4树（视频）</a></li>
</ul>
</li>
<li><p>[ ] <strong>B 树</strong></p>
<ul>
<li>有趣的是：为啥叫 B 仍然是一个神秘。因为 B 可代表波音（Boeing）、平衡（Balanced）或 Bayer（联合创造者）</li>
<li>实际中：B 树会被广泛适用于数据库中，而现代大多数的文件系统都会使用到这种树（或变种)。除了运用在数据库中，B 树也会被用于文件系统以快速访问一个文件的任意块。但存在着一个基本的问题，那就是如何将文件块 i 转换成一个硬盘块（或一个柱面-磁头-扇区）上的地址。</li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="external">B 树</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=I22wEC1tTGo&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=6" target="_blank" rel="external">B 树的介绍（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=s3bCdZGrgpA&amp;index=7&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="external">B 树的定义及其插入操作（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=svfnVhJOfMc&amp;index=8&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="external">B 树的删除操作（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=V3omVLzI0WE&amp;index=7&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf" target="_blank" rel="external">MIT 6.851 —— 内存层次模块（Memory Hierarchy Models）（视频）</a><ul>
<li>覆盖有高速缓存参数无关型（cache-oblivious）B 树和非常有趣的数据结构</li>
<li>头37分钟讲述的很专业，或许可以跳过（B 指块的大小、即缓存行的大小）</li>
</ul>
</li>
</ul>
</li>
<li><p>[ ] <strong>红黑树</strong></p>
<ul>
<li>实际中：红黑树提供了在最坏情况下插入操作、删除操作和查找操作的时间保证。这些时间值的保障不仅对时间敏感型应用有用，例如实时应用，还对在其他数据结构中块的构建非常有用，而这些数据结构都提供了最坏情况下的保障；例如，许多用于计算几何学的数据结构都可以基于红黑树，而目前 Linux 系统所采用的完全公平调度器（the Completely Fair Scheduler）也使用到了该种树。在 Java 8中，红黑树也被用于存储哈希列表集合中相同的数据，而不是使用链表及哈希码。</li>
<li>[ ] <a href="https://youtu.be/1W3x0f_RmUo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3871" target="_blank" rel="external">Aduni —— 算法 —— 课程4（该链接直接跳到开始部分）（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=hm2GHwyKF1o&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=5" target="_blank" rel="external">Aduni —— 算法 —— 课程5（视频）</a></li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="external">黑树（Black Tree）</a></li>
<li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/" target="_blank" rel="external">二分查找及红黑树的介绍</a></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="N__u53C9_u6811_uFF08K__u53C9_u6811_u3001M__u53C9_u6811_uFF09"><a href="#N__u53C9_u6811_uFF08K__u53C9_u6811_u3001M__u53C9_u6811_uFF09" class="headerlink" title="N 叉树（K 叉树、M 叉树）"></a>N 叉树（K 叉树、M 叉树）</h3><ul>
<li>注意：N 或 K 指的是分支系数（即树的最大分支数）：<ul>
<li>二叉树是一种分支系数为2的树</li>
<li>2-3树是一种分支系数为3的树</li>
</ul>
</li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/K-ary_tree" target="_blank" rel="external">K 叉树</a></li>
</ul>
</li>
</ul>
<h2 id="u6392_u5E8F_uFF08Sorting_uFF09"><a href="#u6392_u5E8F_uFF08Sorting_uFF09" class="headerlink" title="排序（Sorting）"></a>排序（Sorting）</h2><ul>
<li><p>[ ] 笔记:</p>
<ul>
<li>实现各种排序 &amp; 知道每种排序的最坏、最好和平均的复杂度分别是什么场景:<ul>
<li>不要用冒泡排序 - 大多数情况下效率感人 - 时间复杂度 O(n^2), 除非 n &lt;= 16</li>
</ul>
</li>
<li>[ ] 排序算法的稳定性 (“快排是稳定的么?”)<ul>
<li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="external">排序算法的稳定性</a></li>
<li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms" target="_blank" rel="external">排序算法的稳定性</a></li>
<li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms" target="_blank" rel="external">排序算法的稳定性</a></li>
<li><a href="http://www.geeksforgeeks.org/stability-in-sorting-algorithms/" target="_blank" rel="external">排序算法的稳定性</a></li>
<li><a href="http://homepages.math.uic.edu/~leon/cs-mcs401-s08/handouts/stability.pdf" target="_blank" rel="external">排序算法 - 稳定性</a></li>
</ul>
</li>
<li>[ ] 哪种排序算法可以用链表？哪种用数组？哪种两者都可？<ul>
<li>并不推荐对一个链表排序，但归并排序是可行的.</li>
<li><a href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/" target="_blank" rel="external">链表的归并排序</a></li>
</ul>
</li>
</ul>
</li>
<li><p>关于堆排序，请查看前文堆的数据结构部分。堆排序很强大，不过是非稳定排序。</p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=P00xJgWzz2c&amp;index=1&amp;list=PL89B61F78B552C1AB" target="_blank" rel="external">冒泡排序 (video)</a></p>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ni_zk257Nqo&amp;index=7&amp;list=PL89B61F78B552C1AB" target="_blank" rel="external">冒泡排序分析 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Kg4bqzAqRBM&amp;index=3&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">插入排序 &amp; 归并排序 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=c4BRHC7kTaQ&amp;index=2&amp;list=PL89B61F78B552C1AB" target="_blank" rel="external">插入排序 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=GCae1WNvnZM&amp;index=3&amp;list=PL89B61F78B552C1AB" target="_blank" rel="external">归并排序 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=y_G9BkAm6B8&amp;index=4&amp;list=PL89B61F78B552C1AB" target="_blank" rel="external">快排 (video)</a></li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=6nDMgr0-Yyo&amp;index=8&amp;list=PL89B61F78B552C1AB" target="_blank" rel="external">选择排序 (video)</a></p>
</li>
<li><p>[ ] 斯坦福大学关于排序算法的视频:</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=ENp00xylP7c&amp;index=15&amp;list=PLFE6E58F856038C69" target="_blank" rel="external">课程 15 | 编程抽象 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=y4M9IVgrVKo&amp;index=16&amp;list=PLFE6E58F856038C69" target="_blank" rel="external">课程 16 | 编程抽象 (video)</a></li>
</ul>
</li>
<li><p>[ ] Shai Simonson 视频, <a href="http://www.aduni.org/" target="_blank" rel="external">Aduni.org</a>:</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=odNJmw5TOEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=2" target="_blank" rel="external">算法 - 排序 - 第二讲 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=hj8YKFTFKEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=3" target="_blank" rel="external">算法 - 排序2 - 第三讲 (video)</a></li>
</ul>
</li>
<li><p>[ ] Steven Skiena 关于排序的视频:</p>
<ul>
<li>[ ] <a href="https://youtu.be/ute-pmMkyuk?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1600" target="_blank" rel="external">课程从 26:46 开始 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=yLvp-pB8mak&amp;index=8&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="external">课程从 27:40 开始 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=q7K9otnzlfE&amp;index=9&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="external">课程从 35:00 开始 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=TvqIGu9Iupw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=10" target="_blank" rel="external">课程从 23:50 开始 (video)</a></li>
</ul>
</li>
<li><p>[ ] 加州大学伯克利分校（UC Berkeley） 大学课程:</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=EiUvYS2DT6I&amp;list=PL4BBB74C7D2A1049C&amp;index=29" target="_blank" rel="external">CS 61B 课程 29: 排序 I (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=2hTY3t80Qsk&amp;list=PL4BBB74C7D2A1049C&amp;index=30" target="_blank" rel="external">CS 61B 课程 30: 排序 II (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Y6LOLpxg6Dc&amp;index=32&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="external">CS 61B 课程 32: 排序 III (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=qNMQ4ly43p4&amp;index=33&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="external">CS 61B 课程 33: 排序 V (video)</a></li>
</ul>
</li>
<li><p>[ ] - 归并排序:</p>
<ul>
<li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/sorting/mergesort.c" target="_blank" rel="external">使用外部数组</a></li>
<li>[ ] <a href="https://github.com/jwasham/practice-cpp/blob/master/merge_sort/merge_sort.cc" target="_blank" rel="external">对原数组直接排序</a></li>
</ul>
</li>
<li><p>[ ] - 快速排序:</p>
<ul>
<li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/randomization/quick.c" target="_blank" rel="external">实现</a></li>
<li>[ ] <a href="https://github.com/jwasham/practice-c/blob/master/quick_sort/quick_sort.c" target="_blank" rel="external">实现</a></li>
</ul>
</li>
<li><p>[ ] 实现:</p>
<ul>
<li>[ ] 归并：平均和最差情况的时间复杂度为 O(n log n)。</li>
<li>[ ] 快排：平均时间复杂度为 O(n log n)。</li>
<li>选择排序和插入排序的最坏、平均时间复杂度都是 O(n^2)。</li>
<li>关于堆排序，请查看前文堆的数据结构部分。</li>
</ul>
</li>
<li><p>[ ] 有兴趣的话，还有一些补充 - 但并不是必须的:</p>
<ul>
<li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#radixSort" target="_blank" rel="external">基数排序</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=xhr26ia4k38" target="_blank" rel="external">基数排序 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Nz1KZXbghj8&amp;index=7&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">基数排序, 计数排序 (线性时间内) (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=cNB2lADK3_s&amp;index=8&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="external">随机算法: 矩阵相乘, 快排, Freivalds’ 算法 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=pOKy3RZbSws&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=14" target="_blank" rel="external">线性时间内的排序 (video)</a></li>
</ul>
</li>
</ul>
<h2 id="u56FE_uFF08Graphs_uFF09"><a href="#u56FE_uFF08Graphs_uFF09" class="headerlink" title="图（Graphs）"></a>图（Graphs）</h2><p>图论能解决计算机科学里的很多问题，所以这一节会比较长，像树和排序的部分一样。</p>
<ul>
<li><p>Yegge 的笔记:</p>
<ul>
<li>有 3 种基本方式在内存里表示一个图:<ul>
<li>对象和指针</li>
<li>矩阵</li>
<li>邻接表</li>
</ul>
</li>
<li>熟悉以上每一种图的表示法，并了解各自的优缺点</li>
<li>宽度优先搜索和深度优先搜索 - 知道它们的计算复杂度和设计上的权衡以及如何用代码实现它们</li>
<li>遇到一个问题时，首先尝试基于图的解决方案，如果没有再去尝试其他的。</li>
</ul>
</li>
<li><p>[ ] Skiena 教授的课程 - 很不错的介绍:</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=OiXxhDrFruw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=11" target="_blank" rel="external">CSE373 2012 - 课程 11 - 图的数据结构 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=g5vF8jscteo&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=12" target="_blank" rel="external">CSE373 2012 - 课程 12 - 广度优先搜索 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=S23W6eTcqdY&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=13" target="_blank" rel="external">CSE373 2012 - 课程 13 - 图的算法 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=WitPBKGV0HY&amp;index=14&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="external">CSE373 2012 - 课程 14 - 图的算法 (1) (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ia1L30l7OIg&amp;index=15&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="external">CSE373 2012 - 课程 15 - 图的算法 (2) (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=jgDOQq6iWy8&amp;index=16&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="external">CSE373 2012 - 课程 16 - 图的算法 (3) (video)</a></li>
</ul>
</li>
<li><p>[ ] 图 (复习和其他):</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=Aa2sqUhIn-E&amp;index=15&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">6.006 单源最短路径问题 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=2E7MmKv0Y24&amp;index=16&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">6.006 Dijkstra 算法 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ozsuci5pIso&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=17" target="_blank" rel="external">6.006 Bellman-Ford 算法(video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=CHvQ3q_gJ7E&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=18" target="_blank" rel="external">6.006 Dijkstra 效率优化 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=i_AQT_XfvD8&amp;index=6&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="external">Aduni: 图的算法 I - 拓扑排序, 最小生成树, Prim 算法 -  第六课 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ufj5_bppBsA&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=7" target="_blank" rel="external">Aduni: 图的算法 II - 深度优先搜索, 广度优先搜索, Kruskal 算法, 并查集数据结构 - 第七课 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=DiedsPsMKXc&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=8" target="_blank" rel="external">Aduni: 图的算法 III: 最短路径 - 第八课 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=XIAQRlNkJAw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=9" target="_blank" rel="external">Aduni: 图的算法. IV: 几何算法介绍 - 第九课 (video)</a></li>
<li>[ ] <a href="https://youtu.be/dgjX4HdMI-Q?list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;t=3489" target="_blank" rel="external">CS 61B 2014 (从 58:09 开始) (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=aJjlQCFwylA&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=19" target="_blank" rel="external">CS 61B 2014: 加权图 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=tKwnms5iRBU&amp;index=16&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="external">贪心算法: 最小生成树 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=RpgcYiky7uw" target="_blank" rel="external">图的算法之强连通分量 Kosaraju 算法 (video)</a></li>
</ul>
</li>
<li><p>完整的 Coursera 课程:</p>
<ul>
<li>[ ] <a href="https://www.coursera.org/learn/algorithms-on-graphs/home/welcome" target="_blank" rel="external">图的算法 (video)</a></li>
</ul>
</li>
<li><p>Yegge: 如果有机会，可以试试研究更酷炫的算法:</p>
<ul>
<li>[ ] Dijkstra 算法 - 上文 - 6.006</li>
<li>[ ] A* 算法<ul>
<li>[ ] <a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="external">A* 算法</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=KNXfSOx4eEE" target="_blank" rel="external">A* 寻路教程 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=-L-WgKMFuhE" target="_blank" rel="external">A* 寻路 (E01: 算法解释) (video)</a></li>
</ul>
</li>
</ul>
</li>
<li><p>我会实现:</p>
<ul>
<li>[ ] DFS 邻接表 (递归)</li>
<li>[ ] DFS 邻接表 (栈迭代)</li>
<li>[ ] DFS 邻接矩阵 (递归)</li>
<li>[ ] DFS 邻接矩阵 (栈迭代)</li>
<li>[ ] BFS 邻接表</li>
<li>[ ] BFS 邻接矩阵</li>
<li>[ ] 单源最短路径问题 (Dijkstra)</li>
<li>[ ] 最小生成树</li>
<li>基于 DFS 的算法 (根据上文 Aduni 的视频):<ul>
<li>[ ] 检查环 (我们会先检查是否有环存在以便做拓扑排序)</li>
<li>[ ] 拓扑排序</li>
<li>[ ] 计算图中的连通分支</li>
<li>[ ] 列出强连通分量</li>
<li>[ ] 检查双向图</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以从 Skiena 的书（参考下面的书推荐小节）和面试书籍中学习更多关于图的实践。</p>
<h2 id="u66F4_u591A_u77E5_u8BC6"><a href="#u66F4_u591A_u77E5_u8BC6" class="headerlink" title="更多知识"></a>更多知识</h2><ul>
<li><h3 id="u9012_u5F52_uFF08Recursion_uFF09"><a href="#u9012_u5F52_uFF08Recursion_uFF09" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h3><ul>
<li>[ ] Stanford 大学关于递归 &amp; 回溯的课程:<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=gl3emqCuueQ&amp;list=PLFE6E58F856038C69&amp;index=8" target="_blank" rel="external">课程 8 | 抽象编程 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=uFJhEPrbycQ&amp;list=PLFE6E58F856038C69&amp;index=9" target="_blank" rel="external">课程 9 | 抽象编程 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=NdF1QDTRkck&amp;index=10&amp;list=PLFE6E58F856038C69" target="_blank" rel="external">课程 10 | 抽象编程 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=p-gpaIGRCQI&amp;list=PLFE6E58F856038C69&amp;index=11" target="_blank" rel="external">课程 11 | 抽象编程 (video)</a></li>
</ul>
</li>
<li>什么时候适合使用</li>
<li>尾递归会更好么?<ul>
<li>[ ] <a href="https://www.quora.com/What-is-tail-recursion-Why-is-it-so-bad" target="_blank" rel="external">什么是尾递归以及为什么它如此糟糕?</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=L1jjXGfxozc" target="_blank" rel="external">尾递归 (video)</a></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u52A8_u6001_u89C4_u5212_uFF08Dynamic_Programming_uFF09"><a href="#u52A8_u6001_u89C4_u5212_uFF08Dynamic_Programming_uFF09" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h3><ul>
<li>This subject can be pretty difficult, as each DP soluble problem must be defined as a recursion relation, and coming up with it can be tricky.</li>
<li>这一部分会有点困难，每个可以用动态规划解决的问题都必须先定义出递推关系，要推导出来可能会有点棘手。</li>
<li><p>我建议先阅读和学习足够多的动态规划的例子，以便对解决 DP 问题的一般模式有个扎实的理解。</p>
</li>
<li><p>[ ] 视频:</p>
<ul>
<li>Skiena 的视频可能会有点难跟上，有时候他用白板写的字会比较小，难看清楚。</li>
<li>[ ] <a href="https://youtu.be/Qc2ieXRgR0k?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1718" target="_blank" rel="external">Skiena: CSE373 2012 - 课程 19 - 动态规划介绍 (video)</a></li>
<li>[ ] <a href="https://youtu.be/IsmMhMdyeGY?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=2749" target="_blank" rel="external">Skiena: CSE373 2012 - 课程 20 - 编辑距离 (video)</a></li>
<li>[ ] <a href="https://youtu.be/o0V9eYF4UI8?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=406" target="_blank" rel="external">Skiena: CSE373 2012 - 课程 21 - 动态规划举例 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=dRbMC1Ltl3A&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=22" target="_blank" rel="external">Skiena: CSE373 2012 - 课程 22 - 动态规划应用 (video)</a></li>
<li>[ ] <a href="https://youtu.be/J5aJEcOr6Eo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3558" target="_blank" rel="external">Simonson: 动态规划 0 (starts at 59:18) (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=0EzHjQ_SOeU&amp;index=11&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="external">Simonson: 动态规划 I - 课程 11 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=v1qiRwuJU7g&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=12" target="_blank" rel="external">Simonson: 动态规划 II - 课程 12 (video)</a></li>
<li>[ ] 单独的 DP 问题 (每一个视频都很短):<br>  <a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr" target="_blank" rel="external">动态规划 (video)</a></li>
</ul>
</li>
<li>[ ] Yale 课程笔记:<ul>
<li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#dynamicProgramming" target="_blank" rel="external">动态规划</a></li>
</ul>
</li>
<li>[ ] Coursera 课程:<ul>
<li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/80RrW/the-rna-secondary-structure-problem" target="_blank" rel="external">RNA 二级结构问题 (video)</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/PSonq/a-dynamic-programming-algorithm" target="_blank" rel="external">动态规划算法 (video)</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/oUEK2/illustrating-the-dp-algorithm" target="_blank" rel="external">DP 算法描述 (video)</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/nfK2r/running-time-of-the-dp-algorithm" target="_blank" rel="external">DP 算法的运行时间 (video)</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/M999a/dp-vs-recursive-implementation" target="_blank" rel="external">DP vs 递归实现 (video)</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/UZ7o6/global-pairwise-sequence-alignment" target="_blank" rel="external">全局成对序列排列 (video)</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/WnNau/local-pairwise-sequence-alignment" target="_blank" rel="external">本地成对序列排列 (video)</a></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u7EC4_u5408_uFF08Combinatorics_uFF09__28n__u4E2D_u9009_k__u4E2A_29__26amp_3B__u6982_u7387_uFF08Probability_uFF09"><a href="#u7EC4_u5408_uFF08Combinatorics_uFF09__28n__u4E2D_u9009_k__u4E2A_29__26amp_3B__u6982_u7387_uFF08Probability_uFF09" class="headerlink" title="组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）"></a>组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=8RRo6Ti9d0U" target="_blank" rel="external">数据技巧: 如何找出阶乘、排列和组合(选择) (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=sZkAAk9Wwa4" target="_blank" rel="external">来点学校的东西: 概率 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=dNaJg-mLobQ" target="_blank" rel="external">来点学校的东西: 概率和马尔可夫链 (video)</a></li>
<li>[ ] 可汗学院:<ul>
<li>课程设置:<ul>
<li>[ ] <a href="https://www.khanacademy.org/math/probability/probability-and-combinatorics-topic" target="_blank" rel="external">概率理论基础</a></li>
</ul>
</li>
<li>视频 - 41 (每一个都短小精悍):<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=uzkc-qNVoOk&amp;list=PLC58778F28211FA19" target="_blank" rel="external">概率解释 (video)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="NP_2C_NP-_u5B8C_u5168_u548C_u8FD1_u4F3C_u7B97_u6CD5"><a href="#NP_2C_NP-_u5B8C_u5168_u548C_u8FD1_u4F3C_u7B97_u6CD5" class="headerlink" title="NP, NP-完全和近似算法"></a>NP, NP-完全和近似算法</h3><ul>
<li>知道最经典的一些 NP 完全问题，比如旅行商问题和背包问题,<br>  而且能在面试官试图忽悠你的时候识别出他们。</li>
<li>知道 NP 完全是什么意思.</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=moPtwq_cVH8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=23" target="_blank" rel="external">计算复杂度 (video)</a></li>
<li>[ ] Simonson:<ul>
<li>[ ] <a href="https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=2939" target="_blank" rel="external">贪心算法. II &amp; 介绍 NP-完全性 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=e0tGC6ZQdQE&amp;index=16&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="external">NP-完全性 II &amp; 归约 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=fCX1BGT3wjE&amp;index=17&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="external">NP-完全性 III (Video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=NKLDp3Rch3M&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=18" target="_blank" rel="external">NP-完全性 IV (video)</a></li>
</ul>
</li>
<li>[ ] Skiena:<ul>
<li>[ ] <a href="https://youtu.be/KiK5TVgXbFg?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1508" target="_blank" rel="external">CSE373 2012 - 课程 23 - 介绍 NP-完全性 IV (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=27Al52X3hd4&amp;index=24&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="external">CSE373 2012 - 课程 24 - NP-完全性证明 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=xCPH4gwIIXM&amp;index=25&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="external">CSE373 2012 - 课程 25 - NP-完全性挑战 (video)</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=eHZifpgyH_4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=22" target="_blank" rel="external">复杂度: P, NP, NP-完全性, 规约 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=MEz1J9wY2iM&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=24" target="_blank" rel="external">复杂度: 近视算法 Algorithms (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=4q-jmGrmxKs&amp;index=25&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="external">复杂度: 固定参数算法 (video)</a></li>
<li>Peter Norvik 讨论旅行商问题的近似最优解:<ul>
<li><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/TSP.ipynb" target="_blank" rel="external">Jupyter 笔记本</a></li>
</ul>
</li>
<li>《算法导论》的第 1048 - 1140 页。</li>
</ul>
</li>
<li><h3 id="u7F13_u5B58_uFF08Cache_uFF09"><a href="#u7F13_u5B58_uFF08Cache_uFF09" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h3><ul>
<li>[ ] LRU 缓存:<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=R5ON3iwx78M" target="_blank" rel="external">LRU 的魔力 (100 Days of Google Dev) (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=bq6N7Ym81iI" target="_blank" rel="external">实现 LRU (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=8-FZRAjR7qU" target="_blank" rel="external">LeetCode - 146 LRU Cache (C++) (video)</a></li>
</ul>
</li>
<li>[ ] CPU 缓存:<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=vjYF_fAZI5E&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&amp;index=24" target="_blank" rel="external">MIT 6.004 L15: 存储体系 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ajgC3-pyGlk&amp;index=25&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-" target="_blank" rel="external">MIT 6.004 L16: 缓存的问题 (video)</a></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u8FDB_u7A0B_uFF08Processe_uFF09_u548C_u7EBF_u7A0B_uFF08Thread_uFF09"><a href="#u8FDB_u7A0B_uFF08Processe_uFF09_u548C_u7EBF_u7A0B_uFF08Thread_uFF09" class="headerlink" title="进程（Processe）和线程（Thread）"></a>进程（Processe）和线程（Thread）</h3><ul>
<li>[ ] 计算机科学 162 - 操作系统 (25 个视频):<ul>
<li>视频 1-11 是关于进程和线程</li>
<li><a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c" target="_blank" rel="external">操作系统和系统编程 (video)</a></li>
</ul>
</li>
<li><a href="https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread" target="_blank" rel="external">进程和线程的区别是什么?</a></li>
<li>涵盖了:<ul>
<li>进程、线程、协程<ul>
<li>进程和线程的区别</li>
<li>进程</li>
<li>线程</li>
<li>锁</li>
<li>互斥</li>
<li>信号量</li>
<li>监控</li>
<li>他们是如何工作的</li>
<li>死锁</li>
<li>活锁</li>
</ul>
</li>
<li>CPU 活动, 中断, 上下文切换</li>
<li>现代多核处理器的并发式结构</li>
<li>进程资源需要（内存：代码、静态存储器、栈、堆、文件描述符、I/O）</li>
<li>线程资源需要（在同一个进程内和其他线程共享以上的资源，但是每个线程都有独立的程序计数器、栈计数器、寄存器和栈）</li>
<li>Fork 操作是真正的写时复制（只读），直到新的进程写到内存中，才会生成一份新的拷贝。</li>
<li>上下文切换<ul>
<li>操作系统和底层硬件是如何初始化上下文切换的。</li>
</ul>
</li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M" target="_blank" rel="external">C++ 的线程 (系列 - 10 个视频)</a></li>
<li>[ ] Python 的协程 (视频):<ul>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PL1H1sBF1VAKVMONJWJkmUh6_p8g4F2oy1" target="_blank" rel="external">线程系列</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Bs7vPNbB9JM" target="_blank" rel="external">Python 线程</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Obt-vMVdM8s" target="_blank" rel="external">理解 Python 的 GIL (2010)</a><ul>
<li><a href="http://www.dabeaz.com/GIL" target="_blank" rel="external">参考</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4" target="_blank" rel="external">David Beazley - Python 协程 - PyCon 2015</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ZzfHjytDceU" target="_blank" rel="external">Keynote David Beazley - 兴趣主题 (Python 异步 I/O)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=0zaPs8OtyKY" target="_blank" rel="external">Python 中的互斥</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>系统设计以及可伸缩性，要把软硬件的伸缩性设计的足够好有很多的东西要考虑，所以这是个包含非常多内容和资源的大主题。需要花费相当多的时间在这个主题上。
</code></pre><ul>
<li><h3 id="u7CFB_u7EDF_u8BBE_u8BA1_u3001_u53EF_u4F38_u7F29_u6027_u3001_u6570_u636E_u5904_u7406"><a href="#u7CFB_u7EDF_u8BBE_u8BA1_u3001_u53EF_u4F38_u7F29_u6027_u3001_u6570_u636E_u5904_u7406" class="headerlink" title="系统设计、可伸缩性、数据处理"></a>系统设计、可伸缩性、数据处理</h3><ul>
<li>Yegge 的注意事项:<ul>
<li>伸缩性<ul>
<li>把大数据集提取为单一值</li>
<li>大数据集转换</li>
<li>处理大量的数据集</li>
</ul>
</li>
<li>系统<ul>
<li>特征集</li>
<li>接口</li>
<li>类层次结构</li>
<li>在特定的约束下设计系统</li>
<li>轻量和健壮性</li>
<li>权衡和折衷</li>
<li>性能分析和优化</li>
</ul>
</li>
</ul>
</li>
<li>[ ] <strong>从这里开始</strong>: <a href="http://www.hiredintech.com/system-design/" target="_blank" rel="external">HiredInTech：系统设计</a></li>
<li>[ ] <a href="https://www.quora.com/How-do-I-prepare-to-answer-design-questions-in-a-technical-interview?redirected_qid=1500023" target="_blank" rel="external">该如何为技术面试里设计方面的问题做准备?</a></li>
<li>[ ] <a href="http://blog.gainlo.co/index.php/2015/10/22/8-things-you-need-to-know-before-system-design-interviews/" target="_blank" rel="external">在系统设计面试前必须知道的 8 件事</a></li>
<li>[ ] <a href="http://www.hiredintech.com/algorithm-design/" target="_blank" rel="external">算法设计</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=UrYLYV7WSHM" target="_blank" rel="external">数据库范式 - 1NF, 2NF, 3NF and 4NF (video)</a></li>
<li>[ ] <a href="https://github.com/checkcheckzz/system-design-interview" target="_blank" rel="external">系统设计面试</a> - 这一部分有很多的资源，浏览一下我放在下面的文章和例子。</li>
<li>[ ] <a href="http://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/" target="_blank" rel="external">如何在系统设计面试中脱颖而出</a></li>
<li>[ ] <a href="http://everythingisdata.wordpress.com/2009/10/17/numbers-everyone-should-know/" target="_blank" rel="external">每个人都该知道的一些数字</a></li>
<li>[ ] <a href="http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html" target="_blank" rel="external">上下文切换操作会耗费多少时间?</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=srOgpXECblk" target="_blank" rel="external">跨数据中心的事务 (video)</a></li>
<li>[ ] <a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="external">简明 CAP 理论介绍</a></li>
<li>[ ] Paxos 一致性算法:<ul>
<li><a href="https://www.youtube.com/watch?v=s8JqcZtvnsM" target="_blank" rel="external">时间很短</a></li>
<li><a href="https://www.youtube.com/watch?v=JEpsBg0AO6o" target="_blank" rel="external">用例 和 multi-paxos</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="external">论文</a></li>
</ul>
</li>
<li>[ ] <a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html" target="_blank" rel="external">一致性哈希</a></li>
<li>[ ] <a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html" target="_blank" rel="external">NoSQL 模式</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=OkC7HKtiZC0&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc" target="_blank" rel="external">OOSE: UML 2.0 系列 (video)</a></li>
<li>[ ] OOSE: 使用 UML 和 Java 开发软件 (21 videos):<ul>
<li>如果你对 OO 都深刻的理解和实践，可以跳过这部分。</li>
<li><a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="external">OOSE: 使用 UML 和 Java 开发软件</a></li>
</ul>
</li>
<li>[ ] 面向对象编程的 SOLID 原则:<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=TMuno5RZNeE" target="_blank" rel="external">Bob Martin 面向对象的 SOLID 原则和敏捷设计 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PL8m4NUhTQU48oiGCSgCP1FiJEcg_xJzyQ" target="_blank" rel="external">C# SOLID 设计模式 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PL4CE9F710017EA77A" target="_blank" rel="external">SOLID 原则 (video)</a></li>
<li>[ ] S - <a href="http://www.oodesign.com/single-responsibility-principle.html" target="_blank" rel="external">单一职责原则</a> | <a href="http://www.javacodegeeks.com/2011/11/solid-single-responsibility-principle.html" target="_blank" rel="external">每个对象的单一职责</a><ul>
<li><a href="https://docs.google.com/open?id=0ByOwmqah_nuGNHEtcU5OekdDMkk" target="_blank" rel="external">更多</a></li>
</ul>
</li>
<li>[ ] O - <a href="http://www.oodesign.com/open-close-principle.html" target="_blank" rel="external">开闭原则</a>  | <a href="https://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="external">生产环境里的对象应该为扩展做准备而不是为更改</a><ul>
<li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1&amp;hl=en" target="_blank" rel="external">更多</a></li>
</ul>
</li>
<li>[ ] L - <a href="http://www.oodesign.com/liskov-s-substitution-principle.html" target="_blank" rel="external">里氏代换原则</a> | <a href="http://stackoverflow.com/questions/56860/what-is-the-liskov-substitution-principle" target="_blank" rel="external">基类和继承类遵循 ‘IS A’ 原则</a><ul>
<li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh&amp;hl=en" target="_blank" rel="external">更多</a></li>
</ul>
</li>
<li>[ ] I - <a href="http://www.oodesign.com/interface-segregation-principle.html" target="_blank" rel="external">接口隔离原则</a> | 客户端被迫实现用不到的接口<ul>
<li><a href="https://www.youtube.com/watch?v=3CtAfl7aXAQ" target="_blank" rel="external">5 分钟讲解接口隔离原则 (video)</a></li>
<li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi&amp;hl=en" target="_blank" rel="external">更多</a></li>
</ul>
</li>
<li>[ ] D -<a href="http://www.oodesign.com/dependency-inversion-principle.html" target="_blank" rel="external">依赖反转原则</a> | 减少对象里的依赖。<ul>
<li><a href="http://stackoverflow.com/questions/62539/what-is-the-dependency-inversion-principle-and-why-is-it-important" target="_blank" rel="external">什么是依赖倒置以及它为什么重要</a></li>
<li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz&amp;hl=en" target="_blank" rel="external">更多</a></li>
</ul>
</li>
</ul>
</li>
<li>[ ] 可伸缩性:<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=-W9F__D3oY4" target="_blank" rel="external">很棒的概述 (video)</a></li>
<li>[ ] 简短系列:<ul>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="external">克隆</a></li>
<li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="external">数据库</a></li>
<li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="external">缓存</a></li>
<li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism" target="_blank" rel="external">异步</a></li>
</ul>
</li>
<li>[ ] <a href="http://www.aosabook.org/en/distsys.html" target="_blank" rel="external">可伸缩的 Web 架构和分布式系统</a></li>
<li>[ ] <a href="https://pages.cs.wisc.edu/~zuyu/files/fallacies.pdf" target="_blank" rel="external">错误的分布式系统解释</a></li>
<li>[ ] <a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="external">实用编程技术</a><ul>
<li><a href="http://horicky.blogspot.com/2010/07/google-pregel-graph-processing.html" target="_blank" rel="external">extra: Google Pregel 图形处理</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=modXC5IWTJI" target="_blank" rel="external">Jeff Dean - 在 Goolge 构建软件系统 (video)</a></li>
<li>[ ] <a href="http://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="external">可伸缩系统架构设计介绍</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=9nWyWwY2Onc" target="_blank" rel="external">使用 App Engine 和云存储扩展面向全球用户的手机游戏架构实践(video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=H4vMcD7zKM0" target="_blank" rel="external">How Google Does Planet-Scale Engineering for Planet-Scale Infra (video)</a></li>
<li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/the-importance-of-algorithms/" target="_blank" rel="external">算法的重要性</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html" target="_blank" rel="external">分片</a></li>
<li>[ ] <a href="https://www.infoq.com/presentations/Scale-at-Facebook" target="_blank" rel="external">Facebook 系统规模扩展实践 (2009)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=oodS71YtkGU" target="_blank" rel="external">Facebook 系统规模扩展实践 (2012), “为 10 亿用户构建” (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=p0jGmgIrf_M&amp;list=PLRXxvay_m8gqVlExPC5DG3TGWJTaBgqSA&amp;index=4" target="_blank" rel="external">Long Game 工程实践 - Astrid Atkinson Keynote(video)</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html" target="_blank" rel="external">30 分钟看完 YouTuBe 7 年系统扩展经验</a><ul>
<li><a href="https://www.youtube.com/watch?v=G-lGCC4KKok" target="_blank" rel="external">video</a></li>
</ul>
</li>
<li>[ ] <a href="http://highscalability.com/blog/2016/8/15/how-paypal-scaled-to-billions-of-transactions-daily-using-ju.html" target="_blank" rel="external">PayPal 如何用 8 台虚拟机扛住 10 亿日交易量系统</a></li>
<li>[ ] <a href="https://blog.clevertap.com/how-to-remove-duplicates-in-large-datasets/" target="_blank" rel="external">如何对大数据集去重</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=3vV4YiqKm1o" target="_blank" rel="external">Etsy 的扩展和工程文化探究 Jon Cowie (video)</a></li>
<li>[ ] <a href="http://thenewstack.io/led-amazon-microservices-architecture/" target="_blank" rel="external">是什么造就了 Amazon 自己的微服务架构</a></li>
<li>[ ] <a href="https://eng.uber.com/trip-data-squeeze/" target="_blank" rel="external">压缩还是不压缩，是 Uber 面临的问题</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/3/3/asyncio-tarantool-queue-get-in-the-queue.html" target="_blank" rel="external">异步 I/O Tarantool 队列</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/2/25/when-should-approximate-query-processing-be-used.html" target="_blank" rel="external">什么时候应该用近视查询处理?</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/2/23/googles-transition-from-single-datacenter-to-failover-to-a-n.html" target="_blank" rel="external">Google 从单数据中心到故障转移, 到本地多宿主架构的演变</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2012/9/24/google-spanners-most-surprising-revelation-nosql-is-out-and.html" target="_blank" rel="external">Spanner</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/2/15/egnyte-architecture-lessons-learned-in-building-and-scaling.html" target="_blank" rel="external">Egnyte: 构建和扩展 PB 级分布式系统架构的经验教训</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/7/6/machine-learning-driven-programming-a-new-programming-for-a.html" target="_blank" rel="external">机器学习驱动的编程: 新世界的新编程方式</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/6/15/the-image-optimization-technology-that-serves-millions-of-re.html" target="_blank" rel="external">日服务数百万请求的图像优化技术</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/2/1/a-patreon-architecture-short.html" target="_blank" rel="external">Patreon 架构</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/1/27/tinder-how-does-one-of-the-largest-recommendation-engines-de.html" target="_blank" rel="external">Tinder: 推荐引擎是如何决定下一个你将会看到谁的?</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html" target="_blank" rel="external">现代缓存设计</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/1/13/live-video-streaming-at-facebook-scale.html" target="_blank" rel="external">Facebook 实时视频流扩展</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html" target="_blank" rel="external">在 Amazon AWS 上把服务扩展到 1100 万量级的新手教程</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2015/12/16/how-does-the-use-of-docker-effect-latency.html" target="_blank" rel="external">对延时敏感的应用是否应该使用 Docker?</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2015/12/14/does-amp-counter-an-existential-threat-to-google.html" target="_blank" rel="external">AMP（Accelerated Mobile Pages）的存在是对 Google 的威胁么?</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html" target="_blank" rel="external">360 度解读 Netflix 技术栈</a></li>
<li>[ ] <a href="http://highscalability.com/latency-everywhere-and-it-costs-you-sales-how-crush-it" target="_blank" rel="external">延迟无处不在 - 如何搞定它？</a></li>
<li>[ ] <a href="http://martinfowler.com/articles/serverless.html" target="_blank" rel="external">无服务器架构</a></li>
<li>[ ] <a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances" target="_blank" rel="external">是什么驱动着 Instagram: 上百个实例、几十种技术</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html" target="_blank" rel="external">Cinchcast 架构 - 每天处理 1500 小时的音频</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html" target="_blank" rel="external">Justin.Tv 实时视频播放架构</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html" target="_blank" rel="external">Playfish’s 社交游戏架构 - 每月五千万用户增长</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html" target="_blank" rel="external">猫途鹰架构 - 40 万访客, 200 万动态页面访问, 30TB 数据</a></li>
<li>[ ] <a href="http://highscalability.com/plentyoffish-architecture" target="_blank" rel="external">PlentyOfFish 架构</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html" target="_blank" rel="external">Salesforce 架构 - 如何扛住 13 亿日交易量</a></li>
<li>[ ] <a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html" target="_blank" rel="external">ESPN’s 架构扩展</a></li>
<li>[ ] 下面 『消息、序列化和消息系统』部分的内容会提到什么样的技术能把各种服务整合到一起</li>
<li>[ ] Twitter:<ul>
<li><a href="https://www.youtube.com/watch?v=5cKTP36HVgI" target="_blank" rel="external">O’Reilly MySQL CE 2011: Jeremy Cole, “Big and Small Data at @Twitter” (video)</a></li>
<li><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability" target="_blank" rel="external">时间线的扩展</a></li>
</ul>
</li>
<li>更多内容可以查看视频部分的『大规模数据挖掘』视频系列。</li>
</ul>
</li>
<li>[ ] 系统设计问题练习：下面有一些指导原则，每一个都有相关文档以及在现实中该如何处理。<ul>
<li>复习: <a href="http://www.hiredintech.com/system-design/" target="_blank" rel="external">HiredInTech 的系统设计</a></li>
<li><a href="https://github.com/jwasham/google-interview-university/blob/master/extras/cheat%20sheets/system-design.pdf" target="_blank" rel="external">cheat sheet</a></li>
<li>流程:<ol>
<li>理解问题和范围:<ul>
<li>在面试官的帮助下定义用例</li>
<li>提出附加功能的建议</li>
<li>去掉面试官认定范围以外的内容</li>
<li>假定高可用是必须的，而且要作为一个用例</li>
</ul>
</li>
<li>考虑约束:<ul>
<li>问一下每月请求量</li>
<li>问一下每秒请求量 (他们可能会主动提到或者让你算一下)</li>
<li>评估读写所占的百分比</li>
<li>评估的时候牢记 2/8 原则</li>
<li>每秒写多少数据</li>
<li>总的数据存储量要考虑超过 5 年的情况</li>
<li>每秒读多少数据</li>
</ul>
</li>
<li>抽象设计:<ul>
<li>分层 (服务, 数据, 缓存)</li>
<li>基础设施: 负载均衡, 消息</li>
<li>粗略的概括任何驱动整个服务的关键算法</li>
<li>考虑瓶颈并指出解决方案</li>
</ul>
</li>
</ol>
</li>
<li>练习:<ul>
<li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci" target="_blank" rel="external">设计一个 CDN 网络</a></li>
<li><a href="https://blog.twitter.com/2010/announcing-snowflake" target="_blank" rel="external">设计一个随机唯一 ID 生成系统</a></li>
<li><a href="http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html" target="_blank" rel="external">设计一个在线多人卡牌游戏</a></li>
<li><a href="http://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="external">设计一个 key-value 数据库</a></li>
<li><a href="https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf" target="_blank" rel="external">设计一个函数获取过去某个时间段内前 K 个最高频访问的请求</a></li>
<li><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html" target="_blank" rel="external">设计一个图片分享系统</a></li>
<li><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf" target="_blank" rel="external">设计一个推荐系统</a></li>
<li><a href="http://www.hiredintech.com/system-design/the-system-design-process/" target="_blank" rel="external">设计一个短域名生成系统</a></li>
<li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="external">设计一个缓存系统</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u8BBA_u6587"><a href="#u8BBA_u6587" class="headerlink" title="论文"></a>论文</h3><ul>
<li>有 Google 的论文和一些知名的论文.</li>
<li>你很可能实在没时间一篇篇完整的读完他们。我建议可以有选择的读其中一些论文里的核心部分。</li>
<li>[ ] <a href="http://spinroot.com/courses/summer/Papers/hoare_1978.pdf" target="_blank" rel="external">1978: 通信顺序处理</a><ul>
<li><a href="https://godoc.org/github.com/thomas11/csp" target="_blank" rel="external">Go 实现</a></li>
<li><a href="https://www.cs.cmu.edu/~crary/819-f09/" target="_blank" rel="external">喜欢经典的论文?</a></li>
</ul>
</li>
<li>[ ] <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf" target="_blank" rel="external">2003: The Google 文件系统</a><ul>
<li>2012 年被 Colossus 取代了</li>
</ul>
</li>
<li>[ ] <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">2004: MapReduce: Simplified Data Processing on Large Clusters</a><ul>
<li>大多被云数据流取代了?</li>
</ul>
</li>
<li>[ ] <a href="https://www.akkadia.org/drepper/cpumemory.pdf" target="_blank" rel="external">2007: 每个程序员都应该知道的内存知识 (非常长，作者建议跳过某些章节来阅读)</a></li>
<li>[ ] <a href="https://www.wired.com/2012/07/google-colossus/" target="_blank" rel="external">2012: Google 的 Colossus</a><ul>
<li>没有论文</li>
</ul>
</li>
<li>[ ] 2012: AddressSanitizer: 快速的内存访问检查器:<ul>
<li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37752.pdf" target="_blank" rel="external">论文</a></li>
<li><a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany" target="_blank" rel="external">视频</a></li>
</ul>
</li>
<li>[ ] 2013: Spanner: Google 的分布式数据库:<ul>
<li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf" target="_blank" rel="external">论文</a></li>
<li><a href="https://www.usenix.org/node/170855" target="_blank" rel="external">视频</a></li>
</ul>
</li>
<li>[ ] <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf" target="_blank" rel="external">2014: Machine Learning: The High-Interest Credit Card of Technical Debt</a></li>
<li>[ ] <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43790.pdf" target="_blank" rel="external">2015: Continuous Pipelines at Google</a></li>
<li>[ ] <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44686.pdf" target="_blank" rel="external">2015: 大规模高可用: 构建 Google Ads 的数据基础设施</a></li>
<li>[ ] <a href="http://download.tensorflow.org/paper/whitepaper2015.pdf" target="_blank" rel="external">2015: TensorFlow: 异构分布式系统上的大规模机器学习</a></li>
<li>[ ] <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43835.pdf" target="_blank" rel="external">2015: 开发者应该如何搜索代码：用例学习</a></li>
<li>[ ] <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf" target="_blank" rel="external">2016: Borg, Omega, and Kubernetes</a></li>
</ul>
</li>
<li><h3 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h3><ul>
<li>涵盖了:<ul>
<li>单元测试是如何工作的</li>
<li>什么是模拟对象</li>
<li>什么是集成测试</li>
<li>什么是依赖注入</li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=SAhJf36_u5U" target="_blank" rel="external">James Bach 讲敏捷软件测试 (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ILkT_HV9DVU" target="_blank" rel="external">James Bach 软件测试公开课 (video)</a></li>
<li>[ ] <a href="https://vimeo.com/83960706" target="_blank" rel="external">Steve Freeman - 测试驱动的开发 (video)</a><ul>
<li><a href="http://gotocon.com/dl/goto-berlin-2013/slides/SteveFreeman_TestDrivenDevelopmentThatsNotWhatWeMeant.pdf" target="_blank" rel="external">slides</a></li>
</ul>
</li>
<li>[ ] <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html" target="_blank" rel="external">测试驱动的开发已死。测试不朽。</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=z9quxZsLcfo" target="_blank" rel="external">测试驱动的开发已死? (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=nzJapzxH_rE&amp;list=PLAwxTw4SYaPkWVHeC_8aSIbSxE_NXI76g" target="_blank" rel="external">视频系列 (152 个) - 并不都是必须 (video)</a></li>
<li>[ ] <a href="http://www.obeythetestinggoat.com/pages/book.html#toc" target="_blank" rel="external">Python：测试驱动的 Web 开发</a></li>
<li>[ ] 依赖注入:<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=IKD2-MAkXyQ" target="_blank" rel="external">视频</a></li>
<li>[ ] <a href="http://jasonpolites.github.io/tao-of-testing/ch3-1.1.html" target="_blank" rel="external">测试之道</a></li>
</ul>
</li>
<li>[ ] <a href="http://jasonpolites.github.io/tao-of-testing/ch4-1.1.html" target="_blank" rel="external">如何编写测试</a></li>
</ul>
</li>
<li><h3 id="u8C03_u5EA6"><a href="#u8C03_u5EA6" class="headerlink" title="调度"></a>调度</h3><ul>
<li>在操作系统中是如何运作的</li>
<li>在操作系统部分的视频里有很多资料</li>
</ul>
</li>
<li><h3 id="u5B9E_u73B0_u7CFB_u7EDF_u4F8B_u7A0B"><a href="#u5B9E_u73B0_u7CFB_u7EDF_u4F8B_u7A0B" class="headerlink" title="实现系统例程"></a>实现系统例程</h3><ul>
<li>理解你使用的系统 API 底层有什么</li>
<li>你能自己实现它们么?</li>
</ul>
</li>
<li><h3 id="u5B57_u7B26_u4E32_u641C_u7D22_u548C_u64CD_u4F5C"><a href="#u5B57_u7B26_u4E32_u641C_u7D22_u548C_u64CD_u4F5C" class="headerlink" title="字符串搜索和操作"></a>字符串搜索和操作</h3><ul>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/tAfHI/search-pattern-in-text" target="_blank" rel="external">文本的搜索模式 (video)</a></li>
<li>[ ] Rabin-Karp (videos):<ul>
<li><a href="https://www.coursera.org/learn/data-structures/lecture/c0Qkw/rabin-karps-algorithm" target="_blank" rel="external">Rabin Karps 算法</a></li>
<li><a href="https://www.coursera.org/learn/data-structures/lecture/nYrc8/optimization-precomputation" target="_blank" rel="external">预先计算的优化</a></li>
<li><a href="https://www.coursera.org/learn/data-structures/lecture/h4ZLc/optimization-implementation-and-analysis" target="_blank" rel="external">优化: 实现和分析</a></li>
<li><a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=9" target="_blank" rel="external">Table Doubling, Karp-Rabin</a></li>
<li><a href="https://www.youtube.com/watch?v=w6nuXg0BISo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=32" target="_blank" rel="external">滚动哈希</a></li>
</ul>
</li>
<li>[ ] Knuth-Morris-Pratt (KMP) 算法:<ul>
<li><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">Pratt 算法</a></li>
<li><a href="https://www.youtube.com/watch?v=2ogqPWJSftE" target="_blank" rel="external">教程: Knuth-Morris-Pratt (KMP) 字符串匹配算法</a></li>
</ul>
</li>
<li>[ ] Boyer–Moore 字符串搜索算法<ul>
<li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="external">Boyer-Moore字符串搜索算法</a></li>
<li><a href="https://www.youtube.com/watch?v=QDZpzctPf10" target="_blank" rel="external">Boyer-Moore-Horspool 高级字符串搜索算法 (video)</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.coursera.org/learn/algorithms-on-strings/home/week/1" target="_blank" rel="external">Coursera: 字符串的算法</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="u7EC8_u9762"><a href="#u7EC8_u9762" class="headerlink" title="终面"></a>终面</h2><pre><code>这一部分有一些短视频，你可以快速的观看和复习大多数重要概念。
这对经常性的巩固很有帮助。
</code></pre><h4 id="u7EFC_u8FF0_3A"><a href="#u7EFC_u8FF0_3A" class="headerlink" title="综述:"></a>综述:</h4><ul>
<li>[ ] 2-3 分钟的短视频系列 (23 个)<ul>
<li><a href="https://www.youtube.com/watch?v=r4r1DZcx1cM&amp;list=PLmVb1OknmNJuC5POdcDv5oCS7_OUkDgpj&amp;index=22" target="_blank" rel="external">Videos</a></li>
</ul>
</li>
<li>[ ] 2-5 分钟的短视频系列 - Michael Sambol (18 个):<ul>
<li><a href="https://www.youtube.com/channel/UCzDJwLWoYCUQowF_nG3m5OQ" target="_blank" rel="external">Videos</a></li>
</ul>
</li>
</ul>
<h4 id="u6392_u5E8F_3A"><a href="#u6392_u5E8F_3A" class="headerlink" title="排序:"></a>排序:</h4><ul>
<li>[ ] 归并排序: <a href="https://www.youtube.com/watch?v=GCae1WNvnZM" target="_blank" rel="external">https://www.youtube.com/watch?v=GCae1WNvnZM</a></li>
</ul>
<h2 id="u4E66_u7C4D"><a href="#u4E66_u7C4D" class="headerlink" title="书籍"></a>书籍</h2><h3 id="Google_Coaching__u91CC_u63D0_u5230_u7684"><a href="#Google_Coaching__u91CC_u63D0_u5230_u7684" class="headerlink" title="Google Coaching 里提到的"></a>Google Coaching 里提到的</h3><p><strong>阅读并做练习:</strong></p>
<ul>
<li><p>[ ] 算法设计手册 (Skiena)</p>
<ul>
<li>书 (Kindle 上可以租到):<ul>
<li><a href="http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202" target="_blank" rel="external">Algorithm Design Manual</a></li>
</ul>
</li>
<li>Half.com 是一个资源丰富且性价比很高的在线书店.</li>
<li>答案:<ul>
<li><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/The_Algorithms_Design_Manual_(Second_Edition" target="_blank" rel="external">解答</a>)</li>
<li><a href="http://blog.panictank.net/category/algorithmndesignmanualsolutions/page/2/" target="_blank" rel="external">解答</a></li>
</ul>
</li>
<li><p><a href="http://www3.cs.stonybrook.edu/~skiena/algorist/book/errata" target="_blank" rel="external">勘误表</a></p>
<p>read and do exercises from the books below. Then move to coding challenges (further down below)<br>一旦你理解了每日计划里的所有内容，就去读上面所列的书并完成练习，然后开始读下面所列的书并做练习，之后就可以开始实战写代码了（本文再往后的部分）</p>
</li>
</ul>
</li>
</ul>
<p><strong>首先阅读:</strong></p>
<ul>
<li>[ ] <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html" target="_blank" rel="external">Programming Interviews Exposed: Secrets to Landing Your Next Job, 2nd Edition</a></li>
</ul>
<p><strong>然后阅读 (这本获得了很多推荐， 但是不在 Google coaching 的文档里):</strong></p>
<ul>
<li>[ ] <a href="http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/" target="_blank" rel="external">Cracking the Coding Interview, 6th Edition</a><ul>
<li>如果你看到有人在看 “The Google Resume”, 实际上它和 “Cracking the Coding Interview” 是同一个作者写的，而且后者是升级版。</li>
</ul>
</li>
</ul>
<h3 id="u9644_u52A0_u4E66_u5355"><a href="#u9644_u52A0_u4E66_u5355" class="headerlink" title="附加书单"></a>附加书单</h3><p>这些没有被 Google 推荐阅读，不过我因为需要这些背景知识所以也把它们列在了这里。</p>
<ul>
<li><p>[ ] C Programming Language, Vol 2</p>
<ul>
<li><a href="https://github.com/lekkas/c-algorithms" target="_blank" rel="external">练习的答案</a></li>
</ul>
</li>
<li><p>[ ] C++ Primer Plus, 6th Edition</p>
</li>
<li><p>[ ] <a href="http://product.half.ebay.com/The-UNIX-Programming-Environment-by-Brian-W-Kernighan-and-Rob-Pike-1983-Other/54385&amp;tg=info" target="_blank" rel="external">《Unxi 环境高级编程》 The Unix Programming Environment</a></p>
</li>
<li><p>[ ] <a href="http://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880" target="_blank" rel="external">《编程珠玑》 Programming Pearls</a></p>
</li>
<li><p>[ ] <a href="http://www.amazon.com/Algorithms-Programming-Solutions-Alexander-Shen/dp/0817638474" target="_blank" rel="external">Algorithms and Programming: Problems and Solutions</a></p>
</li>
</ul>
<h3 id="u5982_u679C_u4F60_u6709_u65F6_u95F4"><a href="#u5982_u679C_u4F60_u6709_u65F6_u95F4" class="headerlink" title="如果你有时间"></a>如果你有时间</h3><ul>
<li><p>[ ] <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844" target="_blank" rel="external">Introduction to Algorithms</a></p>
</li>
<li><p>[ ] <a href="https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836" target="_blank" rel="external">Elements of Programming Interviews</a></p>
<ul>
<li>如果你希望在面试里用 C++ 写代码，这本书的代码全都是 C++ 写的</li>
<li>通常情况下能找到解决方案的好书.</li>
</ul>
</li>
</ul>
<h2 id="u7F16_u7801_u7EC3_u4E60_u548C_u6311_u6218"><a href="#u7F16_u7801_u7EC3_u4E60_u548C_u6311_u6218" class="headerlink" title="编码练习和挑战"></a>编码练习和挑战</h2><p>一旦你学会了理论基础，就应该把它们拿出来练练。<br>尽量坚持每天做编码练习，越多越好。</p>
<p>编程问题预备:</p>
<ul>
<li>[ ] <a href="http://www.hiredintech.com/algorithm-design/" target="_blank" rel="external">不错的介绍 (摘自 System Design 章节): 算法设计:</a></li>
<li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-find-a-solution/" target="_blank" rel="external">如何找到解决方案</a></li>
<li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-dissect-a-topcoder-problem-statement/" target="_blank" rel="external">如何剖析 Topcoder 题目描述</a></li>
<li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/mathematics-for-topcoders/" target="_blank" rel="external">Topcoders 里用到的数学</a></li>
<li><p>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/" target="_blank" rel="external">动态规划 – 从入门到精通</a></p>
</li>
<li><p><a href="https://courses.csail.mit.edu/iap/interview/materials.php" target="_blank" rel="external">MIT 面试材料</a></p>
</li>
<li><p><a href="http://exercism.io/languages" target="_blank" rel="external">针对编程语言本身的练习</a></p>
</li>
</ul>
<p>编码练习平台:</p>
<ul>
<li><a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a></li>
<li><a href="https://www.topcoder.com/" target="_blank" rel="external">TopCoder</a></li>
<li><a href="https://projecteuler.net/index.php?section=problems" target="_blank" rel="external">Project Euler (数学方向为主)</a></li>
<li><a href="http://www.codewars.com" target="_blank" rel="external">Codewars</a></li>
<li><a href="https://www.hackerrank.com/" target="_blank" rel="external">HackerRank</a></li>
<li><a href="https://codility.com/programmers/" target="_blank" rel="external">Codility</a></li>
<li><a href="https://www.interviewcake.com/" target="_blank" rel="external">InterviewCake</a></li>
<li><p><a href="https://www.interviewbit.com/invite/icjf" target="_blank" rel="external">InterviewBit</a></p>
</li>
<li><p><a href="http://www.gainlo.co/" target="_blank" rel="external">模拟大公司的面试</a></p>
</li>
</ul>
<h2 id="u5F53_u4F60_u4E34_u8FD1_u9762_u8BD5_u65F6"><a href="#u5F53_u4F60_u4E34_u8FD1_u9762_u8BD5_u65F6" class="headerlink" title="当你临近面试时"></a>当你临近面试时</h2><ul>
<li>[ ] 搞定代码面试 (videos):<ul>
<li><a href="https://www.youtube.com/watch?v=4NIb9l3imAo" target="_blank" rel="external">Cracking The Code Interview</a></li>
<li><a href="https://www.youtube.com/watch?v=Eg5-tdAwclo" target="_blank" rel="external">Cracking the Coding Interview - 全栈系列</a></li>
<li><a href="https://www.youtube.com/watch?v=1fqxMuPmGak" target="_blank" rel="external">Ask Me Anything: Gayle Laakmann McDowell (Cracking the Coding Interview 的作者)</a></li>
</ul>
</li>
</ul>
<h2 id="u4F60_u7684_u7B80_u5386"><a href="#u4F60_u7684_u7B80_u5386" class="headerlink" title="你的简历"></a>你的简历</h2><ul>
<li><a href="http://steve-yegge.blogspot.co.uk/2007_09_01_archive.html" target="_blank" rel="external">10 条小贴士让你写出一份还算不错的简历</a></li>
<li>这是搞定面试的第一个关键步骤</li>
</ul>
<h2 id="u5F53_u9762_u8BD5_u6765_u4E34_u7684_u65F6_u5019"><a href="#u5F53_u9762_u8BD5_u6765_u4E34_u7684_u65F6_u5019" class="headerlink" title="当面试来临的时候"></a>当面试来临的时候</h2><pre><code>随着下面列举的问题思考下你可能会遇到的 20 个面试问题
每个问题准备 2-3 种回答
准备点故事，不要只是摆一些你完成的事情的数据，相信我，人人都喜欢听故事
</code></pre><ul>
<li>你为什么想得到这份工作？</li>
<li>你解决过的最有难度的问题是什么？</li>
<li>面对过的最大挑战是什么?</li>
<li>见过的最好或者最坏的设计是怎么样的?</li>
<li>对某项 Google 产品提出改进建议。</li>
<li>你作为一个个体同时也是团队的一员，如何达到最好的工作状态?</li>
<li>你的什么技能或者经验是你的角色中不可或缺的?为什么？</li>
<li>你在某份工作或某个项目中最享受的是什么?</li>
<li>你在某份工作或某个项目中面临过的最大挑战是什么?</li>
<li>你在某份工作或某个项目中遇到过的最蛋疼的 Bug 是什么样的？</li>
<li>你在某份工作或某个项目中学到了什么？</li>
<li>你在某份工作或某个项目中哪些地方还可以做的更好？</li>
</ul>
<h2 id="u95EE_u9762_u8BD5_u5B98_u7684_u95EE_u9898"><a href="#u95EE_u9762_u8BD5_u5B98_u7684_u95EE_u9898" class="headerlink" title="问面试官的问题"></a>问面试官的问题</h2><pre><code>我会问的一些：(可能我已经知道了答案但我想听听面试官的看法或者了解团队的前景):
</code></pre><ul>
<li>团队多大规模?</li>
<li>开发周期是怎样的? 会使用瀑布流/极限编程/敏捷开发么?</li>
<li>经常会为 deadline 加班么? 或者是有弹性的?</li>
<li>团队里怎么做技术选型?</li>
<li>每周平均开多少次会?</li>
<li>你觉得工作环境有助于员工集中精力吗?</li>
<li>目前正在做什么工作?</li>
<li>喜欢这些事情吗?</li>
<li>工作期限是怎么样的?</li>
</ul>
<h2 id="u5F53_u4F60_u83B7_u5F97_u4E86_u68A6_u60F3_u7684_u804C_u4F4D"><a href="#u5F53_u4F60_u83B7_u5F97_u4E86_u68A6_u60F3_u7684_u804C_u4F4D" class="headerlink" title="当你获得了梦想的职位"></a>当你获得了梦想的职位</h2><p>我还能说些什么呢，恭喜你！</p>
<ul>
<li><a href="https://medium.com/@moonstorming/10-things-i-wish-i-knew-on-my-first-day-at-google-107581d87286#.livxn7clw" target="_blank" rel="external">我希望在 Google 的第一天就知道的 10 件事</a></li>
</ul>
<p>坚持继续学习。</p>
<p>得到这份工作只是一个开始。</p>
<hr>
<pre><code>*****************************************************************************************************
*****************************************************************************************************

下面的内容都是可选的。这些是我的推荐，不是 Google 的。
通过学习这些内容，你将会得到更多的有关 CS 的概念，并将为所有的软件工程工作做更好的准备。

*****************************************************************************************************
*****************************************************************************************************
</code></pre><hr>
<h2 id="u9644_u52A0_u7684_u5B66_u4E60"><a href="#u9644_u52A0_u7684_u5B66_u4E60" class="headerlink" title="附加的学习"></a>附加的学习</h2><ul>
<li><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><ul>
<li>[ ] <a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="external">每一个软件开发者的绝对最低限度，必须要知道的关于 Unicode 和字符集知识</a></li>
<li>[ ] <a href="http://kunststube.net/encoding/" target="_blank" rel="external">关于处理文本需要的编码和字符集, 每个程序员绝对需要知道的知识</a></li>
</ul>
</li>
<li><h3 id="u5B57_u8282_u987A_u5E8F"><a href="#u5B57_u8282_u987A_u5E8F" class="headerlink" title="字节顺序"></a>字节顺序</h3><ul>
<li>[ ] <a href="https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html" target="_blank" rel="external">大、小端字节序</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=JrNF0KRAlyo" target="_blank" rel="external">大端字节 Vs 小端字节(视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=oBSuXP-1Tc0" target="_blank" rel="external">大、小端字节序的里里外外(Big And Little Endian Inside/Out) (视频)</a><ul>
<li>内核开发者的讨论非常技术性，如果大多数都超出了你的理解范围，不要太担心。</li>
<li>前半段已经足够了。</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Emacs_and_vi_28m_29"><a href="#Emacs_and_vi_28m_29" class="headerlink" title="Emacs and vi(m)"></a>Emacs and vi(m)</h3><ul>
<li>Yegge 的建议，从一个很早以前的亚马逊招聘信息中而来：熟悉基于 unix 的代码编辑器</li>
<li>vi(m):<ul>
<li><a href="https://www.youtube.com/watch?v=5givLEMcINQ&amp;index=1&amp;list=PL13bz4SHGmRxlZVmWQ9DvXo1fEg4UdGkr" target="_blank" rel="external">使用 vim 进行编辑 01 - 安装, 设置和模式 (视频)</a></li>
<li><a href="http://vim-adventures.com/" target="_blank" rel="external">VIM 的冒险之旅</a></li>
<li>4 个视频集:<ul>
<li><a href="https://www.youtube.com/watch?v=SI8TeVMX8pk" target="_blank" rel="external">vi/vim 编辑器 - 课程 1</a></li>
<li><a href="https://www.youtube.com/watch?v=F3OO7ZIOaJE" target="_blank" rel="external">vi/vim 编辑器 - 课程 2</a></li>
<li><a href="https://www.youtube.com/watch?v=1lYD5gwgZIA" target="_blank" rel="external">vi/vim 编辑器 - 课程 4</a></li>
<li><a href="https://www.youtube.com/watch?v=ZYEccA_nMaI" target="_blank" rel="external">vi/vim 编辑器 - 课程 3</a></li>
</ul>
</li>
<li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Using_Vi_instead_of_Emacs" target="_blank" rel="external">使用 Vi 而不是 Emacs</a></li>
</ul>
</li>
<li>emacs:<ul>
<li><a href="https://www.youtube.com/watch?v=hbmV1bnQ-i0" target="_blank" rel="external">基础 Emacs 教程 (视频)</a></li>
<li>3 个视频集:<ul>
<li><a href="https://www.youtube.com/watch?v=ujODL7MD04Q" target="_blank" rel="external">Emacs 教程 (初学者) -第 1 部分- 文件命令, 剪切/复制/粘贴,  自定义命令</a></li>
<li><a href="https://www.youtube.com/watch?v=XWpsRupJ4II" target="_blank" rel="external">Emacs 教程 (初学者 -第 2 部分- Buffer 管理, 搜索, M-x grep 和 rgrep 模式</a></li>
<li><a href="https://www.youtube.com/watch?v=paSgzPso-yc" target="_blank" rel="external">Emacs 教程 (初学者 -第 3 部分- 表达式, 声明, ~/.emacs 文件和包机制</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=JWD1Fpdd4Pc" target="_blank" rel="external">Evil 模式: 或许, 我是怎样对 Emacs 路人转粉的 (视频)</a></li>
<li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Writing_C_programs_with_Emacs" target="_blank" rel="external">使用 Emacs 开发 C 程序</a></li>
<li><a href="https://www.youtube.com/watch?v=nsGYet02bEk" target="_blank" rel="external">(或许) 深度组织模式:管理结构 (视频)</a></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Unix__u547D_u4EE4_u884C_u5DE5_u5177"><a href="#Unix__u547D_u4EE4_u884C_u5DE5_u5177" class="headerlink" title="Unix 命令行工具"></a>Unix 命令行工具</h3><ul>
<li>下列内容中的优秀工具由的 Yegge 推荐，Yegge 目前致力于 Amazon 人事招聘处。</li>
<li>[ ] bash</li>
<li>[ ] cat</li>
<li>[ ] grep</li>
<li>[ ] sed</li>
<li>[ ] awk</li>
<li>[ ] curl or wget</li>
<li>[ ] sort</li>
<li>[ ] tr</li>
<li>[ ] uniq</li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Strace" target="_blank" rel="external">strace</a></li>
<li>[ ] <a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="external">tcpdump</a></li>
</ul>
</li>
<li><h3 id="u4FE1_u606F_u8D44_u6E90__28_u89C6_u9891_29"><a href="#u4FE1_u606F_u8D44_u6E90__28_u89C6_u9891_29" class="headerlink" title="信息资源 (视频)"></a>信息资源 (视频)</h3><ul>
<li>[ ] <a href="https://www.khanacademy.org/computing/computer-science/informationtheory" target="_blank" rel="external">Khan Academy 可汗学院</a></li>
<li>[ ] 更多有关马尔可夫的内容:<ul>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/waxgx/core-markov-text-generation" target="_blank" rel="external">Core Markov Text Generation马尔可夫内容生成</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/gZhiC/core-implementing-markov-text-generation" target="_blank" rel="external">Core Implementing Markov Text Generation马尔可夫内容生成补充</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/EUjrq/project-markov-text-generation-walk-through" target="_blank" rel="external">Project = Markov Text Generation Walk Through一个马尔可夫内容生成器的项目</a></li>
</ul>
</li>
<li>关于更多信息，请参照下方 MIT 6.050J 信息和系统复杂度的内容.</li>
</ul>
</li>
<li><h3 id="u5947_u5076_u6821_u9A8C_u4F4D__26amp_3B__u6C49_u660E_u7801__28_u89C6_u9891_29"><a href="#u5947_u5076_u6821_u9A8C_u4F4D__26amp_3B__u6C49_u660E_u7801__28_u89C6_u9891_29" class="headerlink" title="奇偶校验位 &amp; 汉明码 (视频)"></a>奇偶校验位 &amp; 汉明码 (视频)</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=q-3BctoUpHE" target="_blank" rel="external">入门</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=DdMcAUlxh1M" target="_blank" rel="external">奇偶校验位</a></li>
<li>[ ] 汉明码(Hamming Code):<ul>
<li><a href="https://www.youtube.com/watch?v=1A_NcXxdoCc" target="_blank" rel="external">发现错误</a></li>
<li><a href="https://www.youtube.com/watch?v=JAMLuxdHH8o" target="_blank" rel="external">修正错误</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=wbH2VxzmoZk" target="_blank" rel="external">检查错误</a></li>
</ul>
</li>
<li><h3 id="u7CFB_u7EDF_u71B5_u503C_uFF08_u7CFB_u7EDF_u590D_u6742_u5EA6_uFF09"><a href="#u7CFB_u7EDF_u71B5_u503C_uFF08_u7CFB_u7EDF_u590D_u6742_u5EA6_uFF09" class="headerlink" title="系统熵值（系统复杂度）"></a>系统熵值（系统复杂度）</h3><ul>
<li>请参考下方视频</li>
<li>观看之前，请先确定观看了信息论的视频</li>
<li>[ ] <a href="https://youtu.be/JnJq3Py0dyM?t=176" target="_blank" rel="external">信息理论, 克劳德·香农, 熵值, 系统冗余, 数据比特压缩 (视频)</a></li>
</ul>
</li>
<li><h3 id="u5BC6_u7801_u5B66"><a href="#u5BC6_u7801_u5B66" class="headerlink" title="密码学"></a>密码学</h3><ul>
<li>请参考下方视频</li>
<li>观看之前，请先确定观看了信息论的视频</li>
<li>[ ] <a href="https://www.khanacademy.org/computing/computer-science/密码学" target="_blank" rel="external">可汗学院</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=KqqOXndnvic&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=30" target="_blank" rel="external">密码学: 哈希函数</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=9TNI2wHmaeI&amp;index=31&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="external">密码学: 加密</a></li>
</ul>
</li>
<li><h3 id="u538B_u7F29"><a href="#u538B_u7F29" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>观看之前，请先确定观看了信息论的视频</li>
<li>[ ] 压缩 (视频):<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=Lto-ajuqW3w" target="_blank" rel="external">压缩</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=M5c_RFKVkko" target="_blank" rel="external">压缩熵值</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=umTbivyJoiI" target="_blank" rel="external">由上而下的树 (霍夫曼编码树)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=DV8efuB3h2g" target="_blank" rel="external">额外比特 - 霍夫曼编码树</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=goOa3DGezUA" target="_blank" rel="external">优雅的压缩数据 (无损数据压缩方法)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=cCDCfoHTsaU" target="_blank" rel="external">Text Compression Meets Probabilities</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H" target="_blank" rel="external">数据压缩的艺术</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=whGwm0Lky2s" target="_blank" rel="external">(可选) 谷歌开发者: GZIP 还差远了呢!</a></li>
</ul>
</li>
<li><h3 id="u7F51_u7EDC__28_u89C6_u9891_29"><a href="#u7F51_u7EDC__28_u89C6_u9891_29" class="headerlink" title="网络 (视频)"></a>网络 (视频)</h3><ul>
<li>[ ] <a href="https://www.khanacademy.org/computing/computer-science/internet-intro" target="_blank" rel="external">可汗学院</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Vdc8TCESIg8" target="_blank" rel="external">网络传输协议中的数据压缩</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=e5DEVa9eSN0" target="_blank" rel="external">TCP/IP 和 OSI 模型解析!</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=nomyRJehhnM" target="_blank" rel="external">TCP/IP 教程：传输数据包.</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=WGJrLqtX7As" target="_blank" rel="external">HTTP</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=S2iBR2ZlZf0" target="_blank" rel="external">SSL 和 HTTPS</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Rp3iZUvXWlM" target="_blank" rel="external">SSL/TLS</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=E9FxNzv1Tr8" target="_blank" rel="external">HTTP 2.0</a></li>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PLEbnTDJUr_IegfoqO4iPnPYQui46QqT0j" target="_blank" rel="external">视频</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=t5xYI0jzOf4" target="_blank" rel="external">子网络解密 - 第五部分 经典内部域名指向 CIDR 标记</a></li>
</ul>
</li>
<li><h3 id="u8BA1_u7B97_u673A_u5B89_u5168"><a href="#u8BA1_u7B97_u673A_u5B89_u5168" class="headerlink" title="计算机安全"></a>计算机安全</h3><ul>
<li><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">MIT</a><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">威胁模型：入门</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=6bwzNg5qQ0o&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=2" target="_blank" rel="external">控制攻击</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=drQyrzRoRiA&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=3" target="_blank" rel="external">缓冲数据注入和防御</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=6SIJmoE9L9g&amp;index=4&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">优先权区分</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=8VqTSY-11F4&amp;index=5&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">能力</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=VEV74hwASeU&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=6" target="_blank" rel="external">在沙盒中运行原生代码</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=chkFBigodIw&amp;index=7&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">网络安全模型</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=EBQIGy1ROLY&amp;index=8&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">网络安全应用</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=yRVZPvHYHzw&amp;index=9&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">标志化执行</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=SIEVvk3NVuk&amp;index=11&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">网络安全</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=QOtA76ga_fY&amp;index=12&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">网络协议</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=PuVMkSEcPiI&amp;index=15&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">旁路攻击</a></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u91CA_u653E_u7F13_u5B58"><a href="#u91CA_u653E_u7F13_u5B58" class="headerlink" title="释放缓存"></a>释放缓存</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=StdfeXaKGEc&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=25" target="_blank" rel="external">Java 释放缓存; 片段化数据 (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PLO9y7hOkmmSGTy5z6HZ-W4k2y8WXF7Bff" target="_blank" rel="external">编译器 (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=iHVs_HkjdmI" target="_blank" rel="external">Python 释放缓存 (视频)</a></li>
<li>[ ] <a href="https://www.infoq.com/presentations/garbage-collection-benefits" target="_blank" rel="external">深度解析：论释放缓存在 JAVA 中的重要性</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=P-8Z0-MhdQs&amp;list=PLdzf4Clw0VbOEWOS_sLhT_9zaiQDrS5AR&amp;index=3" target="_blank" rel="external">深度解析：论释放缓存在 Python 中的重要性(视频)</a></li>
</ul>
</li>
<li><h3 id="u5E76_u884C/_u5E76_u53D1_u7F16_u7A0B"><a href="#u5E76_u884C/_u5E76_u53D1_u7F16_u7A0B" class="headerlink" title="并行/并发编程"></a>并行/并发编程</h3><ul>
<li>[ ] <a href="https://www.coursera.org/learn/parprog1/home/week/1" target="_blank" rel="external">Coursera (Scala)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=uY85GkaYzBk" target="_blank" rel="external">论并行/并发编程如何提高 Python 执行效率 (视频)</a></li>
</ul>
</li>
<li><h3 id="u8BBE_u8BA1_u6A21_u5F0F"><a href="#u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=3cmzqZzwNDM&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc&amp;index=3" target="_blank" rel="external">UML统一建模语言概览 (视频)</a></li>
<li>[ ] 主要有如下的设计模式:<ul>
<li>[ ] s(strategy)</li>
<li>[ ] singleton</li>
<li>[ ] adapter</li>
<li>[ ] prototype</li>
<li>[ ] decorator</li>
<li>[ ] visitor</li>
<li>[ ] factory, abstract factory</li>
<li>[ ] facade</li>
<li>[ ] observer</li>
<li>[ ] proxy</li>
<li>[ ] delegate</li>
<li>[ ] command</li>
<li>[ ] state</li>
<li>[ ] memento</li>
<li>[ ] iterator</li>
<li>[ ] composite</li>
<li>[ ] flyweight</li>
</ul>
</li>
<li>[ ] <a href="https://youtu.be/LAP2A80Ajrg?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO&amp;t=3344" target="_blank" rel="external">第六章 (第 1 部分 ) - 设计模式 (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=U8-PGsjvZc4&amp;index=12&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="external">第六章 (第 2 部分 ) - Abstraction-Occurrence, General Hierarchy, Player-Role, Singleton, Observer, Delegation (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=7sduBHuex4c&amp;index=13&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="external">第六章 (第 3 部分 ) - Adapter, Facade, Immutable, Read-Only Interface, Proxy (video)</a></li>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PLF206E906175C7E07" target="_blank" rel="external">视频</a></li>
<li>[ ] <a href="https://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124" target="_blank" rel="external">Head Fisrt 设计模型</a><ul>
<li>尽管这本书叫做设计模式：重复使用模块，但是我还是认为Head First是对于新手来说很不错的书。</li>
</ul>
</li>
<li>[ ] <a href="https://sourcemaking.com/design-patterns-and-tips" target="_blank" rel="external">基于实际操作对于入门开发者的建议</a></li>
</ul>
</li>
<li><h3 id="u4FE1_u606F_u4F20_u8F93_2C__u5E8F_u5217_u5316_2C_u548C_u961F_u5217_u5316_u7684_u7CFB_u7EDF"><a href="#u4FE1_u606F_u4F20_u8F93_2C__u5E8F_u5217_u5316_2C_u548C_u961F_u5217_u5316_u7684_u7CFB_u7EDF" class="headerlink" title="信息传输, 序列化,和队列化的系统"></a>信息传输, 序列化,和队列化的系统</h3><ul>
<li>[ ] <a href="https://thrift.apache.org/" target="_blank" rel="external">Thrift</a><ul>
<li><a href="http://thrift-tutorial.readthedocs.io/en/latest/intro.html" target="_blank" rel="external">教程</a></li>
</ul>
</li>
<li>[ ] <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">协议缓冲</a><ul>
<li><a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="external">教程</a></li>
</ul>
</li>
<li>[ ] <a href="http://www.grpc.io/" target="_blank" rel="external">gRPC</a><ul>
<li><a href="https://www.youtube.com/watch?v=5tmPvSe7xXQ&amp;list=PLcTqM9n_dieN0k1nSeN36Z_ppKnvMJoly&amp;index=1" target="_blank" rel="external">gRPC 对于JAVA开发者的入门教程（视频）</a></li>
</ul>
</li>
<li>[ ] <a href="http://redis.io/" target="_blank" rel="external">Redis</a><ul>
<li><a href="http://try.redis.io/" target="_blank" rel="external">教程</a></li>
</ul>
</li>
<li>[ ] <a href="https://aws.amazon.com/sqs/" target="_blank" rel="external">Amazon的 SQS 系统 (队列)</a></li>
<li>[ ] <a href="https://aws.amazon.com/sns/" target="_blank" rel="external">Amazon的 SNS 系统 (pub-sub)</a></li>
<li>[ ] <a href="https://www.rabbitmq.com/" target="_blank" rel="external">RabbitMQ</a><ul>
<li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="external">入门教程</a></li>
</ul>
</li>
<li>[ ] <a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a><ul>
<li><a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html" target="_blank" rel="external">Celery入门</a></li>
</ul>
</li>
<li>[ ] <a href="http://zeromq.org/" target="_blank" rel="external">ZeroMQ</a><ul>
<li><a href="http://zeromq.org/intro:read-the-manual" target="_blank" rel="external">入门教程</a></li>
</ul>
</li>
<li>[ ] <a href="http://activemq.apache.org/" target="_blank" rel="external">ActiveMQ</a></li>
<li>[ ] <a href="http://kafka.apache.org/documentation.html#introduction" target="_blank" rel="external">Kafka</a></li>
<li>[ ] <a href="http://msgpack.org/index.html" target="_blank" rel="external">MessagePack</a></li>
<li>[ ] <a href="https://avro.apache.org/" target="_blank" rel="external">Avro</a></li>
</ul>
</li>
<li><h3 id="u5FEB_u901F_u5085_u91CC_u53F6_u53D8_u6362"><a href="#u5FEB_u901F_u5085_u91CC_u53F6_u53D8_u6362" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><ul>
<li>[ ] <a href="http://www.askamathematician.com/2012/09/q-what-is-a-fourier-transform-what-is-it-used-for/" target="_blank" rel="external">什么是傅立叶变换？论傅立叶变换的用途</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Xxut2PN-V8Q" target="_blank" rel="external">什么是傅立叶变换？ (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=iTMn0Kt18tg&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=4" target="_blank" rel="external">关于 FFT 的不同观点 (视频)</a></li>
<li>[ ] <a href="http://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/" target="_blank" rel="external">FTT 是什么</a></li>
</ul>
</li>
<li><h3 id="u5E03_u9686_u8FC7_u6EE4_u5668"><a href="#u5E03_u9686_u8FC7_u6EE4_u5668" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul>
<li>给一个布隆过滤器m比特和k个哈希函数，所有的注入和相关测试都会是通过。</li>
<li><a href="https://www.youtube.com/watch?v=-SuTGoFYjZs" target="_blank" rel="external">布隆过滤器</a></li>
<li><a href="https://www.youtube.com/watch?v=qBTdukbzc78" target="_blank" rel="external">布隆过滤器 | 数据挖掘 | Stanford University</a></li>
<li><a href="http://billmill.org/bloomfilter-tutorial/" target="_blank" rel="external">教程</a></li>
<li><a href="http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/" target="_blank" rel="external">如何写一个布隆过滤器应用</a></li>
</ul>
</li>
<li><h3 id="van_Emde_Boas__u6811"><a href="#van_Emde_Boas__u6811" class="headerlink" title="van Emde Boas 树"></a>van Emde Boas 树</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=hmReJCupbNU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=6" target="_blank" rel="external">争论: van Emde Boas 树 (视频)</a></li>
<li>[ ] <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2012/lecture-notes/MIT6_046JS12_lec15.pdf" target="_blank" rel="external">MIT课堂笔记</a></li>
</ul>
</li>
<li><h3 id="u66F4_u6DF1_u5165_u7684_u6570_u636E_u7ED3_u6784"><a href="#u66F4_u6DF1_u5165_u7684_u6570_u636E_u7ED3_u6784" class="headerlink" title="更深入的数据结构"></a>更深入的数据结构</h3><ul>
<li>[ ] <a href="https://youtu.be/zksIj9O8_jc?list=PL4BBB74C7D2A1049C&amp;t=950" target="_blank" rel="external">CS 61B 第 39 课: 更深入的数据结构</a></li>
</ul>
</li>
<li><h3 id="u8DF3_u8868"><a href="#u8DF3_u8868" class="headerlink" title="跳表"></a>跳表</h3><ul>
<li>“有一种非常迷幻的数据类型” - Skiena</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=2g9OSRKJuzM&amp;index=10&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="external">随机化: 跳表 (视频)</a></li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="external">更生动详细的解释</a></li>
</ul>
</li>
<li><h3 id="u7F51_u7EDC_u6D41"><a href="#u7F51_u7EDC_u6D41" class="headerlink" title="网络流"></a>网络流</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=v1VgJmkEJW0" target="_blank" rel="external">5分钟简析Ford-Fulkerson (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=v1VgJmkEJW0" target="_blank" rel="external">Ford-Fulkerson 算法 (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=2vhN4Ice5jI" target="_blank" rel="external">网络流 (视频)</a></li>
</ul>
</li>
<li><h3 id="u4E0D_u76F8_u4EA4_u96C6__26amp_3B__u8054_u5408_u67E5_u627E"><a href="#u4E0D_u76F8_u4EA4_u96C6__26amp_3B__u8054_u5408_u67E5_u627E" class="headerlink" title="不相交集 &amp; 联合查找"></a>不相交集 &amp; 联合查找</h3><ul>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="external">不相交集</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=MAEGXTwmUsI&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=21" target="_blank" rel="external">UCB 61B - 不相交集; 排序 &amp; 选择(视频)</a></li>
<li>[ ] Coursera (not needed since the above video explains it great):<ul>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/JssSY/overview" target="_blank" rel="external">概览</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/EM5D0/naive-implementations" target="_blank" rel="external">初级实践</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/Mxu0w/trees" target="_blank" rel="external">树状结构</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/qb4c2/union-by-rank" target="_blank" rel="external">合并树状结构</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/Q9CVI/path-compression" target="_blank" rel="external">路径压缩</a></li>
<li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/GQQLN/analysis-optional" target="_blank" rel="external">分析选项</a></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="u5FEB_u901F_u5904_u7406_u6570_u5B66"><a href="#u5FEB_u901F_u5904_u7406_u6570_u5B66" class="headerlink" title="快速处理数学"></a>快速处理数学</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=eCaXlAaN2uE&amp;index=11&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">整数运算, Karatsuba 乘法 (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ru7mWZJlRQg" target="_blank" rel="external">中国剩余定理 (在密码学中的使用) (视频)</a></li>
</ul>
</li>
<li><h3 id="u6811_u5806__28Treap_29"><a href="#u6811_u5806__28Treap_29" class="headerlink" title="树堆 (Treap)"></a>树堆 (Treap)</h3><ul>
<li>一个二叉搜索树和一个堆的组合</li>
<li>[ ] <a href="https://en.wikipedia.org/wiki/Treap" target="_blank" rel="external">树堆</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=6podLUYinH8" target="_blank" rel="external">数据结构：树堆的讲解(video)</a></li>
<li>[ ] <a href="https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf" target="_blank" rel="external">集合操作的应用(Applications in set operations)</a></li>
</ul>
</li>
<li><h3 id="u7EBF_u6027_u89C4_u5212_uFF08Linear_Programming_uFF09_uFF08_u89C6_u9891_uFF09"><a href="#u7EBF_u6027_u89C4_u5212_uFF08Linear_Programming_uFF09_uFF08_u89C6_u9891_uFF09" class="headerlink" title="线性规划（Linear Programming）（视频）"></a>线性规划（Linear Programming）（视频）</h3><ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=M4K6HYLHREQ" target="_blank" rel="external">线性规划</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=2ACJ9ewUC6U" target="_blank" rel="external">寻找最小成本</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=8AA_81xI3ik" target="_blank" rel="external">寻找最大值</a></li>
</ul>
</li>
<li><h3 id="u51E0_u4F55_uFF1A_u51F8_u5305_uFF08Geometry_2C_Convex_hull_uFF09_uFF08_u89C6_u9891_uFF09"><a href="#u51E0_u4F55_uFF1A_u51F8_u5305_uFF08Geometry_2C_Convex_hull_uFF09_uFF08_u89C6_u9891_uFF09" class="headerlink" title="几何：凸包（Geometry, Convex hull）（视频）"></a>几何：凸包（Geometry, Convex hull）（视频）</h3><ul>
<li>[ ] <a href="https://youtu.be/XIAQRlNkJAw?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3164" target="_blank" rel="external">Graph Alg. IV: 几何算法介绍 - 第 9 课</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=J5aJEcOr6Eo&amp;index=10&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="external">Graham &amp; Jarvis: 几何算法 - 第 10 课</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=EzeYI7p9MjU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=2" target="_blank" rel="external">Divide &amp; Conquer: 凸包, 中值查找</a></li>
</ul>
</li>
<li><h3 id="u79BB_u6563_u6570_u5B66"><a href="#u79BB_u6563_u6570_u5B66" class="headerlink" title="离散数学"></a>离散数学</h3><ul>
<li>查看下面的视频：(这里没看到视频= =）</li>
</ul>
</li>
<li><h3 id="u673A_u5668_u5B66_u4E60_uFF08Machine_Learning_uFF09"><a href="#u673A_u5668_u5B66_u4E60_uFF08Machine_Learning_uFF09" class="headerlink" title="机器学习（Machine Learning）"></a>机器学习（Machine Learning）</h3><ul>
<li>[ ] 为什么学习机器学习？<ul>
<li>[ ] <a href="https://backchannel.com/how-google-is-remaking-itself-as-a-machine-learning-first-company-ada63defcb70" target="_blank" rel="external">谷歌如何将自己改造成一家「机器学习优先」公司？</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=QSaZGT4-6EY" target="_blank" rel="external">智能计算机系统的大规模深度学习 (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=X769cyzBNVw" target="_blank" rel="external">Peter Norvig：深度学习和理解与软件工程和验证的对比</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Ja2hxBAwG_0" target="_blank" rel="external">谷歌云机器学习工具（视频）</a></li>
<li>[ ] <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal" target="_blank" rel="external">谷歌开发者机器学习清单 (Scikit Learn 和 Tensorflow) (视频)</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=oZikw5k_2FM" target="_blank" rel="external">Tensorflow (视频)</a></li>
<li>[ ] <a href="https://www.tensorflow.org/versions/r0.11/tutorials/index.html" target="_blank" rel="external">Tensorflow 教程</a></li>
<li>[ ] <a href="http://www.analyticsvidhya.com/blog/2016/04/neural-networks-python-theano/" target="_blank" rel="external">Python 实现神经网络实例教程（使用 Theano）</a></li>
<li>课程:<ul>
<li>[ ] <a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">很棒的初级课程：机器学习</a><pre><code>- [视频教程](https://www.youtube.com/playlist?list=PLZ9qNFMHZ-A4rycgrgOYma6zxF4BZGGPW)
- 看第 12-18 集复习线性代数（第 14 集和第 15 集是重复的）
</code></pre></li>
<li>[ ] <a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="external">机器学习中的神经网络</a></li>
<li>[ ] <a href="https://www.udacity.com/course/deep-learning--ud730" target="_blank" rel="external">Google 深度学习微学位</a></li>
<li>[ ] <a href="https://www.udacity.com/course/machine-learning-engineer-nanodegree-by-google--nd009" target="_blank" rel="external">Google/Kaggle 机器学习工程师微学位</a></li>
<li>[ ] <a href="https://www.udacity.com/drive" target="_blank" rel="external">无人驾驶工程师微学位</a></li>
<li>[ ] <a href="http://www.thisismetis.com/explore-data-science" target="_blank" rel="external">Metis 在线课程 (两个月 99 美元)</a></li>
</ul>
</li>
<li>资源:<ul>
<li>书籍: Data Science from Scratch: First Principles with Python: <a href="https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X" target="_blank" rel="external">https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X</a></li>
<li>网站: Data School: <a href="http://www.dataschool.io/" target="_blank" rel="external">http://www.dataschool.io/</a></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Go__u8BED_u8A00"><a href="#Go__u8BED_u8A00" class="headerlink" title="Go 语言"></a>Go 语言</h3><ul>
<li>[ ] 视频:<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=FTl0tl9BGdc" target="_blank" rel="external">为什么学习 Go 语言？</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=CF9S4QZuV30" target="_blank" rel="external">Go 语言编程</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ytEkHepK08c" target="_blank" rel="external">Go 语言之旅</a></li>
</ul>
</li>
<li>[ ] 书籍:<ul>
<li>[ ] <a href="https://www.golang-book.com/books/intro" target="_blank" rel="external">Go 语言编程入门 (免费在线阅读)</a></li>
<li>[ ] <a href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440" target="_blank" rel="external">Go 语言圣经 (Donovan &amp; Kernighan)</a></li>
</ul>
</li>
<li>[ ] <a href="https://www.golang-book.com/guides/bootcamp" target="_blank" rel="external">Go 语言新手训练营</a></li>
</ul>
</li>
</ul>
<p>–</p>
<h2 id="u4E00_u4E9B_u4E3B_u9898_u7684_u989D_u5916_u5185_u5BB9"><a href="#u4E00_u4E9B_u4E3B_u9898_u7684_u989D_u5916_u5185_u5BB9" class="headerlink" title="一些主题的额外内容"></a>一些主题的额外内容</h2><pre><code>我为前面提到的某些主题增加了一些额外的内容，之所以没有直接添加到前面，是因为这样很容易导致某个主题内容过多。毕竟你想在本世纪找到一份工作，对吧？
</code></pre><ul>
<li><p>[ ] <strong>动态规划的更多内容</strong> (视频)</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=19" target="_blank" rel="external">6.006: 动态规划 I: 斐波那契数列, 最短路径</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ENyox7kNKeY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=20" target="_blank" rel="external">6.006: 动态规划 II: 文本匹配, 二十一点/黑杰克</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=ocZMDMZwhCY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=21" target="_blank" rel="external">6.006: 动态规划 III: 最优加括号方式, 最小编辑距离, 背包问题</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=tp4_UXaVyx8&amp;index=22&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="external">6.006: 动态规划 IV: 吉他指法，拓扑，超级马里奥.</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=Tw1k46ywN6E&amp;index=14&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="external">6.046: 动态规划: 动态规划进阶</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=NzgFUwOaoIw&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=15" target="_blank" rel="external">6.046: 动态规划: 所有点对最短路径</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=krZI60lKPek&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=12" target="_blank" rel="external">6.046: 动态规划: 更多示例</a></li>
</ul>
</li>
<li><p>[ ] <strong>图形处理进阶</strong> (视频)</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=mUBmcbbJNf4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=27" target="_blank" rel="external">异步分布式算法: 对称性破缺，最小生成树</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=kQ-UQAzcnzA&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=28" target="_blank" rel="external">异步分布式算法: 最小生成树</a></li>
</ul>
</li>
<li><p>[ ] MIT <strong>概率论</strong> (mathy, and go slowly, which is good for mathy things) (视频):</p>
<ul>
<li>[ ] <a href="https://www.youtube.com/watch?v=SmFwFdESMHI&amp;index=18&amp;list=PLB7540DEDD482705B" target="_blank" rel="external">MIT 6.042J - 概率论概述</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=E6FbvM-FGZ8&amp;index=19&amp;list=PLB7540DEDD482705B" target="_blank" rel="external">MIT 6.042J - 条件概率 Probability</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=l1BCv3qqW4A&amp;index=20&amp;list=PLB7540DEDD482705B" target="_blank" rel="external">MIT 6.042J - 独立</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=MOfhhFaQdjw&amp;list=PLB7540DEDD482705B&amp;index=21" target="_blank" rel="external">MIT 6.042J - 随机变量</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=gGlMSe7uEkA&amp;index=22&amp;list=PLB7540DEDD482705B" target="_blank" rel="external">MIT 6.042J - 期望 I</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=oI9fMUqgfxY&amp;index=23&amp;list=PLB7540DEDD482705B" target="_blank" rel="external">MIT 6.042J - 期望 II</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=q4mwO2qS2z4&amp;index=24&amp;list=PLB7540DEDD482705B" target="_blank" rel="external">MIT 6.042J - 大偏差</a></li>
<li>[ ] <a href="https://www.youtube.com/watch?v=56iFMY8QW2k&amp;list=PLB7540DEDD482705B&amp;index=25" target="_blank" rel="external">MIT 6.042J - 随机游走</a></li>
</ul>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=oDniZCmNmNw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=19" target="_blank" rel="external">Simonson: 近似算法 (视频)</a></p>
</li>
</ul>
<h2 id="u89C6_u9891_u7CFB_u5217"><a href="#u89C6_u9891_u7CFB_u5217" class="headerlink" title="视频系列"></a>视频系列</h2><p> 坐下来享受一下吧。”netflix and skill” :P</p>
<ul>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr" target="_blank" rel="external">个人的动态规划问题列表 (都是短视频哟)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL038BE01D3BAEFDB0" target="_blank" rel="external">x86 架构，汇编，应用程序 (11 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLE7DDD91010BC51F8" target="_blank" rel="external">MIT 18.06 线性代数，2005 年春季 (35 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL3B08AE665AB9002A" target="_blank" rel="external">绝妙的 MIT 微积分：单变量微积分</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iD8wQm8U0gG_Z1uHjImKXFy" target="_blank" rel="external">计算机科学 70, 001 - 2015 年春季 - 离散数学和概率理论</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL3o9D4Dl2FJ9q0_gtFXPh_H4POI5dK0yG" target="_blank" rel="external">离散数学 (19 个视频)</a></p>
</li>
<li><p>[ ] CSE373 - 算法分析 (25 个视频)</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZFjhkohHdAA&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=1" target="_blank" rel="external">Skiena 的算法设计手册讲座</a></li>
</ul>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=mFPmKGIrQs4&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd" target="_blank" rel="external">UC Berkeley 61B (2014 年春季): 数据结构 (25 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL4BBB74C7D2A1049C" target="_blank" rel="external">UC Berkeley 61B (2006 年秋季): 数据结构 (39 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=gJJeUFyuvvg&amp;list=PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_" target="_blank" rel="external">UC Berkeley 61C: 计算机结构 (26 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="external">OOSE: 使用 UML 和 Java 进行软件开发 (21 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=UH0QYvtP7Rk&amp;index=20&amp;list=PLkFD6_40KJIwEiwQx1dACXwh-2Fuo32qr" target="_blank" rel="external">UC Berkeley CS 152: 计算机结构和工程 (20 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-" target="_blank" rel="external">MIT 6.004: 计算结构 (49 视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL5PHm2jkkXmi5CxxI7b3JCL1TWybTDtKq" target="_blank" rel="external">卡內基梅隆大学 - 计算机架构讲座 (39 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=HtSuA80QTyo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;nohtml5=False" target="_blank" rel="external">MIT 6.006: 算法介绍 (47 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=zm2VP0kHl1M&amp;list=PL6535748F59DCA484" target="_blank" rel="external">MIT 6.033: 计算机系统工程 (22 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP63gFHB6xb-kVBiQHYe_4hSi" target="_blank" rel="external">MIT 6.034 人工智能, 2010 年秋季 (30 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=L3LMbpZIKhQ&amp;list=PLB7540DEDD482705B" target="_blank" rel="external">MIT 6.042J: 计算机科学数学, 2010 年秋季 (25 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=2P-yW7LQr08&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="external">MIT 6.046: 算法设计与分析 (34 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=phxsQrZQupo&amp;list=PL_2Bwul6T-A7OldmhGODImZL8KEVE38X7" target="_blank" rel="external">MIT 6.050J: 信息和熵, 2008 年春季 (19 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=T0yzrZL1py0&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=1" target="_blank" rel="external">MIT 6.851: 高等数据结构 (22 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c" target="_blank" rel="external">MIT 6.854: 高等算法, 2016 年春季 (24 个视频)</a></p>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="external">MIT 6.858计算机系统安全, 2014 年秋季</a></p>
</li>
<li><p>[ ] 斯坦福: 编程范例 (17 个视频)</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=jTSvthW34GU&amp;list=PLC0B8B318B7394B6F&amp;nohtml5=False" target="_blank" rel="external">C 和 C++ 课程</a></li>
</ul>
</li>
<li><p>[ ] <a href="https://www.youtube.com/watch?v=2aHkqB2-46k&amp;feature=youtu.be" target="_blank" rel="external">密码学导论</a></p>
<ul>
<li><a href="https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg" target="_blank" rel="external">本系列更多内容 (不分先后顺序)</a></li>
</ul>
</li>
<li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLLssT5z_DsK9JDLcT8T62VtzwyW9LNepV" target="_blank" rel="external">大数据 - 斯坦福大学 (94 个视频)</a></p>
</li>
</ul>
<h2 id="u8BA1_u7B97_u673A_u79D1_u5B66_u8BFE_u7A0B"><a href="#u8BA1_u7B97_u673A_u79D1_u5B66_u8BFE_u7A0B" class="headerlink" title="计算机科学课程"></a>计算机科学课程</h2><ul>
<li><a href="https://github.com/open-source-society/computer-science" target="_blank" rel="external"> 在线 CS 课程目录 </a></li>
<li><a href="https://github.com/prakhar1989/awesome-courses" target="_blank" rel="external">CS 课程目录 (一些是在线讲座)</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C Sharp学习笔记]]></title>
      <url>http://pengtianhao.com/2016/09/21/C%20Sharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一直觉得C#语法和Java很类似（事实上也是这样，都面向对象），但其实它的基于C/C++的。现在因为要用Unity的关系需要学一下C#。这里很多内容来自<a href="http://www.runoob.com/" target="_blank" rel="external">runoob.com</a></p>
</blockquote>
<a id="more"></a>
<h2 id="u7A0B_u5E8F_u7ED3_u6784"><a href="#u7A0B_u5E8F_u7ED3_u6784" class="headerlink" title="程序结构"></a>程序结构</h2><p>这里给一个最简单的小程序：</p>
<pre><code>//1. using 关键字用于在程序中包含 System 命名空间
//一个程序一般有多个 using 语句
using System;

//2.一个 namespace 是一系列的类
//First 命名空间包含了类 MainClass
namespace First {

    //类大家都差不多
    class MainClass {

        //Main 方法，是所有程序的入口点    

        public static void Main (string[] args) {

        //用Rectangle类初始化了一个对象
        Rectangle myRec = new Rectangle ();
        myRec.width = 1;
        myRec.height = 2;
        myRec.countArea ();

        //打印
        Console.WriteLine (&quot;Hello World!&quot;);
        }
    }

    class Rectangle {
        public double width;
        public double height;

        public void countArea(){
            Console.WriteLine(&quot;area === {0}&quot;,width*height);
        }    
    }
}
</code></pre><h2 id="u547D_u540D_u7A7A_u95F4"><a href="#u547D_u540D_u7A7A_u95F4" class="headerlink" title="命名空间"></a>命名空间</h2><p>namespace是为了区分命名区间，有利于协作的机制</p>
<p>用的时候就</p>
<pre><code>mynamespace.myclass a = new mynamespace.myclass();
</code></pre><p>在system里才可以不加namespace直接写</p>
<pre><code>Console.WriteLine(&quot;Hello&quot;);
</code></pre><p>在其他命名空间就要</p>
<pre><code>System.Console.WriteLine(&quot;Hello&quot;);
</code></pre><h2 id="u6570_u636E_u7C7B_u578B"><a href="#u6570_u636E_u7C7B_u578B" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="u57FA_u672C_u6570_u636E_u7C7B_u578B"><a href="#u57FA_u672C_u6570_u636E_u7C7B_u578B" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>这里主要指的是<code>int</code>、<code>float</code>之类的，和c差不多，但是就是有一点比较关注</p>
<p>就是有说法是变量有初始值，但事实上不赋初始值会报错。</p>
<h3 id="u5F15_u7528_u7C7B_u578B"><a href="#u5F15_u7528_u7C7B_u578B" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="object_u5BF9_u8C61_u7C7B_u578B"><a href="#object_u5BF9_u8C61_u7C7B_u578B" class="headerlink" title="object对象类型"></a>object对象类型</h4><p>这是所有数据类型的基类，所以打印<code>123</code>可以这么做</p>
<pre><code>object xy = &quot;123&quot;;
Console.WriteLine (&quot;{0}&quot;,xy);
</code></pre><p>管他什么类型都可以直接赋给xy，相当于oc的<code>id</code>或者Swift的<code>anyobject</code></p>
<h4 id="dynamic_u7C7B_u578B"><a href="#dynamic_u7C7B_u578B" class="headerlink" title="dynamic类型"></a>dynamic类型</h4><p>其实<code>dynamic</code>和<code>object</code>挺类似的，只不过前者类型检查是在运行时发生，后者在编译时发生的。</p>
<p>这里有个关于它们的讲解：<a href="http://www.cnblogs.com/LoveJenny/archive/2011/07/04/2097031.html" target="_blank" rel="external">浅谈Dynamic 关键字系列之一:dynamic 就是Object</a></p>
<h4 id="string_u7C7B_u578B"><a href="#string_u7C7B_u578B" class="headerlink" title="string类型"></a>string类型</h4><p>这个类专门用来保存字符串，并且有一个很棒的关键字<code>@</code>(这里要注意此<code>@</code>和oc里的<code>@</code>不一样：C#里来用无视转义字符，所见即所得；oc里用来与c区分，比如<code>@select</code>也是差不多的意思)</p>
<pre><code>string str = @&quot;C:\Windows&quot;;

string str = &quot;C:\\Windows&quot;;    
</code></pre><h5 id="String_u7C7B_u7684_u57FA_u7C7B"><a href="#String_u7C7B_u7684_u57FA_u7C7B" class="headerlink" title="String类的基类"></a>String类的基类</h5><p><a href="http://www.runoob.com/csharp/csharp-string.html" target="_blank" rel="external">String类的属性和方法</a></p>
<p>String类是string的基类，提供了很多方法和属性，比如长度、比较、链接、查找甚至大小写转换</p>
<h3 id="u53EF_u7A7A_u7C7B_u578B"><a href="#u53EF_u7A7A_u7C7B_u578B" class="headerlink" title="可空类型"></a>可空类型</h3><p>这个和swift里的自判断链接差不多，都是加<code>？</code>，不过要记得还是要赋<code>null</code>值</p>
<pre><code>int? x = null;
int? y = null;
Console.WriteLine (&quot;{0} {1}&quot;,x,y);
</code></pre><h3 id="u6307_u9488"><a href="#u6307_u9488" class="headerlink" title="指针"></a>指针</h3><p>C#里也有类似C的指针，用法一模一样</p>
<pre><code>int *a;
</code></pre><h3 id="u7C7B_u578B_u8F6C_u6362"><a href="#u7C7B_u578B_u8F6C_u6362" class="headerlink" title="类型转换"></a>类型转换</h3><p>有这么多类型，就有互相转换的问题，比如http通讯的时候，就经常把数字转换成字符串</p>
<p>转换最通用的方法是用<code>Convert</code>类</p>
<pre><code>int i = 0;
string x = &quot;123&quot;;
i = Convert.ToInt16 (x);    //i = 123
</code></pre><p>当要转字符串的时候也可以用类型内置的转换方法:</p>
<pre><code>int i = 123;
string x = i.ToString();    //x = &quot;123&quot;
</code></pre><h3 id="Null__u5408_u5E76_u8FD0_u7B97_u7B26"><a href="#Null__u5408_u5E76_u8FD0_u7B97_u7B26" class="headerlink" title="Null 合并运算符"></a>Null 合并运算符</h3><p>Null 合并运算符<code>??</code>出现在有符号<code>？</code>的地方，用法是如果前者为<code>null</code>，就把后者赋给变量</p>
<pre><code>int? x = null;
int? y = 123;

int x2 = x ?? 1234;
int y2 = y ?? 1234;

Console.WriteLine (&quot;{0} {1}&quot;,x2,y2);//打印『1234 123』    
</code></pre><h3 id="u5E38_u91CF"><a href="#u5E38_u91CF" class="headerlink" title="常量"></a>常量</h3><pre><code>const double pi = 3.14159; // 常量声明
double s = pi*r*r;
</code></pre><h3 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h3><h4 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h4><p>数组是一个对象，初始化有很多种形式</p>
<pre><code>double[] array = new double[5];//元素自动赋值为0

double[] balance = { 2340.0, 4523.69, 3421.0};//直接赋值

int [] marks = new int[5]  { 99,  98, 92, 97, 95};//其实并不知道这个在这里有什么意义

int [] marks = new int[]  { 99,  98, 92, 97, 95};//这个也一样
</code></pre><p>除了需要初始化以外，其他和c没什么区别</p>
<h4 id="Array_u7C7B"><a href="#Array_u7C7B" class="headerlink" title="Array类"></a>Array类</h4><p>Array是数组类的基类，里面有很多好用的方法和属性，比如<strong>清空、复制、得到长度、逆转、排序等等</strong></p>
<h3 id="u4ECE_u63A7_u5236_u53F0_u8F93_u5165"><a href="#u4ECE_u63A7_u5236_u53F0_u8F93_u5165" class="headerlink" title="从控制台输入"></a>从控制台输入</h3><p>输入输出都用了<code>Console</code>类，<code>ReadLine</code>返回的是字符串类，所以如果想要得到一个int类型还得进行一次转换</p>
<pre><code>Int32 xx = Convert.ToInt32(Console.ReadLine());
</code></pre><h3 id="u6BD4_u8F83"><a href="#u6BD4_u8F83" class="headerlink" title="比较"></a>比较</h3><ul>
<li><strong>符号<code>=</code></strong> 用于值的比较，如果是用在引用类型上(比如object之间)，那么就是比较地址，例子很简单</li>
</ul>
<pre><code>int i = 1;
int x = 1;
if (i == x){
    Console.WriteLine (@&quot;is equal&quot;);
}//打印『isqual』

object i = 1;
object x = 1;

if (i != x) {
    Console.WriteLine (@&quot;not equal&quot;);
}//打印『not equal』
</code></pre><ul>
<li><p><strong>equal</strong> 用于比较引用类型的值</p>
<pre><code>object i = 1;
object x = 1;

if (i.Equals(x)) {
    Console.WriteLine (@&quot;is equal&quot;);
}//打印『isqual』
</code></pre></li>
</ul>
<h3 id="u63A7_u5236_u6761_u4EF6"><a href="#u63A7_u5236_u6761_u4EF6" class="headerlink" title="控制条件"></a>控制条件</h3><p>这个和c差不多，就写一个，可以对例如数组的对象使用<code>foreach</code>循环来遍历</p>
<pre><code>int[] array = {1,2,3,4};

foreach(int x in array) {
    Console.WriteLine(&quot;{0}&quot;,x);
}
</code></pre><h2 id="u7C7B_u76F8_u5173"><a href="#u7C7B_u76F8_u5173" class="headerlink" title="类相关"></a>类相关</h2><p><strong><code>this</code>表示自己</strong></p>
<h3 id="u5C5E_u6027"><a href="#u5C5E_u6027" class="headerlink" title="属性"></a>属性</h3><p>C#里的属性和其他的语言不太一样，这一种用来规范原来字段的东西</p>
<pre><code>属性（Property） 是类（class）、结构（structure）和接口（interface）
的命名（named）成员。类或结构中的成员变量或方法称为 域（Field）。
属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。
它们使用 访问器（accessors） 让私有域的值可被读写或操作。
</code></pre><p><strong>说得通俗一点就是：</strong></p>
<p>这是一个模子，本来我们需要调用字段的时候，要么设成public，但是不安全，要么通过set或者get，但是也有问题，没法规定属性的范围或者做一些其他操作，这个c#和swift都做到了（swift对于这块内容详见:<a href="http://pengtianhao.com/2016/08/14/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#u5C5E_u6027">Swift中的属性</a>）。c#的属性就是为此而生的</p>
<h4 id="u5C5E_u6027_u7684_u4F8B_u5B50"><a href="#u5C5E_u6027_u7684_u4F8B_u5B50" class="headerlink" title="属性的例子"></a>属性的例子</h4><pre><code>class myClass {
    public int a;
    public int A
    {
        get {
            return a*3;
        }

        set {
            //value就是输入值
            a = 2*value;
        } s

    }
}
</code></pre><p>通过属性赋值</p>
<pre><code>myClass a = new myClass();
a.A = 1;
Console.WriteLine(&quot;{0}&quot;, a.A);
</code></pre><p>打印结果为:<strong>6</strong></p>
<h3 id="u7D22_u5F15_u5668"><a href="#u7D22_u5F15_u5668" class="headerlink" title="索引器"></a>索引器</h3><p>自己的理解就是索引器用来给应用一个能力，让实例能够实现</p>
<pre><code>class myClass{
    public int[] a = new int[10];
    public myClass(){
        for (int i = 0; i &lt; 10; i++)
        {
            a[i] = 1;
        }
    }

    public int this[int index]
    {
        get
        {
            return a[index];
        }

        set
        {
            a[index] = value;
        }
    }
}
</code></pre><h3 id="u6784_u9020_u51FD_u6570"><a href="#u6784_u9020_u51FD_u6570" class="headerlink" title="构造函数"></a>构造函数</h3><p>就是一个没有返回类型的函数，在初始化的时候被调用。不过其实也可以通过静态类返回test来初始化</p>
<h3 id="u5C01_u88C5"><a href="#u5C01_u88C5" class="headerlink" title="封装"></a>封装</h3><p>如果没有指定访问修饰符，默认是<code>private</code></p>
<ul>
<li><strong>Public</strong> 任何人都能访问</li>
<li><strong>Private</strong> 只有内部访问(内部消化)，实例化的对象也不行~~</li>
<li><strong>Protected</strong> 允许子类访问它的基类的成员变量和成员函数（但还是内部消化）,实例化的对象还是访问不了</li>
<li><strong>Internal</strong> 仅在项目类公用，其他项目引用后找不到Interal的方法</li>
</ul>
<p><strong>关于Internal和Puclic的不同</strong><br>网上看到这个说法，挺有意思的：</p>
<p>『一个是国际妓女，谁用都可以，就是PUBLIC；一个是不懂外语的，只能在国内做生意，就是INTERNAL，只能在当前所在的工程里面引用。两个工程，建立一个引用关系，被引用的里面建两个类，就能区别了。用VS的话，你根本点不出来那个不懂外语的』</p>
<h3 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h3><p>大多数和java一样，但是有一个传参的关键字<code>ref</code>，用来传引用</p>
<pre><code>public void swap(ref int x,ref int y){
    int temp = x;
    x = y;
    y = temp;
}

public static void Main (string[] args) {
    int x = 1;
    int y = 2;

    MainClass f = new MainClass ();
    f.swap (ref x, ref y);

    Console.WriteLine (&quot;{0} {1}&quot;,x,y);
}
</code></pre><p>结果是x，y交换了</p>
<h3 id="u9759_u6001"><a href="#u9759_u6001" class="headerlink" title="静态"></a>静态</h3><p>静态<code>static</code>意味着一个属性被固话，无论创建多少个对象在内存中只存在一个，比如将一个int属性设为静态，那么当第二个对象修改的时候，第一个对象对应的属性也会改变</p>
<p>如果写静态方法的话，那么就意味着即使对象没被实例化也能使用，也就意味着<strong>静态方法只能操作静态变量</strong></p>
<p>下面给一个用静态方法初始化的例子，这里虽然操作了属性，但是其实并不是由方法本身操作的</p>
<pre><code>class MainClass
{
    public static void Main (string[] args)
    {
        test a = test.init ();
        Console.WriteLine (&quot;{0}&quot;,a.x);
    }

}

class test{

    public int x;

    static public test init(){
        test a = new test ();
        a.x = 1;
        return a;
    }
}
</code></pre><h3 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h3><p>既然有面向对象，那么一定会有继承</p>
<p>这里有个例子</p>
<pre><code>//基类
class animal{
    protected string name;

    public animal(string n){
        name = n;
    }

    public void bark(){
        Console.WriteLine(&quot;bark&quot;);
    }

    public void showName(){
        Console.WriteLine(name);
    }
}

//派生类
class dog:animal{

    //当基类写过构造函数的时候，子类的构造函数就需要这么写
    public dog(string n):base(n){
        name = n;
    }

    //方法的重载
    public void bark(){
        Console.WriteLine(&quot;wang&quot;);
    }
}
</code></pre><p>这时候在<code>main</code>函数里写</p>
<pre><code>dog ds = new dog (&quot;nnn&quot;);
ds.showName ();
ds.bark ();
</code></pre><p>打印结果是</p>
<pre><code>nnn
wang
</code></pre><p>这里面的<code>base</code>大概就是<code>super</code>的意思，表示基类</p>
<h3 id="u591A_u6001"><a href="#u591A_u6001" class="headerlink" title="多态"></a>多态</h3><h4 id="u91CD_u8F7D"><a href="#u91CD_u8F7D" class="headerlink" title="重载"></a>重载</h4><p>上面有一个重载的例子，但还有一个要注意</p>
<p><strong>能重载只有返回类型不同的函数声明</strong></p>
<h4 id="u62BD_u8C61_u7C7B"><a href="#u62BD_u8C61_u7C7B" class="headerlink" title="抽象类"></a>抽象类</h4><p><code>abstract</code>其实可以看做是一种接口，规定了继承者要实现的方法。</p>
<pre><code>abstract class Shape {
  public abstract int area();
}
</code></pre><p>派生类就要写</p>
<pre><code>public override int area ()
</code></pre><p>主要是要注意这几点</p>
<ul>
<li>抽象类无法被实例化</li>
<li>抽象方法无法在抽象类外部声明</li>
<li>无法成为sealed类（封闭类，无法被继承），要是抽象类被sealed了简直搞笑~~</li>
</ul>
<h4 id="u865A_u65B9_u6CD5"><a href="#u865A_u65B9_u6CD5" class="headerlink" title="虚方法"></a>虚方法</h4><p>vitual类让基类可以指定子类实现的方法</p>
<pre><code>public virtual int area()
{
   Console.WriteLine(&quot;父类的面积：&quot;);
   return 0;
}
</code></pre><p>子类就需要实现</p>
<pre><code>public override int area ()
</code></pre><h3 id="u63A5_u53E3"><a href="#u63A5_u53E3" class="headerlink" title="接口"></a>接口</h3><p>接口就像是一个合同，所有继承接口的类都必须实现里面规定的方法</p>
<pre><code>public interface creature{
    void breath();
}
</code></pre><h2 id="u7ED3_u6784"><a href="#u7ED3_u6784" class="headerlink" title="结构"></a>结构</h2><p>结构和c里的结构体还是有不少区别的，可以有构造函数，但是没有析构函数</p>
<pre><code>struct books{
    public int number;
    public string name;

    public void init(int n,string na) {
        number = n;
        name = na;
    }
}
</code></pre><p>结构和类的区别如果有用过别的语言的话应该知道</p>
<ul>
<li>类是引用类型，结构是值类型</li>
<li>结构不支持继承</li>
<li>结构不能声明默认的构造函数</li>
</ul>
<h2 id="u679A_u4E3E"><a href="#u679A_u4E3E" class="headerlink" title="枚举"></a>枚举</h2><p>枚举里面是符号，但是其实最终的值是数字</p>
<pre><code>enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };

int x = (int)Day.Sun;
</code></pre><h2 id="u5F02_u5E38_u5904_u7406"><a href="#u5F02_u5E38_u5904_u7406" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>try {
// 引起异常的语句
}
catch( ExceptionName e1 ) {
// 错误处理代码
}
catch( ExceptionName e2 ) {
// 错误处理代码
}
catch( ExceptionName eN ) {
// 错误处理代码
}
finally {
// 要执行的语句
}
</code></pre><p>具体在这里看<a href="http://www.runoob.com/csharp/csharp-exception-handling.html" target="_blank" rel="external">c#错误处理</a></p>
<h2 id="u6587_u4EF6_u64CD_u4F5C"><a href="#u6587_u4EF6_u64CD_u4F5C" class="headerlink" title="文件操作"></a>文件操作</h2><p>c#里主要通过FileStream类实现文件的输入输出</p>
<p>MSDN里有详细的信息 <a href="https://msdn.microsoft.com/zh-cn/library/system.io.filestream(v=vs.80" target="_blank" rel="external">FileStream类—MSDN</a>.aspx)</p>
<pre><code>FileStream F = new FileStream(&quot;sample.txt&quot;, FileMode.Open, FileAccess.Read, FileShare.Read);
</code></pre><p><strong>参数表示</strong> 都是枚举类型</p>
<ul>
<li><strong>FileMode</strong> 定义了打开方式，有Append、Open、OpenNew、CreateNew、Create、Truncate</li>
<li><strong>FileAccess</strong> 定义了能够做的操作，Read、ReadWrite和Write</li>
<li><strong>FileShare</strong> 定义了同一文件可以具有的访问类型</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数电逻辑笔记]]></title>
      <url>http://pengtianhao.com/2016/09/20/%E6%95%B0%E7%94%B5%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>数字电路的一些总结，持续更新</p>
</blockquote>
<a id="more"></a>
<h2 id="u7EEA_u8BBA"><a href="#u7EEA_u8BBA" class="headerlink" title="绪论"></a>绪论</h2><h3 id="u95E8_u7535_u8DEF_u7B26_u53F7"><a href="#u95E8_u7535_u8DEF_u7B26_u53F7" class="headerlink" title="门电路符号"></a>门电路符号</h3><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1y2u282c3R1M0c1O2a0I/7c1ed21b0ef41bd597ac45ce52da81cb39db3d08.png?v=fb6979cf" alt=""></p>
<h3 id="u6570_u5236_u8F6C_u6362"><a href="#u6570_u5236_u8F6C_u6362" class="headerlink" title="数制转换"></a>数制转换</h3><p>最好通过<strong>二进制</strong>做转点</p>
<p>16-2 每四位对应<br>8-2 每三位对应</p>
<p>数字拆分：<code>431.21（10） = 1*10^2+3*10^1+1*10^0+2*10^(-1)+1*10^(-2)</code></p>
<p><strong><em>下面的R都指进制</em></strong></p>
<h4 id="u6574_u6570_u8F6C_u6362"><a href="#u6574_u6570_u8F6C_u6362" class="headerlink" title="整数转换"></a>整数转换</h4><p><strong>以10转2为例</strong></p>
<p>数值逐次除R（这里是2），除一次就得到一个低位位，一直到结果为0为止</p>
<pre><code>//括号里为余数
53/2 = 26(1)/2 = 13(0)/2 = 6(1)/2 = 3(0)/2 = 1(1)/2 = 0(1)
</code></pre><p>结果为 <strong>110101</strong></p>
<h4 id="u5C0F_u6570_u8F6C_u6362"><a href="#u5C0F_u6570_u8F6C_u6362" class="headerlink" title="小数转换"></a>小数转换</h4><p><strong>以10转2为例</strong></p>
<p>每次乘R（这里是2），保存整数位结果作为高位，然后去掉高位，直到乘积为0或者一定精度就停止</p>
<pre><code>//括号里是整数位
0.375*2 = 0.750（0）*2 = 0.5（1）*2 = 0（1）
</code></pre><p>结果为 <strong>0.11</strong></p>
<h4 id="u5C0F_u6570_u8F6C_u6362_u7684_u7CBE_u786E_u5EA6_u95EE_u9898"><a href="#u5C0F_u6570_u8F6C_u6362_u7684_u7CBE_u786E_u5EA6_u95EE_u9898" class="headerlink" title="小数转换的精确度问题"></a>小数转换的精确度问题</h4><p>比如0.1%的精度，其实就是问<code>0.001*R^n &gt;=1</code>,n就是要求的位数</p>
<p><strong>以8进制为例</strong></p>
<pre><code>0.001*8^3 = 0.512 &lt;1
0.001*8^4 = 4.069 &gt;1
</code></pre><p>精度要求0.001时候，8进制小数转换需要4位</p>
<h3 id="BCD_u7801"><a href="#BCD_u7801" class="headerlink" title="BCD码"></a>BCD码</h3><p>其实就是<strong><em>二进制（B，binary）-十进制（D，decimal）码（code）</em></strong>，用2进制表示10进制，但是坑爹的是BCD码并不一定要<code>0000</code>对应<code>0</code>，<code>0101</code>对应<code>5</code>，它可以乱来，所以把这个code记成密码理解起来简单一点。</p>
<p>因为10进制一位数有0~9，一共10种变化，所以需要二进制里用4（<code>2^4 = 16 &gt;10</code>）来对应</p>
<h4 id="u6709_u6743_u7801"><a href="#u6709_u6743_u7801" class="headerlink" title="有权码"></a>有权码</h4><p>有权码的意思是四位2进制码每一位都有特定的权值，蛮简单的，计算方法就是按权值计算，然后加起来</p>
<ul>
<li><strong>8421码</strong>    也就是普通的二进制，1001的计算方法是 <code>1001（2）= 1*8+0*4+0*2+1*1 = 9</code></li>
<li><strong>2421码</strong>    这个的好处是可以直观判断<code>1111</code>就是<code>9</code>，1001的计算方法是 <code>1001（2）= 1*2+0*4+0*2+1*1 = 3</code></li>
</ul>
<h4 id="u65E0_u6743_u7801"><a href="#u65E0_u6743_u7801" class="headerlink" title="无权码"></a>无权码</h4><p>无权码不能通过加权计算，但是其实也不难</p>
<ul>
<li><strong>余3码</strong> 本质是每个8421码+3（0011）得到，比如<code>0 = 0000（8421） = 0011（余3码）</code></li>
</ul>
<h3 id="u7B97_u672F_u8FD0_u7B97"><a href="#u7B97_u672F_u8FD0_u7B97" class="headerlink" title="算术运算"></a>算术运算</h3><p>本质上来说和之前的运算没有任何区别</p>
<ul>
<li><strong>二进制加法</strong> <code>1001+0110 = 1111</code></li>
<li><strong>二进制减法</strong> <code>1001-0110 = 0011</code></li>
<li><strong>二进制乘法</strong> <code>1001*0110 = 0000+10010+100100+0000000 = 110110</code> </li>
<li><strong>二进制除法</strong> <code>1001/0110 -&gt; 0110（1）-&gt;0(0.1) = 1.1</code> 箭头后为相减后余数移位的数值，括号中为产生的一位结果。</li>
</ul>
<h2 id="u903B_u8F91_u51FD_u6570_u53CA_u5176_u7B80_u5316"><a href="#u903B_u8F91_u51FD_u6570_u53CA_u5176_u7B80_u5316" class="headerlink" title="逻辑函数及其简化"></a>逻辑函数及其简化</h2><h3 id="u7B80_u5355_u903B_u8F91_u89E3_u91CA"><a href="#u7B80_u5355_u903B_u8F91_u89E3_u91CA" class="headerlink" title="简单逻辑解释"></a>简单逻辑解释</h3><ul>
<li><strong>与</strong> P = A·B</li>
<li><strong>或</strong> P = A+B</li>
<li><strong>非</strong> P = ¬A</li>
<li><strong>与非</strong> P = ¬(A·B)</li>
<li><strong>或非</strong> P = ¬(A+B)</li>
<li><strong>同或⊙</strong> P = ¬A·¬B+A·B(相同为真)</li>
<li><strong>异或⊕</strong> P = ¬A·B+A·¬B(相异为真)</li>
</ul>
<h3 id="u771F_u503C_u8868_u4E0E_u903B_u8F91_u51FD_u6570"><a href="#u771F_u503C_u8868_u4E0E_u903B_u8F91_u51FD_u6570" class="headerlink" title="真值表与逻辑函数"></a>真值表与逻辑函数</h3><h4 id="u771F_u503C_u8868"><a href="#u771F_u503C_u8868" class="headerlink" title="真值表"></a>真值表</h4><p>大概就是这个玩意</p>
<table>
<thead>
<tr>
<th>A</th>
<th style="text-align:center">B</th>
<th style="text-align:right">P</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">0</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>0</td>
<td style="text-align:center">1</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">1</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">1</td>
<td style="text-align:right">1</td>
</tr>
</tbody>
</table>
<ul>
<li>可以用<strong>真值表</strong>来证明逻辑函数相等</li>
</ul>
<h4 id="u903B_u8F91_u89C4_u5219"><a href="#u903B_u8F91_u89C4_u5219" class="headerlink" title="逻辑规则"></a>逻辑规则</h4><h5 id="u903B_u8F91_u8BA1_u7B97_u89C4_u5F8B"><a href="#u903B_u8F91_u8BA1_u7B97_u89C4_u5F8B" class="headerlink" title="逻辑计算规律"></a>逻辑计算规律</h5><p>普通规律</p>
<ul>
<li><strong>分配律</strong> 特别注意的是 <code>A+BC = (A+B)(A+C)</code></li>
<li><strong>结合律</strong> 每种都支持</li>
<li><strong>交换律</strong> 每种都支持</li>
</ul>
<hr>
<p>特殊规则</p>
<ul>
<li><strong>反演律1</strong> <code>¬(A+B)=¬A·¬B</code></li>
<li><strong>反演律2</strong> <code>¬(AB)=¬A+¬B</code></li>
</ul>
<h5 id="u4EE3_u5165_u89C4_u5219"><a href="#u4EE3_u5165_u89C4_u5219" class="headerlink" title="代入规则"></a>代入规则</h5><p>讲逻辑等式中任何一种(比如全部的A)替换成任意一种逻辑函数，等式依然成立</p>
<pre><code>A+BC = (A+B)(A+C)

//A替换为(D+E)
D+E+BC = (D+E+B)(D+E+C)
</code></pre><h5 id="u53CD_u6F14_u89C4_u5219"><a href="#u53CD_u6F14_u89C4_u5219" class="headerlink" title="反演规则"></a>反演规则</h5><p>将逻辑函数中所有的<code>·</code>替换为<code>+</code>，所有的<code>+</code>替换为<code>·</code>;所有的<code>0</code>替换为<code>1</code>，所有的<code>1</code>替换为<code>2</code>;所有的<code>原变量</code>替换为<code>反变量</code>，所有的<code>反变量</code>替换为<code>原变量</code></p>
<p>要注意的是</p>
<ol>
<li><strong>原来的变量计算先后顺序关系不变</strong></li>
<li><p><strong>只替换原变量和反变量，不要把不作用于变量的取反也变了</strong></p>
<p> //例子1<br> F = ¬A¬B+CD<br> ¬F = (A+B)(¬C+¬D)</p>
<p> //例子2，这个解释了两个注意点，最好在反演之前把所有先后顺序都用括号打起来<br> F = ¬(A+B)<br> ¬F = ¬(¬A·¬B)</p>
</li>
</ol>
<h5 id="u5BF9_u5076_u89C4_u5219"><a href="#u5BF9_u5076_u89C4_u5219" class="headerlink" title="对偶规则"></a>对偶规则</h5><p>这就比反演规则少以一条，变量不用取反，但是还是要小心</p>
<h4 id="u5E38_u7528_u516C_u5F0F"><a href="#u5E38_u7528_u516C_u5F0F" class="headerlink" title="常用公式"></a>常用公式</h4><ol>
<li><code>AB+A¬B = A</code> </li>
<li><code>A+AB = A</code></li>
<li><code>A+¬AB = A+B</code> -&gt; <code>(A+¬A)(A+B)</code> -&gt;<code>1·(A+B)</code></li>
<li><code>AB+¬AC+BC = AB+¬AC</code></li>
<li><code>AB+¬AC = (A+C)(¬A+B)</code></li>
</ol>
<h4 id="u903B_u8F91_u51FD_u6570_u7684_u6807_u51C6_u5F62_u5F0F"><a href="#u903B_u8F91_u51FD_u6570_u7684_u6807_u51C6_u5F62_u5F0F" class="headerlink" title="逻辑函数的标准形式"></a>逻辑函数的标准形式</h4><h4 id="u4E94_u79CD_u7B49_u4EF7_u5F62_u5F0F"><a href="#u4E94_u79CD_u7B49_u4EF7_u5F62_u5F0F" class="headerlink" title="五种等价形式"></a>五种等价形式</h4><ol>
<li>与或表达式</li>
<li>由(1)对偶两次</li>
<li>由(1)两次取反</li>
<li>由(2)两次反演</li>
<li>由(4)反演</li>
</ol>
<h4 id="u6700_u5C0F_u9879_u3001_u6700_u5927_u9879_u8868_u8FBE_u5F0F"><a href="#u6700_u5C0F_u9879_u3001_u6700_u5927_u9879_u8868_u8FBE_u5F0F" class="headerlink" title="最小项、最大项表达式"></a>最小项、最大项表达式</h4><h5 id="u6700_u5C0F_u9879_u8868_u8FBE_u5F0F"><a href="#u6700_u5C0F_u9879_u8868_u8FBE_u5F0F" class="headerlink" title="最小项表达式"></a>最小项表达式</h5><ul>
<li><p><strong>符号</strong> ∑m(1,2,3,4)</p>
</li>
<li><p><strong>编号意义</strong> 最小项为1时候的取值</p>
</li>
<li><p><strong>最小项</strong> 包含全部输入变量的乘积项</p>
</li>
<li><p><strong>最小项表达式</strong> 全部由最小项相加构成的与-或表达式</p>
</li>
</ul>
<p>长这样:<code>ABC+AB¬C+¬ABC</code></p>
<p>包含全部变量的乘积项等于1的可能性最小</p>
<p><strong>方法:</strong></p>
<ol>
<li>找到每个乘积项的缺省元素</li>
<li>一扩二，比如<code>AB</code>差个<code>C</code>，那么就是变成<code>ABC+AB¬C</code></li>
<li>合并相同项</li>
</ol>
<h5 id="u6700_u5927_u9879_u8868_u8FBE_u5F0F"><a href="#u6700_u5927_u9879_u8868_u8FBE_u5F0F" class="headerlink" title="最大项表达式"></a>最大项表达式</h5><ul>
<li><p><strong>符号</strong> ∏m(1,2,3,4)</p>
</li>
<li><p><strong>编号意义</strong> 最大项为0时候的取值</p>
</li>
<li><p><strong>最大项</strong> 包含全部输入变量的乘积项</p>
</li>
<li><p><strong>最大项表达式</strong> 全部由最小项相加构成的或-与表达式</p>
</li>
</ul>
<p>长这样:<code>(A+B+C)(A+B+¬C)</code></p>
<p><strong>方法:</strong></p>
<ol>
<li>找到每个乘积项的缺省元素</li>
<li>一扩二，比如<code>A+C</code>差个<code>B</code>，那么就是变成<code>(A+B¬B+C)</code></li>
<li>？</li>
</ol>
<h5 id="u6700_u5927_u9879_u8868_u8FBE_u5F0F_u4E0E_u6700_u5C0F_u9879_u8868_u8FBE_u5F0F_u5173_u7CFB"><a href="#u6700_u5927_u9879_u8868_u8FBE_u5F0F_u4E0E_u6700_u5C0F_u9879_u8868_u8FBE_u5F0F_u5173_u7CFB" class="headerlink" title="最大项表达式与最小项表达式关系"></a>最大项表达式与最小项表达式关系</h5><p>F(A,B,C) = ∑m(1,2,3,4) = ∏M(5,6,7,8) 互补</p>
<h4 id="u51FD_u6570_u5316_u7B80"><a href="#u51FD_u6570_u5316_u7B80" class="headerlink" title="函数化简"></a>函数化简</h4><p><strong>几个函数关系转换</strong></p>
<p>F = ∑m(1,3,6,9,10,14)</p>
<p>//取F得空<br>¬F = ∑m(0,2,4,5,7,8,10,11,12,13,15)</p>
<p>//¬F每一位被最高位减<br>F* = ∑m(15,13,11,10,8,7,5,4,3,2,0)</p>
<h5 id="u516C_u5F0F_u6CD5"><a href="#u516C_u5F0F_u6CD5" class="headerlink" title="公式法"></a>公式法</h5><p>合并项法<code>AB+A¬B = A</code></p>
<p>吸收法 1. <code>A+AB=A</code> 2. <code>AB+¬AC+BC=AB+¬AC</code></p>
<p>消去法<code>A+¬AB=A+B</code></p>
<p>配项法 1. 乘以<code>(A+¬A)</code>然后展开 2. 利用<code>AB+¬AC=AB+¬AC+BC</code>增加BC</p>
<h5 id="u5361_u8BFA_u56FE"><a href="#u5361_u8BFA_u56FE" class="headerlink" title="卡诺图"></a>卡诺图</h5><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">00</th>
<th style="text-align:center">01</th>
<th style="text-align:center">11</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>步骤:</p>
<ol>
<li>将函数化为最小项表达式</li>
<li>填进卡诺图</li>
<li>画圈消去互为反变量的因子</li>
</ol>
<p>上面那个图的答案就应该是 <strong><code>BC¬D+¬BCD</code></strong></p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1N0s1t2t461j2H0V0E0p/QQ20160920-1@2x.png?v=c779a9cf" alt=""></p>
<p><strong>约束条件∑d(2,4)就是在对应位置画X，X可以看1或者0</strong></p>
<p><strong>如果是最大限表达式的话，就圈0</strong></p>
<h5 id="u5217_u8868_u6CD5"><a href="#u5217_u8868_u6CD5" class="headerlink" title="列表法"></a>列表法</h5><p>这个很简单，就是拿一张表，将变量所有的组合方式产生的结果填入表中，然后按照最小项表达式写出来就ok了，这个一般用来验证对错。</p>
<p>例子:</p>
<p>求<code>P = (A+¬B)(A+¬BC)</code>的化简</p>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">P</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h2 id="u903B_u8F91_u7535_u8DEF"><a href="#u903B_u8F91_u7535_u8DEF" class="headerlink" title="逻辑电路"></a>逻辑电路</h2><h3 id="u7EC4_u5408_u7535_u8DEF_u5206_u6790"><a href="#u7EC4_u5408_u7535_u8DEF_u5206_u6790" class="headerlink" title="组合电路分析"></a>组合电路分析</h3><ul>
<li><strong>组合电路:</strong> 输出之和输入有关</li>
<li><strong>时序电路:</strong> 输出和原状态+输入有关，有记忆功能</li>
</ul>
<ol>
<li>逻辑电路图逐级写出输出端逻辑表达式</li>
<li>化简和变换（不必要）</li>
<li>写出真值表</li>
<li>分析真值表或者逻辑表达式，概括功能</li>
</ol>
<h4 id="u5168_u52A0_u5668"><a href="#u5168_u52A0_u5668" class="headerlink" title="全加器"></a>全加器</h4><p>作用就是两个二进制数相加并求出和</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0U2E2E0o3j3d063Q2i0q/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-11%20%E4%B8%8B%E5%8D%886.52.23.png?v=52009a0f" alt=""></p>
<h4 id="u7F16_u7801_u5668"><a href="#u7F16_u7801_u5668" class="headerlink" title="编码器"></a>编码器</h4><p>普通编码器：只允许输入一个有效信号<br>优先编码器：可输入多个，只对优先级最高的编码</p>
<h5 id="8-3_u7F16_u7801_u5668"><a href="#8-3_u7F16_u7801_u5668" class="headerlink" title="8-3编码器"></a>8-3编码器</h5><p>ST位有效的情况下，输入某位为0，输出就应该是这个数二进制的反</p>
<p>例如</p>
<ol>
<li>想要输入<code>6(xxxxxx01)</code></li>
<li>输出就应该是<code>001(N2N1N0)</code></li>
</ol>
<p><strong>输入有圆圈或三角表示以低电平为有效</strong></p>
<p>0为有效，1无效</p>
<h4 id="u8BD1_u7801_u5668"><a href="#u8BD1_u7801_u5668" class="headerlink" title="译码器"></a>译码器</h4><p>编码的逆过程</p>
<p>输入5，输出位Y5为0，其他为1</p>
<h4 id="u6570_u636E_u9009_u62E9_u5668"><a href="#u6570_u636E_u9009_u62E9_u5668" class="headerlink" title="数据选择器"></a>数据选择器</h4><p>Y信号是源信号，A为控制信号，D为输出信号</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3o2N32240j3H1s181N2b/屏幕快照%202016-11-07%20上午11.38.18.png?v=15310754" alt=""></p>
<h3 id="u7EC4_u5408_u903B_u8F91_u7535_u8DEF_u8BBE_u8BA1"><a href="#u7EC4_u5408_u903B_u8F91_u7535_u8DEF_u8BBE_u8BA1" class="headerlink" title="组合逻辑电路设计"></a>组合逻辑电路设计</h3><p>分析的逆过程</p>
<ol>
<li>概括功能</li>
<li>写出真值表、卡诺图</li>
<li>逻辑函数表达式</li>
<li>化简</li>
<li>优化变换</li>
<li>逻辑图</li>
</ol>
<h4 id="u6839_u636E_u771F_u503C_u8868_u5199_u903B_u8F91_u51FD_u6570_u8868_u8FBE_u5F0F"><a href="#u6839_u636E_u771F_u503C_u8868_u5199_u903B_u8F91_u51FD_u6570_u8868_u8FBE_u5F0F" class="headerlink" title="根据真值表写逻辑函数表达式"></a>根据真值表写逻辑函数表达式</h4><p>寻找所有最终值等于1的行</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3r3g0J3J1h0D2z3M0C30/屏幕快照%202016-11-07%20上午9.31.00.png?v=b7b7dc40" alt=""></p>
<h4 id="u903B_u8F91_u8868_u8FBE_u5F0F_u53D8_u6362_28_u53D8_u5316_u548C_u5316_u7B80_u901A_u7528_29"><a href="#u903B_u8F91_u8868_u8FBE_u5F0F_u53D8_u6362_28_u53D8_u5316_u548C_u5316_u7B80_u901A_u7528_29" class="headerlink" title="逻辑表达式变换(变化和化简通用)"></a>逻辑表达式变换(变化和化简通用)</h4><ol>
<li>原式两次取反</li>
<li>将每个模块看成单独变量</li>
<li>每个单独变量间+变·，·变+</li>
<li>第二条取反线按照+或·位置打断</li>
</ol>
<p><strong>示例</strong><img src="https://d17oy1vhnax1f7.cloudfront.net/items/001V2w1h3Y1o1j0k041i/屏幕快照%202016-11-07%20上午10.04.52.png?v=894ea218" alt=""></p>
<h4 id="u964D_u7EF4_u56FE_u6CD5"><a href="#u964D_u7EF4_u56FE_u6CD5" class="headerlink" title="降维图法"></a>降维图法</h4><p><strong>场景:</strong> 当输入端小于变量的时候，需要将一个变量降维</p>
<p>其实就是把要降唯的变量乘进去</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1G2h3G1n0F2q2Q0I3T0C/屏幕快照%202016-11-07%20下午12.06.05.png?v=535f2fdf" alt=""></p>
<h2 id="u65F6_u5E8F_u7535_u8DEF"><a href="#u65F6_u5E8F_u7535_u8DEF" class="headerlink" title="时序电路"></a>时序电路</h2><h3 id="u96C6_u6210_u89E6_u53D1_u5668"><a href="#u96C6_u6210_u89E6_u53D1_u5668" class="headerlink" title="集成触发器"></a>集成触发器</h3><p><strong>触发器</strong> 能保持状态的电路，时序电路的基本单位</p>
<h4 id="u72B6_u6001_u8F6C_u79FB_u771F_u503C_u8868"><a href="#u72B6_u6001_u8F6C_u79FB_u771F_u503C_u8868" class="headerlink" title="状态转移真值表"></a>状态转移真值表</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1x0w1o0j1G0U333q341e/QQ20161116-2@2x.png?v=00693e4b" alt=""></p>
<h4 id="u7279_u5F81_u65B9_u7A0B"><a href="#u7279_u5F81_u65B9_u7A0B" class="headerlink" title="特征方程"></a>特征方程</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0d411C0J15181M1v0409/屏幕快照%202016-11-16%20上午10.38.46.png?v=130a3fce" alt=""></p>
<h4 id="u72B6_u6001_u8F6C_u79FB_u56FE"><a href="#u72B6_u6001_u8F6C_u79FB_u56FE" class="headerlink" title="状态转移图"></a>状态转移图</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2w2T171j3y3T382f1u1W/屏幕快照%202016-11-16%20上午10.40.50.png?v=97367f62" alt=""></p>
<h4 id="R-S_u89E6_u53D1_u5668"><a href="#R-S_u89E6_u53D1_u5668" class="headerlink" title="R-S触发器"></a>R-S触发器</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3O1T293g3b3S0n340V0d/屏幕快照%202016-11-16%20上午8.43.35.png?v=b45e54eb" alt=""></p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2q2k452C1o3h1E403t3D/屏幕快照%202016-11-16%20上午8.31.59.png?v=c7bebe35" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">R</th>
<th style="text-align:center">S</th>
<th style="text-align:center">Q</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">不定</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">保持</td>
</tr>
</tbody>
</table>
<h4 id="u540C_u6B65R-S_u89E6_u53D1_u5668"><a href="#u540C_u6B65R-S_u89E6_u53D1_u5668" class="headerlink" title="同步R-S触发器"></a>同步R-S触发器</h4><p>CP = 0，触发器状态不变<br>CP = 1，Q = S</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3N3b2c0a200f2d3l3X31/屏幕快照%202016-11-16%20上午9.03.46.png?v=ee38a4ad" alt=""></p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1p2e3N3c3X181r0o2r3K/屏幕快照%202016-11-16%20上午8.51.55.png?v=bf61e5e3" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">R</th>
<th style="text-align:center">S</th>
<th style="text-align:center">Q</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">不定</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">保持</td>
</tr>
</tbody>
</table>
<h4 id="u4E3B_u4ECER-S_u89E6_u53D1_u5668"><a href="#u4E3B_u4ECER-S_u89E6_u53D1_u5668" class="headerlink" title="主从R-S触发器"></a>主从R-S触发器</h4><p><strong>下降沿触发</strong></p>
<ul>
<li><strong>CP=1时:</strong> 主触发器打开,RS信号输入到主触发器; 从触发器被封锁,保持原来状态。</li>
<li><strong>CP=由1变0时:</strong> 从触发器打开,<br>主触发器的状态写入从触发器。 主触发器被封锁, 此后, 输入R、 S不管如何变化, 主触发器的状态不变。</li>
<li><strong>CP=0时:</strong> 从触发器继续打开,主触发器继续封锁。</li>
</ul>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3N3b2c0a200f2d3l3X31/屏幕快照%202016-11-16%20上午9.03.46.png?v=ee38a4ad" alt=""></p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2g240h2N3A0u1918123D/0654D670-1611-4CCB-9D62-F8DF29F241D9.png?v=84c927d3" alt=""></p>
<h4 id="D_u89E6_u53D1_u5668"><a href="#D_u89E6_u53D1_u5668" class="headerlink" title="D触发器"></a>D触发器</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0v0g2J3z0v3K2J2U0U1J/QQ20161116-0@2x.png?v=9b4e3584" alt=""></p>
<h4 id="JK_u89E6_u53D1_u5668"><a href="#JK_u89E6_u53D1_u5668" class="headerlink" title="JK触发器"></a>JK触发器</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1k2B3C3B3O0h3b0M2i07/QQ20161116-1@2x.png?v=438f479c" alt=""></p>
<h4 id="T_u89E6_u53D1_u5668"><a href="#T_u89E6_u53D1_u5668" class="headerlink" title="T触发器"></a>T触发器</h4><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3C0D18360M3J2v312T3i/屏幕快照%202016-11-16%20上午10.29.57.png?v=319cdb1c" alt=""></p>
<h4 id="u4E3B_u4ECEJ-K_u89E6_u53D1_u5668"><a href="#u4E3B_u4ECEJ-K_u89E6_u53D1_u5668" class="headerlink" title="主从J-K触发器"></a>主从J-K触发器</h4><h4 id="u7EF4_u6301_u963B_u585ERS_u89E6_u53D1_u5668"><a href="#u7EF4_u6301_u963B_u585ERS_u89E6_u53D1_u5668" class="headerlink" title="维持阻塞RS触发器"></a>维持阻塞RS触发器</h4><p>0-&gt;1 时发生状态转移，其他时候保持不变</p>
<h4 id="u963B_u585E"><a href="#u963B_u585E" class="headerlink" title="阻塞"></a>阻塞</h4><h2 id="VHDL"><a href="#VHDL" class="headerlink" title="VHDL"></a>VHDL</h2><h3 id="u57FA_u672C_u8BED_u6CD5"><a href="#u57FA_u672C_u8BED_u6CD5" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> IEEE;</span><br><span class="line"><span class="keyword">USE</span> IEEE.STD_LOGIC_1164.<span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTITY</span> EXAMPLE <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span>(CLK: <span class="keyword">IN</span> <span class="typename">STD_LOGIC</span>;</span><br><span class="line">	OUTOBJECT: <span class="keyword">OUT</span> <span class="typename">STD_LOGIC</span>);</span><br><span class="line"><span class="keyword">END</span> EXAMPLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARCHITECTURE</span> A <span class="keyword">OF</span> EXAMPLE <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">PROCESS</span>(CLK,OUTOBJECT) <span class="keyword">IS</span></span><br><span class="line">   <span class="keyword">IF</span>(CLK<span class="attribute">'EVENT</span> <span class="keyword">AND</span> CLK=<span class="number">1</span>) <span class="keyword">THEN</span></span><br><span class="line">      OUTOBJECT &lt;= CLK;</span><br><span class="line">   <span class="keyword">ELSIF</span>(CLK<span class="attribute">'EVEN</span> <span class="keyword">AND</span> CLK=<span class="number">0</span>) <span class="keyword">THEN</span></span><br><span class="line">      OUTOBJECT &lt;= CLK;</span><br><span class="line">   <span class="keyword">ELSE</span> <span class="keyword">THEN</span></span><br><span class="line">      OUTOBJECT &lt;= CLK;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">PROCESS</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">ARCHITECTURE</span> A;</span><br></pre></td></tr></table></figure>
<h3 id="u91CD_u8981_u7684_u987A_u5E8F_u8BED_u53E5"><a href="#u91CD_u8981_u7684_u987A_u5E8F_u8BED_u53E5" class="headerlink" title="重要的顺序语句"></a>重要的顺序语句</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">ELSIF</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CASE</span>(STH) <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">"00"</span> =&gt;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">FOR</span> I <span class="keyword">IN</span> <span class="number">8</span> <span class="keyword">DOWNTO</span> <span class="number">0</span> <span class="keyword">LOOP</span></span><br><span class="line">TEMP:=TEMP <span class="keyword">XOR</span> <span class="typename">STRING</span>(I);</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">VARIABLE</span> STH:<span class="typename">STD_LOGIC_VECTOR</span>(<span class="number">3</span> DOWN <span class="keyword">TO</span> <span class="number">0</span>);</span><br><span class="line">STH:=<span class="string">"0000"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="u4F20_u7EDF_u548C_u73B0_u4EE3_u8BBE_u8BA1_u65B9_u6CD5_u7684_u6BD4_u8F83"><a href="#u4F20_u7EDF_u548C_u73B0_u4EE3_u8BBE_u8BA1_u65B9_u6CD5_u7684_u6BD4_u8F83" class="headerlink" title="传统和现代设计方法的比较"></a>传统和现代设计方法的比较</h3><p>以全加器为例</p>
<h4 id="u4F20_u7EDF_u65B9_u6CD5"><a href="#u4F20_u7EDF_u65B9_u6CD5" class="headerlink" title="传统方法"></a>传统方法</h4><ul>
<li>写真值表</li>
<li>画出卡诺图</li>
<li>写函数表达式</li>
<li>逻辑电路</li>
</ul>
<h2 id="u4F5C_u4E1A_u7B54_u6848"><a href="#u4F5C_u4E1A_u7B54_u6848" class="headerlink" title="作业答案"></a>作业答案</h2><h3 id="u7B2C_u4E00_u6B21_u4F5C_u4E1A"><a href="#u7B2C_u4E00_u6B21_u4F5C_u4E1A" class="headerlink" title="第一次作业"></a>第一次作业</h3><h4 id="1-1_285_29"><a href="#1-1_285_29" class="headerlink" title="1-1(5)"></a>1-1(5)</h4><p><strong>二进制转换十进制</strong> 101001.10010</p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3m00342r412C2h0G133C/Untitled%201.gif?v=716efcc5" alt=""></p>
<p>答案为 41.5625</p>
<h4 id="1-2_283_29"><a href="#1-2_283_29" class="headerlink" title="1-2(3)"></a>1-2(3)</h4><p><strong>十进制转二进制</strong> 12.34<br>101001.1001</p>
<p>这个要拆分成两部分</p>
<pre><code>12/2 = 6(0)/2 = 3(0)/2 = 1(1)/2 = 0(1) -&gt;1100

//为啥这个这么长还不给精度~~
0.34*2 = 0.68(0)*2 = 0.36(1)*2 = 0.72(0)*2 
= 0.44(1)*2 = 0.88(0)*2 = 0.76(1)*2 = 0.52(1)*2 = 0.04(1)//……不算了
-&gt;0.01010111
</code></pre><p>结果为: 1100.010101110000101000111101011100001010001111010111</p>
<h4 id="1-4_282_29"><a href="#1-4_282_29" class="headerlink" title="1-4(2)"></a>1-4(2)</h4><p><strong>完成数制转换</strong> 432.B7（16进制）</p>
<pre><code>//转2进制，注意这里的『432』是16进制的！！！！
432/2 = 219(0)/2 = 10C(1)/2 = 86(0)/2 = 43(0)/2 
= 21(1)/2 = 10(1)/2 =  8(0)/2 = 4(0)/2 = 2(0)/2 = 1(0)/2 = 0(1) -&gt; 10000110010

0.B7*2 = 0.6E(1)*2 = 0.DC(0)*2 = 0.B8(1)*2 = 0.7(1)*2 = 0.E(0)*2 = 0.C(1)*2 = 0.8(1)*2 = 0(1)
-&gt; 0.10110111
</code></pre><p>答案为 110110000.10110111</p>
<pre><code>//转8进制
432/8 = 86(2)    /8 = 10(6)/8 = 2(0)/8 = 0(2) -&gt;2062

0.B7*8 = 0.B8(5)*8 = 0.C(5)*8 = 0(6) 0-&gt;0.556
</code></pre><p>答案为 2062.556</p>
<h4 id="1-6_281_29"><a href="#1-6_281_29" class="headerlink" title="1-6(1)"></a>1-6(1)</h4><p><strong>完成数制转换</strong> 73.26（10进制）= ?(8421码)</p>
<pre><code>73/2 = 36(1)/2 = 18(0)/2 = 9(0)/2 = 4(1)/2 
= 2(0)/2 = 1(0)/2 = 0(1)  -&gt;1001001

0.26*2 = 0.52（0.52上面那道题碰到过，直接贴答案了）
-&gt;0.01000010100011110101110000101
</code></pre><p>答案为 1001001.01000010100011110101110000101</p>
<h4 id="2-1_281_29"><a href="#2-1_281_29" class="headerlink" title="2-1(1)"></a>2-1(1)</h4><p><strong>有a、b、c三个输入信号，如果三个输入信号均为0或其中一个为1时，输出信号Y=1，其余情况下，输出Y=0，写出逻辑表达式</strong></p>
<table>
<thead>
<tr>
<th>A</th>
<th style="text-align:center">B</th>
<th style="text-align:right">C</th>
<th style="text-align:right">Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">0</td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">0</td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>0</td>
<td style="text-align:center">1</td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>0</td>
<td style="text-align:center">0</td>
<td style="text-align:right">1</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">1</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>0</td>
<td style="text-align:center">1</td>
<td style="text-align:right">1</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">0</td>
<td style="text-align:right">1</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">1</td>
<td style="text-align:right">1</td>
<td style="text-align:right">0</td>
</tr>
</tbody>
</table>
<pre><code>Y = ¬A¬B¬C+A¬B¬C+¬AB¬C+¬A¬BC;
</code></pre><h4 id="2-3_284_29"><a href="#2-3_284_29" class="headerlink" title="2-3(4)"></a>2-3(4)</h4><p><strong>直接写出函数反函数表达式和对偶表达式</strong> </p>
<p><strong>F=AB+¬(CD)+¬(BC)+¬(¬D+¬CE+¬(B+E))</strong></p>
<pre><code>//反演
¬F = (¬A+¬B)·¬(¬C+¬D)·¬(¬B+¬C)·¬(D·¬(¬C+¬E)·¬(¬B·¬E))

//对偶
F* =(A·B)·¬(C+D)·¬(B+C)·¬(¬D·¬(C+E)·¬(B·E))
</code></pre><h4 id="2-4_282_29"><a href="#2-4_282_29" class="headerlink" title="2-4(2)"></a>2-4(2)</h4><p><strong>公式法证明等式</strong></p>
<p><strong>¬A¬C+¬A¬B+¬A¬C¬D+BC = ¬A+BC</strong></p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/3T323P1p1a1G3R0K3X2x/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-18%20%E4%B8%8B%E5%8D%881.03.43.png?v=235042c1" alt=""></p>
<h4 id="2-6_283_29"><a href="#2-6_283_29" class="headerlink" title="2-6(3)"></a>2-6(3)</h4><p><strong>公式法简化下列式子</strong></p>
<p><strong>F = A¬BC+¬A¬CD+A¬C</strong></p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2e012X2g0l1I2l2F2n0F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-18%20%E4%B8%8B%E5%8D%881.01.52.png?v=ed37e486" alt=""></p>
<p>这里只用了一个公式<code>A+¬AB = A+B</code></p>
<h3 id="u7B2C_u4E8C_u6B21_u4F5C_u4E1A"><a href="#u7B2C_u4E8C_u6B21_u4F5C_u4E1A" class="headerlink" title="第二次作业"></a>第二次作业</h3><h4 id="2-8_281_29"><a href="#2-8_281_29" class="headerlink" title="2-8(1)"></a>2-8(1)</h4><p><strong>用公式法化简</strong><br><strong>F = A¬BC+¬A¬CD+A¬C</strong></p>
<p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/2e012X2g0l1I2l2F2n0F/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-18%20%E4%B8%8B%E5%8D%881.01.52.png?v=ed37e486" alt=""></p>
<h4 id="2-8_284_29"><a href="#2-8_284_29" class="headerlink" title="2-8(4)"></a>2-8(4)</h4><h4 id="2-9_282_29"><a href="#2-9_282_29" class="headerlink" title="2-9(2)"></a>2-9(2)</h4><h4 id="2-9_286_29"><a href="#2-9_286_29" class="headerlink" title="2-9(6)"></a>2-9(6)</h4><h4 id="2-9_288_29"><a href="#2-9_288_29" class="headerlink" title="2-9(8)"></a>2-9(8)</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【翻译】Unity，Source 2，Unreal Engine4或者CryENGINE，我应该挑选哪种游戏引擎]]></title>
      <url>http://pengtianhao.com/2016/09/13/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91Unity,%20Source%202,Unreal%20Engine%204%E6%88%96%E8%80%85CryENGINE%E6%88%91%E5%BA%94%E8%AF%A5%E6%8C%91%E9%80%89%E5%93%AA%E7%A7%8D%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<blockquote>
<p>翻译自<a href="http://blog.digitaltutors.com/unity-udk-cryengine-game-engine-choose/" target="_blank" rel="external">digitaltutors.com</a>，版权归作者所有</p>
</blockquote>
<a id="more"></a>
<p>如果你想在全世界开发和发行你自己的游戏，在开始这次旅程之前有几个非常重要的事情需要考虑。你眼前有许多免费的游戏引擎适合你开发自己的游戏，但问题是你应该选择哪个？为了帮助你决定，我们这有四个极其强大的引擎，因此你可以比较和发现哪个适合你的需求。</p>
<p>在过去的几年洞中，有许多超棒的游戏引擎公开发布，给饥渴的独立开发者以开发那款萦绕于心游戏的机会。最著名的游戏引擎是<a href="http://unity3d.com/" target="_blank" rel="external">Unity</a>， <a href="https://www.unrealengine.com/products/unreal-engine-4" target="_blank" rel="external">Unreal Engine 4</a>和<a href="http://www.crytek.com/cryengine" target="_blank" rel="external">CryENGINE</a>。这所有三个引擎都极其强大并且每个都有自己的强项。为了帮助确定哪个能为我们的项目更好地服务，你需要问你自己：你计划制作哪种游戏？这是一个第一人称射击（FPS）？一个移动游戏？将要做成2D还是3D？</p>
<p>如果你计划发行这个游戏并获得大量的收入，你需要衡量每个引擎不同的授权费用来确定哪个符合你的预算。因为这四个引擎都相对便宜，在你准备售卖游戏的时候，就需要支付授权费、专利费用或者全部的两者。</p>
<h2 id="Source_2_u5F15_u64CE"><a href="#Source_2_u5F15_u64CE" class="headerlink" title="Source 2引擎"></a>Source 2引擎</h2><p>在GDC 2015（游戏开发者大会）<a href="http://www.valvesoftware.com/" target="_blank" rel="external">Valve公司</a> 有几个重大发布并且也许在游戏圈最重大的一个是<a href="http://blog.digitaltutors.com/valve-enters-game-engine-race-source-2/" target="_blank" rel="external">Source2游戏引擎的发布</a>。Source2游戏引擎是曾用于Valves公司最受欢迎的诸如<a href="http://blog.counter-strike.net/" target="_blank" rel="external">Counter-Strike: Source</a>和<a href="http://orange.half-life2.com/" target="_blank" rel="external">Half-Life 2</a> 上游戏和其他大量游戏引擎的继承者。在Valves的开发工具包中，Source2引擎作为次世代游戏引擎在过去的几年间被游戏开发者所热切期盼。在记者招待会中，Valve公司的Jay Stelly(Valve高级工程师，译者注)说『我们将让Source2引擎对内容开发者免费。它伴随着最近发布的Epic和Unity将会帮助PC平台维持作为内容程序首发平台的统治地位』。很明显Valve已经做好准备加入与Epic和Unity的游戏引擎竞赛，并且为游戏开发者提供更多选项。然而『对于内容开发者免费』这一说法依然模糊不清。是否仅仅对于正式开发团队亦或者所有人都属于『内容开发者』？</p>
<p>对于发布新引擎的确切日期，Valve还没有发出任何信息，只能确定的是Source引擎将在不久的将来发布。Jay Stelly也声称『通过Source2，我们专注于提升开发者的生产力。意识到用户产生内容的重要性，Source2引擎被设计为不仅仅供专业开发者使用，更使得玩家自己可以参与创建和开发他们最新换的游戏』。这个评论暗示Source2引擎不仅仅是一个为专业开发工作室设计的引擎，还会帮助那些使得Valve游戏如此受欢迎的业余爱好者和模组制作者。</p>
<p>我们已经向Valve索取更多关于Source2的信息，并且一旦得知更多关于这款即将到来的引擎的信息，我们将会在第一时间更新这篇文章。一件事情是已经确定的，Source2引擎将对于例如Unity和Unreal Engine等已有影响力的玩家来说会是一个强力的竞争者，并且就像 Jay Stelly 所暗示的那样，Source2引擎将会免费。</p>
<h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><p><a href="http://unity3d.com/" target="_blank" rel="external">Unity</a>游戏引擎提供了大量的功能和理解相对简单的界面。它的生存之道是跨平台整合能力，意味着游戏能够被快速和简单地部署在Android，iOS，Windows Phone 8和BlackBerry上，使得它成为了一个超棒的移动游戏开发引擎。它也有为终端开发的能力。然而如果你是一个新的开发者，有更多方法能够加入终端开发，因为你被要求获得终端SDK的权限，而这正是新的开发者倾向于不去做的。</p>
<p>Unity游戏引擎支持主流3D应用中的许多特性，例如<br><a href="http://www.digitaltutors.com/software/3ds-Max-tutorials" target="_blank" rel="external">3ds Max</a>，<a href="http://www.digitaltutors.com/software/Maya-tutorials" target="_blank" rel="external">Maya</a>，<a href="http://www.digitaltutors.com/software/Softimage-tutorials" target="_blank" rel="external">Softimage</a>，<a href="http://www.digitaltutors.com/software/CINEMA-4D-tutorials" target="_blank" rel="external">CINEMA 4D</a>，<a href="http://www.blender.org/" target="_blank" rel="external">Blender</a>以及更多，意味着它所支持的文件样例没有真正的约束。在最近的发行的Unity4.3中，也有原生2D支持，支持精灵和2D物理效果，使得它成为一个能够用于2D游戏开发的强力引擎。</p>
<p>然而，当引擎支持任何3D应用的集合的时候，它确实会遭受在引擎编辑器中许多编辑能力。<a href="http://www.digitaltutors.com/software/Unity-tutorials" target="_blank" rel="external">Unity</a>除了一些基础模块以外，没有真正的建模和建造功能，因此所有东西将需要在第三方3D应用中创建。然而它确实拥有一个巨大的<a href="https://www.assetstore.unity3d.com/" target="_blank" rel="external">资源库</a> 。其中有许多种资源可被下载或者购买（价格由资源作者决定）。</p>
<p>Unity有几种不同的授权费用。第一种是<a href="http://unity3d.com/get-unity" target="_blank" rel="external">专业版本</a>，售价1500美金或者75美金一个月，每平台/每销售位。Unity5免费个人版包含了和专业版本中的功能，包括分析器，物理阴影，反射探测以及更多。然而，为了拥有Unity5的使用资格，你必须是一个年入低于十万美金、资金低于十万美金的小工作室。要获取更多关于授权计划的信息，请访问<a href="http://unity3d.com/get-unity" target="_blank" rel="external">the Unity pricing</a> 页面。作为一个有追求的开发者这个警告不会对你构成任何问题，因为免费的Unity5个人版本更像是你需要的。</p>
<p>Unity是一个经常与移动游戏联系起来的游戏引擎，但是随着Unity5的发布，包含类似物理阴影、实时全球照明和HDR反射探测等新改进的新渲染系统已经在图形表达上有了巨大的进步。</p>
<p>很明显，他们已经参与到了与UE4和CryENGINE的次世代游戏引擎竞争当中，并且随着64位和WebGL的支持，Unity5提供了一些超棒的功能，使得它在游戏引擎中成为一个有力的竞争者。</p>
<h2 id="Unreal_Engine_4"><a href="#Unreal_Engine_4" class="headerlink" title="Unreal Engine 4"></a>Unreal Engine 4</h2><p><a href="https://www.unrealengine.com/products/unreal-engine-4" target="_blank" rel="external">Unreal Engine 4</a>(UE4，虚幻引擎)是Epic Game发布的全新游戏引擎，是UDK的继承者。UE4有一些难以想象的图形能力，包括先进的动态照明技术和能够在同一时间控制百万粒子的新粒子系统。作为一个3D和游戏艺术家，你看会对这个能力流口水。</p>
<p>因为UE4是UDK的继承者，重要的是需要记住引擎上有许多巨大的变化。如果你有任何UDK的开发经验，当你切换到这个新引擎的时候确实会有一些学习上的困难。这些改变虽然不坏，UE4高可用性让它对于新游戏开发者有更高的吸引力。</p>
<p>UE4的脚本语言有一个重大的变化。也许你已经知道了，UE已经不运行自己的脚本了。事实上，UE脚本已经完全被C++替代，并且Kismet（UE的可视化脚本系统）也被更加直观的Blueprint系统替代。</p>
<p>一个需要记住的重大事项是如果你想做为上一代终端做游戏，你可能没办法用UE4开发。现在为止，UE4游戏能够在PC，Mac，iOS，Android，Xbox One和PlayStation4上发布。能够在手机以及下一代终端开发，让你有能力制作拥有惊人物理效果或者简单的横版游戏，这是你的自由。就像之前提到的那样，决定引擎是否发布在下一代终端不是很重要，尤其对于有抱负的开发者，因为在每一个平台发布游戏都需要一个单独的授权和SDK，并且必须有认证记录来获取一个开发工具包。因此对于新开发者来说，移动和PC平台将更是一条更加普遍的路。</p>
<p>UE4最近售价从无论哪里发售都是19美金每月并且有5%的版税分成到现在<a href="http://blog.digitaltutors.com/unreal-engine-4-now-free-everyone/" target="_blank" rel="external">完全免费</a>，不收订购费用。</p>
<p>这很明显对于任何想要开始制作游戏的人来说是个重大利好。当然，5%的版税分成依然存在，但对于这样一个价格结构，对于有抱负的开发者来说真是开了一扇门。如果你在每个季度每个游戏赚3000美金以上，你将被要求交纳5%的版税费用。因此如果你有四个游戏，每个游戏每季度只赚2500美金，你将不必支付版税。</p>
<p>查询更多UE4的信息，请阅读我们的<a href="http://blog.digitaltutors.com/unreal-engine-4-powering-next-generation-games/" target="_blank" rel="external">in-depth post</a>。现在就开始浏览<a href="http://www.digitaltutors.com/tutorial/1609-Introduction-to-Unreal-Engine-4#overview" target="_blank" rel="external">Introduction to Unreal Engine 4</a>，并且开始开发游戏吧！</p>
<h2 id="CryENGINE"><a href="#CryENGINE" class="headerlink" title="CryENGINE"></a>CryENGINE</h2><p><a href="http://cryengine.com/features" target="_blank" rel="external">CryENGINE</a>是一个极其强大的引擎，第一次被用于<a href="http://en.wikipedia.org/wiki/Far_Cry" target="_blank" rel="external">Far Cry</a>（孤岛惊魂）的开发，由开发公司<a href="http://www.crytek.com/" target="_blank" rel="external">Crytek</a>设计。它被设计用于PC和终端的开发，包括PS4和Xbox One。拥有使用最先进技术的光照、逼真物理效果、先进动画技术和更多功能的CryENGINE，它的图形性能胜过Unity和UDK，但是和UE4平分秋色。最近用CryENGINE开发的游戏是<a href="http://cryengine.com/showcases/showcase?id=16" target="_blank" rel="external">Ryse: Son of Rome</a>(崛起：罗马之子)。与UDK、UE4相同的是，CryENGINE内部有直观和强大的等级设计功能。</p>
<p>然而因为CryENGINE是一个极其强大的游戏引擎，它确实需要克服一些困难才能进行高效地开发，并且如果你没有任何游戏开发经验的话，CryENGINE更难掌握。如果你不需要游戏拥有像<a href="http://cryengine.com/showcases/showcase?id=17" target="_blank" rel="external">Crysis 3</a>或者Ryse:Son of Rome那样的物理效果，最好选用其他用户体验更好地引擎。</p>
<p>CryENGINE和其他游戏引擎有略微不同的定价策略。为了获得使用权，你需要支付一个月10美金。因为它不像UE4或者Unity5那样完全免费，它不要求任何版权费用，所以你所有需要付出的就是9.9美金。取决于你的工作室或者队伍的规模，不需要支付版税会是一个巨大的好处。想要知道更多关于CryENGINE的信息和他们的收费计划，请访问<a href="http://cryengine.com/get-cryengine" target="_blank" rel="external">他们的网页</a>。</p>
<h2 id="u56E0_u6B64_u6211_u9002_u5408_u4EC0_u4E48_uFF1F"><a href="#u56E0_u6B64_u6211_u9002_u5408_u4EC0_u4E48_uFF1F" class="headerlink" title="因此我适合什么？"></a>因此我适合什么？</h2><p>所有这些游戏引擎对于你的游戏开发过程来说都是极好的。Unity是对于移动、2D、3D游戏来说很棒。UE4通过合理的5%收费，让你能够开发照片般真实的图形效果或者简单的2D横版游戏。CryENGINE也拥有惊人的图形能力和次世代平台功能，对于你的工作室来说收费比UE4更加有吸引力。</p>
<p>最终决定取决于你，哪个引擎和你的项目最相配。有一件事是已经确定的，你不缺引擎用。这个博文有助于帮助你决定和让你专注于最有意思的部分：创造你的游戏。如果你依然没法确定，把每个都尝试一遍，发现你用起来最舒服的那个。看下面的链接，获得每个游戏引擎强大的框架，并探索更多。</p>
<p><a href="http://www.digitaltutors.com/software/Unity-tutorials" target="_blank" rel="external">Unity tutorials</a></p>
<p><a href="http://www.digitaltutors.com/software/Unreal-Engine-tutorials" target="_blank" rel="external">Unreal Engine 4 tutorials</a> </p>
<p><a href="http://www.digitaltutors.com/software/CryENGINE-tutorials" target="_blank" rel="external">CryENGINE tutorials</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[资源搜索清单（备份用）]]></title>
      <url>http://pengtianhao.com/2016/09/01/%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2%E6%B8%85%E5%8D%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转自<a href="http://huai235.com" target="_blank" rel="external">坏235</a></p>
</blockquote>
<a id="more"></a>
<h2 id="u627E_u8D44_u6E90_u5229_u5668"><a href="#u627E_u8D44_u6E90_u5229_u5668" class="headerlink" title="找资源利器"></a>找资源利器</h2><p>去转盘网:<a href="http://www.quzhuanpan.com/" target="_blank" rel="external">http://www.quzhuanpan.com/</a><br>西林街：<a href="http://www.xilinjie.com/" target="_blank" rel="external">http://www.xilinjie.com/</a><br>小不点：<a href="http://www.xiaobd.net/" target="_blank" rel="external">http://www.xiaobd.net/</a><br>找文件：<a href="http://www.zhaofile.com/" target="_blank" rel="external">http://www.zhaofile.com/</a><br>呆木瓜：<a href="http://www.daimugua.com/" target="_blank" rel="external">http://www.daimugua.com/</a><br>爱挖盘：<a href="http://www.iwapan.com/" target="_blank" rel="external">http://www.iwapan.com/</a><br>网盘屋：<a href="http://wangpanwu.com/" target="_blank" rel="external">http://wangpanwu.com/</a><br>盘搜：<a href="http://www.pansou.com/" target="_blank" rel="external">http://www.pansou.com/</a><br>ok搜搜：<a href="http://www.oksousou.com/" target="_blank" rel="external">http://www.oksousou.com/</a><br>CiLiBaBa：<a href="http://www.cilibaba.com/" target="_blank" rel="external">http://www.cilibaba.com/</a><br>btBook：<a href="http://www.btwalk.com/" target="_blank" rel="external">http://www.btwalk.com/</a><br>bt樱桃：<a href="http://www.btyingtao.net/" target="_blank" rel="external">http://www.btyingtao.net/</a></p>
<h2 id="u5916_u6587_u4E66_u7C4D_uFF08_u6587_u732E_uFF09_u4E0B_u8F7D_u7F51_u7AD9"><a href="#u5916_u6587_u4E66_u7C4D_uFF08_u6587_u732E_uFF09_u4E0B_u8F7D_u7F51_u7AD9" class="headerlink" title="外文书籍（文献）下载网站"></a>外文书籍（文献）下载网站</h2><p>Book ZZ：<a href="http://bookzz.org/" target="_blank" rel="external">http://bookzz.org/</a><br>Free-Ebooks：<a href="http://www.free-ebooks.net" target="_blank" rel="external">http://www.free-ebooks.net</a><br>Bookboon：<a href="http://bookboon.com/en" target="_blank" rel="external">http://bookboon.com/en</a><br>ManyBooks：<a href="http://manybooks.net/" target="_blank" rel="external">http://manybooks.net/</a><br>SnipFiles：<a href="http://www.snipfiles.com/" target="_blank" rel="external">http://www.snipfiles.com/</a><br>Open Library：<a href="https://openlibrary.org/" target="_blank" rel="external">https://openlibrary.org/</a><br>Bookyards：<a href="http://www.bookyards.com/" target="_blank" rel="external">http://www.bookyards.com/</a></p>
<h2 id="u4E2D_u6587_u4E66_u7C4D_u4E0B_u8F7D_u7F51_u7AD9"><a href="#u4E2D_u6587_u4E66_u7C4D_u4E0B_u8F7D_u7F51_u7AD9" class="headerlink" title="中文书籍下载网站"></a>中文书籍下载网站</h2><p>钱氏藏书：    <a href="http://qscs.haotui.com/?fromuid=272" target="_blank" rel="external">http://qscs.haotui.com/?fromuid=272</a><br>大熊图书馆：    <a href="http://dxlibrary.haotui.com/bbs.php" target="_blank" rel="external">http://dxlibrary.haotui.com/bbs.php</a><br>读远：    <a href="http://www.readfar.com/" target="_blank" rel="external">http://www.readfar.com/</a><br>Bucee杂志馆：    <a href="http://bucee.net/" target="_blank" rel="external">http://bucee.net/</a><br>汉川草庐：    <a href="http://www.sidneyluo.net/index.html" target="_blank" rel="external">http://www.sidneyluo.net/index.html</a><br>起点中文：    <a href="http://i.qidian.com/" target="_blank" rel="external">http://i.qidian.com/</a><br>红袖添香：    <a href="http://www.hongxiu.com" target="_blank" rel="external">http://www.hongxiu.com</a><br>国学网：    <a href="http://www.guoxue.com/" target="_blank" rel="external">http://www.guoxue.com/</a><br>书同文古籍数据库：    <a href="http://guji.unihan.com.cn/" target="_blank" rel="external">http://guji.unihan.com.cn/</a></p>
<h2 id="u9AD8_u6E05_u7535_u5F71_u8D44_u6E90_u7F51_u7AD9"><a href="#u9AD8_u6E05_u7535_u5F71_u8D44_u6E90_u7F51_u7AD9" class="headerlink" title="高清电影资源网站"></a>高清电影资源网站</h2><p>天天美剧：<a href="http://www.ttmeiju.com/" target="_blank" rel="external">http://www.ttmeiju.com/</a><br>他来说电影网：<a href="http://www.talaishuo.com/" target="_blank" rel="external">http://www.talaishuo.com/</a><br>耐卡：<a href="http://bbs.ncar.cc/forum.php" target="_blank" rel="external">http://bbs.ncar.cc/forum.php</a><br>电影天堂：<a href="http://www.dytt8.net/" target="_blank" rel="external">http://www.dytt8.net/</a><br>MP4吧：<a href="http://www.mp4ba.com/" target="_blank" rel="external">http://www.mp4ba.com/</a><br>蓝影网：<a href="http://www.lanyingwang.com/" target="_blank" rel="external">http://www.lanyingwang.com/</a><br>80s： <a href="http://www.80s.tw/" target="_blank" rel="external">http://www.80s.tw/</a><br>Mp48 : <a href="http://www.mp48.com/" target="_blank" rel="external">http://www.mp48.com/</a><br>电影首发站：<a href="http://www.dysfz.net" target="_blank" rel="external">http://www.dysfz.net</a><br>资源共享：<a href="http://www.ed2000.com/" target="_blank" rel="external">http://www.ed2000.com/</a><br>电影港：<a href="http://www.dygang.com/" target="_blank" rel="external">http://www.dygang.com/</a><br>Diggbt： <a href="http://diggbt.me/" target="_blank" rel="external">http://diggbt.me/</a><br>Bt天堂：<a href="http://www.bttiantang.com/" target="_blank" rel="external">http://www.bttiantang.com/</a><br>字幕组：<a href="http://www.zimuzu.tv/" target="_blank" rel="external">http://www.zimuzu.tv/</a></p>
<h2 id="u795E_u7AD9_u7CFB_u5217"><a href="#u795E_u7AD9_u7CFB_u5217" class="headerlink" title="神站系列"></a>神站系列</h2><p>大软坊：<a href="http://app.hustonline.net/major" target="_blank" rel="external">http://app.hustonline.net/major</a><br>香当网：<a href="http://www.xiangdang.net/" target="_blank" rel="external">http://www.xiangdang.net/</a><br>Smallpdf：<a href="http://smallpdf.com/" target="_blank" rel="external">http://smallpdf.com/</a><br>processon：<a href="https://www.processon.com/" target="_blank" rel="external">https://www.processon.com/</a><br>Rainy Mood：<a href="http://www.rainymood.com/" target="_blank" rel="external">http://www.rainymood.com/</a><br>MSDN：<a href="http://www.itellyou.cn/" target="_blank" rel="external">http://www.itellyou.cn/</a></p>
<h2 id="u641E_u7B11_u9017_u6BD4_u7F51_u7AD9_u7CFB_u7C7B"><a href="#u641E_u7B11_u9017_u6BD4_u7F51_u7AD9_u7CFB_u7C7B" class="headerlink" title="搞笑逗比网站系类"></a>搞笑逗比网站系类</h2><p>内涵段子：<a href="http://neihanshequ.com/" target="_blank" rel="external">http://neihanshequ.com/</a><br>逗比匣子: <a href="http://www.doubixiazi.com/" target="_blank" rel="external">http://www.doubixiazi.com/</a><br>糗事百科：<a href="http://www.qiushibaike.com/" target="_blank" rel="external">http://www.qiushibaike.com/</a><br>捧腹网：<a href="http://www.pengfu.com/" target="_blank" rel="external">http://www.pengfu.com/</a><br>中文幽默王：<a href="http://www.haha365.com/" target="_blank" rel="external">http://www.haha365.com/</a><br>快乐麻花：<a href="http://www.mahua.com/" target="_blank" rel="external">http://www.mahua.com/</a><br>爱邪恶：<a href="http://www.ixiee.com/" target="_blank" rel="external">http://www.ixiee.com/</a><br>笑话网：<a href="http://www.ihuopo.com/" target="_blank" rel="external">http://www.ihuopo.com/</a></p>
<h2 id="u8003_u7814_u8D44_u6599_u76F8_u5173_u7F51_u7AD9"><a href="#u8003_u7814_u8D44_u6599_u76F8_u5173_u7F51_u7AD9" class="headerlink" title="考研资料相关网站"></a>考研资料相关网站</h2><p>考研圈：    <a href="http://www.zhuansoo.com/vbar/c/vc.html?id=19" target="_blank" rel="external">http://www.zhuansoo.com/vbar/c/vc.html?id=19</a><br>考试点社区: <a href="http://bbs.kaoshidian.com/resource" target="_blank" rel="external">http://bbs.kaoshidian.com/resource</a><br>考研论坛：<a href="http://download.bbs.kaoyan.com/" target="_blank" rel="external">http://download.bbs.kaoyan.com/</a><br>小木虫论坛：<a href="http://emuch.net/bbs/index.php" target="_blank" rel="external">http://emuch.net/bbs/index.php</a><br>传媒人网：<a href="http://www.chuanmeiren.cn/bbs/" target="_blank" rel="external">http://www.chuanmeiren.cn/bbs/</a></p>
<h2 id="u52A8_u6F2B_u8D44_u6E90_u7F51_u7AD9"><a href="#u52A8_u6F2B_u8D44_u6E90_u7F51_u7AD9" class="headerlink" title="动漫资源网站"></a>动漫资源网站</h2><p>Animation World Network：    <a href="http://www.awn.com/" target="_blank" rel="external">http://www.awn.com/</a><br>卡通酿造：    <a href="http://www.cartoonbrew.com/" target="_blank" rel="external">http://www.cartoonbrew.com/</a><br>皮克斯帝国：    <a href="http://pixarempire.com/" target="_blank" rel="external">http://pixarempire.com/</a><br>动漫花园：    <a href="http://share.dmhy.org" target="_blank" rel="external">http://share.dmhy.org</a><br>漫游BT：    <a href="http://share.popgo.org" target="_blank" rel="external">http://share.popgo.org</a><br>简单动漫：    <a href="http://www.36dm.com/" target="_blank" rel="external">http://www.36dm.com/</a><br>漫画书：    <a href="http://manhuashu.net/" target="_blank" rel="external">http://manhuashu.net/</a><br>旋风动漫：    <a href="http://bt.xfsub.com/" target="_blank" rel="external">http://bt.xfsub.com/</a></p>
<h2 id="u7535_u5F71_u8D44_u6E90_u8BBA_u575B_u7F51_u7AD9"><a href="#u7535_u5F71_u8D44_u6E90_u8BBA_u575B_u7F51_u7AD9" class="headerlink" title="电影资源论坛网站"></a>电影资源论坛网站</h2><p>百度云论坛：<a href="http://www.baiduyun.me/" target="_blank" rel="external">http://www.baiduyun.me/</a><br>首发论坛：<a href="http://www.mq11.com/" target="_blank" rel="external">http://www.mq11.com/</a><br>小兔子腾讯云：<a href="http://www.tengxunyun.me/" target="_blank" rel="external">http://www.tengxunyun.me/</a><br>黑影库：<a href="http://www.heiyingku.cn/" target="_blank" rel="external">http://www.heiyingku.cn/</a><br>360云盘论坛：    <a href="http://www.360yunpan.me/" target="_blank" rel="external">http://www.360yunpan.me/</a><br>蓝光电影论坛：<a href="http://www.1080.net/forum.php" target="_blank" rel="external">http://www.1080.net/forum.php</a><br>bt首发论坛：<a href="http://www.btshoufa.net/forum.php" target="_blank" rel="external">http://www.btshoufa.net/forum.php</a><br>西西站：<a href="http://www.xixizhan.com/" target="_blank" rel="external">http://www.xixizhan.com/</a></p>
<h2 id="u975E_u5E38_u5F3A_u5927_u7684_u7FFB_u8BD1_u5E73_u53F0"><a href="#u975E_u5E38_u5F3A_u5927_u7684_u7FFB_u8BD1_u5E73_u53F0" class="headerlink" title="非常强大的翻译平台"></a>非常强大的翻译平台</h2><p>CNKI翻译助手：    <a href="http://dict.cnki.net/" target="_blank" rel="external">http://dict.cnki.net/</a><br>句酷：    <a href="http://www.jukuu.com/" target="_blank" rel="external">http://www.jukuu.com/</a><br>词都：    <a href="http://www.dictall.com/" target="_blank" rel="external">http://www.dictall.com/</a><br>LINE Dictionary：<a href="http://ce.linedict.com/dict.html#/cnen/" target="_blank" rel="external">http://ce.linedict.com/dict.html#/cnen/</a><br>Glosbe：<a href="https://glosbe.com/" target="_blank" rel="external">https://glosbe.com/</a></p>
<h2 id="u516D_u4E2A_u7EAA_u5F55_u7247_u7CBE_u54C1_u7F51_u7AD9"><a href="#u516D_u4E2A_u7EAA_u5F55_u7247_u7CBE_u54C1_u7F51_u7AD9" class="headerlink" title="六个纪录片精品网站"></a>六个纪录片精品网站</h2><p>Ary Heaven：<a href="http://documentaryheaven.com/" target="_blank" rel="external">http://documentaryheaven.com/</a><br>Free DocumentAries：<a href="http://freedocumentaries.org/" target="_blank" rel="external">http://freedocumentaries.org/</a><br>Top DocumentaryFilm：    <a href="http://topdocumentaryfilms.com/" target="_blank" rel="external">http://topdocumentaryfilms.com/</a><br>District 7 Media：    <a href="http://www.district7media.net/main/" target="_blank" rel="external">http://www.district7media.net/main/</a><br>Citizen 4Film： <a href="https://citizenfourfilm.com/" target="_blank" rel="external">https://citizenfourfilm.com/</a><br>Documentary：<a href="http://documentaryaddict.com/" target="_blank" rel="external">http://documentaryaddict.com/</a></p>
<h2 id="u4E0B_u8F7D_u56FD_u5185_u5916_u6742_u5FD7_u7684_u8D44_u6E90_u7F51_u7AD9"><a href="#u4E0B_u8F7D_u56FD_u5185_u5916_u6742_u5FD7_u7684_u8D44_u6E90_u7F51_u7AD9" class="headerlink" title="下载国内外杂志的资源网站"></a>下载国内外杂志的资源网站</h2><p>高清杂志网：<a href="http://www.gqzzw.com/" target="_blank" rel="external">http://www.gqzzw.com/</a><br>PDF之家：<a href="http://www.pdfzj.com/" target="_blank" rel="external">http://www.pdfzj.com/</a><br>十月杂志网：<a href="http://shiyue.me/" target="_blank" rel="external">http://shiyue.me/</a></p>
<h2 id="u6709_u58F0_u8BFB_u7269_u7F51_u7AD9"><a href="#u6709_u58F0_u8BFB_u7269_u7F51_u7AD9" class="headerlink" title="有声读物网站"></a>有声读物网站</h2><p>天方听书：    <a href="http://www.tingbook.com/" target="_blank" rel="external">http://www.tingbook.com/</a><br>静雅思听：<a href="http://www.justing.com.cn/" target="_blank" rel="external">http://www.justing.com.cn/</a><br>书喇叭：    <a href="http://shulaba.com/" target="_blank" rel="external">http://shulaba.com/</a><br>爱听网：    <a href="http://www.aitingwang.com/" target="_blank" rel="external">http://www.aitingwang.com/</a><br>酷听网：    <a href="http://www.kting.cn/" target="_blank" rel="external">http://www.kting.cn/</a><br>家常读书：<a href="http://www.jiachangdushu.com" target="_blank" rel="external">http://www.jiachangdushu.com</a></p>
<h2 id="u65E7_u4E66_u4EA4_u6613_u7C7B_u7F51_u7AD9"><a href="#u65E7_u4E66_u4EA4_u6613_u7C7B_u7F51_u7AD9" class="headerlink" title="旧书交易类网站"></a>旧书交易类网站</h2><p>孔夫子旧书网：<a href="http://shop.kongfz.com/" target="_blank" rel="external">http://shop.kongfz.com/</a><br>布衣书局：<a href="http://www.booyee.com.cn/index.jsp" target="_blank" rel="external">http://www.booyee.com.cn/index.jsp</a><br>有路网：<a href="http://www.youlu.net/" target="_blank" rel="external">http://www.youlu.net/</a><br>中国旧书网：<a href="http://www.jiushu.cn/" target="_blank" rel="external">http://www.jiushu.cn/</a><br>天下旧书网：<a href="http://www.jiushu.net/" target="_blank" rel="external">http://www.jiushu.net/</a></p>
<h2 id="u514D_u8D39_u97F3_u6548_u8D44_u6E90_u7C7B_u7F51_u7AD9"><a href="#u514D_u8D39_u97F3_u6548_u8D44_u6E90_u7C7B_u7F51_u7AD9" class="headerlink" title="免费音效资源类网站"></a>免费音效资源类网站</h2><p>中国素材网音效库：<a href="http://www.sucai.com/duomeiti/yx/" target="_blank" rel="external">http://www.sucai.com/duomeiti/yx/</a><br>日本的音效库：<a href="http://koukaongen.com/" target="_blank" rel="external">http://koukaongen.com/</a><br>站长素材-音效：<a href="http://sc.chinaz.com/yinxiao/" target="_blank" rel="external">http://sc.chinaz.com/yinxiao/</a><br>Soundsnap：<a href="http://www.soundsnap.com/" target="_blank" rel="external">http://www.soundsnap.com/</a><br>Freeplay Music：<a href="http://www.freeplaymusic.com/" target="_blank" rel="external">http://www.freeplaymusic.com/</a><br>Ilovewavs：<a href="http://www.ilovewavs.com/" target="_blank" rel="external">http://www.ilovewavs.com/</a><br>Breakout：<a href="http://www.breakout4u.com/en/" target="_blank" rel="external">http://www.breakout4u.com/en/</a></p>
<h2 id="u6B4C_u8C31_u7B80_u8C31_u641C_u7D22_u4E0B_u8F7D_u7F51_u7AD9"><a href="#u6B4C_u8C31_u7B80_u8C31_u641C_u7D22_u4E0B_u8F7D_u7F51_u7AD9" class="headerlink" title="歌谱简谱搜索下载网站"></a>歌谱简谱搜索下载网站</h2><p>中国曲谱网：<a href="http://www.qupu123.com/" target="_blank" rel="external">http://www.qupu123.com/</a><br>大众曲谱：<a href="http://www.myscore.org/" target="_blank" rel="external">http://www.myscore.org/</a><br>简谱网：<a href="http://www.jianpu.cn/" target="_blank" rel="external">http://www.jianpu.cn/</a><br>搜谱：<a href="http://www.sooopu.com//" target="_blank" rel="external">http://www.sooopu.com//</a><br>找歌谱：<a href="http://www.zhaogepu.com/" target="_blank" rel="external">http://www.zhaogepu.com/</a><br>超低空：<a href="http://www.chaodikong.com/" target="_blank" rel="external">http://www.chaodikong.com/</a><br>谱天下：<a href="http://www.ptx123.com/" target="_blank" rel="external">http://www.ptx123.com/</a></p>
<h2 id="u5F71_u89C6_u540E_u671F_u6559_u7A0B_u7C7B_u7F51_u7AD9"><a href="#u5F71_u89C6_u540E_u671F_u6559_u7A0B_u7C7B_u7F51_u7AD9" class="headerlink" title="影视后期教程类网站"></a>影视后期教程类网站</h2><p>我要自学网：<a href="http://t.cn/hgWA5w" target="_blank" rel="external">http://t.cn/hgWA5w</a><br>翼虎网：<a href="http://t.cn/RhcgNMN" target="_blank" rel="external">http://t.cn/RhcgNMN</a><br>飞特网：<a href="http://t.cn/hbBHpZ" target="_blank" rel="external">http://t.cn/hbBHpZ</a><br>Videocopilot：<a href="http://www.videocopilot.net/" target="_blank" rel="external">http://www.videocopilot.net/</a><br>Vfxinfo：<a href="http://vfxinfo.net/" target="_blank" rel="external">http://vfxinfo.net/</a><br>BW Design：<a href="http://benwattsdesign.com/" target="_blank" rel="external">http://benwattsdesign.com/</a></p>
<h2 id="u514D_u8D39_u89C6_u9891_u7D20_u6750/_u6A21_u677F_u4E0B_u8F7D_u7F51_u7AD9"><a href="#u514D_u8D39_u89C6_u9891_u7D20_u6750/_u6A21_u677F_u4E0B_u8F7D_u7F51_u7AD9" class="headerlink" title="免费视频素材/模板下载网站"></a>免费视频素材/模板下载网站</h2><p>视崛：<a href="http://www.shij001.com/" target="_blank" rel="external">http://www.shij001.com/</a><br>92素材网：<a href="http://www.92sucai.com/" target="_blank" rel="external">http://www.92sucai.com/</a><br>新GG儿：<a href="http://www.newcger.com/" target="_blank" rel="external">http://www.newcger.com/</a><br>千图网：<a href="http://www.58pic.com/shipin/" target="_blank" rel="external">http://www.58pic.com/shipin/</a><br>39视频：<a href="http://www.39video.com/" target="_blank" rel="external">http://www.39video.com/</a><br>模板天空：<a href="http://www.mobantiankong.com/" target="_blank" rel="external">http://www.mobantiankong.com/</a><br>人人素材社区：<a href="http://www.rr-sc.com/?fromuid=201838" target="_blank" rel="external">http://www.rr-sc.com/?fromuid=201838</a></p>
<h2 id="Photoshop_u6559_u7A0B_u7F51_u7AD9"><a href="#Photoshop_u6559_u7A0B_u7F51_u7AD9" class="headerlink" title="Photoshop教程网站"></a>Photoshop教程网站</h2><p>我要自学网：<a href="http://www.51zxw.net/" target="_blank" rel="external">http://www.51zxw.net/</a><br>大师之路：<a href="http://99ut.blueidea.com/text/photoshop/basic/index.html" target="_blank" rel="external">http://99ut.blueidea.com/text/photoshop/basic/index.html</a><br>52photoshop：<a href="http://www.52photoshop.cn/" target="_blank" rel="external">http://www.52photoshop.cn/</a><br>PSDFAN：<a href="http://psd.fanextra.com/" target="_blank" rel="external">http://psd.fanextra.com/</a><br>Photoshop Tutorials：<a href="http://www.photoshoptutorials.ws/" target="_blank" rel="external">http://www.photoshoptutorials.ws/</a><br>PS Brushes：<a href="http://www.psbrushes.net/" target="_blank" rel="external">http://www.psbrushes.net/</a><br>ps联盟：<a href="http://www.68ps.com/" target="_blank" rel="external">http://www.68ps.com/</a></p>
<h2 id="u4E13_u4E1A_u5F71_u8BC4_u7C7B_u7F51_u7AD9"><a href="#u4E13_u4E1A_u5F71_u8BC4_u7C7B_u7F51_u7AD9" class="headerlink" title="专业影评类网站"></a>专业影评类网站</h2><p>时光网：<a href="http://www.mtime.com/community/" target="_blank" rel="external">http://www.mtime.com/community/</a><br>豆瓣电影：<a href="http://movie.douban.com/" target="_blank" rel="external">http://movie.douban.com/</a><br>烂番茄：<a href="http://www.rottentomatoes.com/" target="_blank" rel="external">http://www.rottentomatoes.com/</a><br>IMBD：<a href="http://www.imdb.com/" target="_blank" rel="external">http://www.imdb.com/</a><br>美国广播影评人协会：<a href="http://www.criticschoice.com/" target="_blank" rel="external">http://www.criticschoice.com/</a><br>纽约影评家协会：<a href="http://www.nyfcc.com/" target="_blank" rel="external">http://www.nyfcc.com/</a><br>Film：<a href="http://www.film.com/" target="_blank" rel="external">http://www.film.com/</a><br>GoodFil.ms：<a href="http://goodfil.ms/" target="_blank" rel="external">http://goodfil.ms/</a><br>Cinephilia：<a href="http://cinephilia.net/" target="_blank" rel="external">http://cinephilia.net/</a><br>IndieWire：<a href="http://www.indiewire.com/" target="_blank" rel="external">http://www.indiewire.com/</a></p>
<h2 id="u516C_u5F00_u8BFE_u7F51_u7AD9"><a href="#u516C_u5F00_u8BFE_u7F51_u7AD9" class="headerlink" title="公开课网站"></a>公开课网站</h2><p>网易公开课：<a href="http://open.163.com/" target="_blank" rel="external">http://open.163.com/</a><br>中国大学MOOC：<a href="http://www.icourse163.org/" target="_blank" rel="external">http://www.icourse163.org/</a><br>新浪公开课：<a href="http://open.sina.com.cn/" target="_blank" rel="external">http://open.sina.com.cn/</a><br>央视网–公开课：<a href="http://opencla.cntv.cn/" target="_blank" rel="external">http://opencla.cntv.cn/</a><br>爱课堂：<a href="http://www.icourses.cn/home/" target="_blank" rel="external">http://www.icourses.cn/home/</a><br>MOOC中国：<a href="http://www.mooc.cn/" target="_blank" rel="external">http://www.mooc.cn/</a><br>超星公开课：<a href="http://openv.chaoxing.com/" target="_blank" rel="external">http://openv.chaoxing.com/</a></p>
<h2 id="u5C0F_u8BED_u79CD_u7CFB_u5217_u5B66_u4E60_u8D44_u6E90"><a href="#u5C0F_u8BED_u79CD_u7CFB_u5217_u5B66_u4E60_u8D44_u6E90" class="headerlink" title="小语种系列学习资源"></a>小语种系列学习资源</h2><p>小语种入门：<a href="http://www.yingyurumen.com/" target="_blank" rel="external">http://www.yingyurumen.com/</a><br>小语种学习网：<a href="http://xyz.tingroom.com/" target="_blank" rel="external">http://xyz.tingroom.com/</a><br>其他小语种学习资源：<a href="http://www.cmzyk.com/h-nd-633.html" target="_blank" rel="external">http://www.cmzyk.com/h-nd-633.html</a></p>
<h2 id="u6CD5_u5F8B_u5B66_u4E60_u67E5_u8BE2"><a href="#u6CD5_u5F8B_u5B66_u4E60_u67E5_u8BE2" class="headerlink" title="法律学习查询"></a>法律学习查询</h2><p>天涯法律网：<a href="http://www.hicourt.gov.cn/law/default.asp" target="_blank" rel="external">http://www.hicourt.gov.cn/law/default.asp</a><br>中国法律信息网：<a href="http://law1.law-star.com/" target="_blank" rel="external">http://law1.law-star.com/</a><br>北大法律信息网：<a href="http://law.chinalawinfo.com/" target="_blank" rel="external">http://law.chinalawinfo.com/</a><br>法易网：<a href="http://so.148365.com/" target="_blank" rel="external">http://so.148365.com/</a><br>法律图书馆：<a href="http://www.law-lib.com/" target="_blank" rel="external">http://www.law-lib.com/</a></p>
<h2 id="u5176_u4ED6_u7CFB_u5217_u8D44_u6E90"><a href="#u5176_u4ED6_u7CFB_u5217_u8D44_u6E90" class="headerlink" title="其他系列资源"></a>其他系列资源</h2><p>学术网站大全：<a href="http://dir.cnki.net/" target="_blank" rel="external">http://dir.cnki.net/</a><br>10个LOGO资源站：<a href="http://www.uisdc.com/top-logo-design-resources" target="_blank" rel="external">http://www.uisdc.com/top-logo-design-resources</a><br>10个无版权限制的大图特供网站：<a href="http://www.uisdc.com/free-hd-picture-website" target="_blank" rel="external">http://www.uisdc.com/free-hd-picture-website</a><br>找工作必备网站大全：<a href="http://www.cmzyk.com/h-nd-j-79-4_5.html" target="_blank" rel="external">http://www.cmzyk.com/h-nd-j-79-4_5.html</a><br>查询国内外文献资料的实用网站：<a href="http://cmzyk.lofter.com/post/1cb13862_5cc54cb" target="_blank" rel="external">http://cmzyk.lofter.com/post/1cb13862_5cc54cb</a><br>财经类网站大全：<a href="http://www.cmzyk.com/h-nd-j-182-4_5.html" target="_blank" rel="external">http://www.cmzyk.com/h-nd-j-182-4_5.html</a><br>33个最值得读的世界级社科博客榜单：<a href="http://www.cmzyk.com/" target="_blank" rel="external">http://www.cmzyk.com/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UI Dynamics的简单应用]]></title>
      <url>http://pengtianhao.com/2016/08/29/UI%20Dynamics%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>UI Dynamics是基于 UIKit构建的，提供了一些与物理学有关的功能，一共有UIAttachmentBehavior，UICollisionBehavior，UIGravityBehavior，UIPushBehavior，UISnapBehavior五种效果</p>
</blockquote>
<a id="more"></a>
<h2 id="u91CD_u529B_u3001_u78B0_u649E_u6548_u679C"><a href="#u91CD_u529B_u3001_u78B0_u649E_u6548_u679C" class="headerlink" title="重力、碰撞效果"></a>重力、碰撞效果</h2><p>下面的例子可以实现label从空中掉落知道与地面碰撞停止的效果</p>
<pre><code>var animator = UIDynamicAnimator()
@IBOutlet weak var myLabel: UILabel!
override func viewDidLoad() {
    super.viewDidLoad();

    //向自己的view添加绘制者
    animator = UIDynamicAnimator(referenceView: self.view)

    //向label添加重力
    let gBehavior = UIGravityBehavior(items: [self.myLabel])
    animator.addBehavior(gBehavior)

    //向label添加碰撞，设定碰撞边界范围为view边界
    let aBehavior = UICollisionBehavior(items: [self.myLabel])
    aBehavior.translatesReferenceBoundsIntoBoundary = true
    animator.addBehavior(aBehavior)
}
</code></pre><h2 id="u6355_u6349_u6548_u679C"><a href="#u6355_u6349_u6548_u679C" class="headerlink" title="捕捉效果"></a>捕捉效果</h2><p>下面的例子可以实现label随着鼠标点击移动的效果</p>
<pre><code>var animator = UIDynamicAnimator()
@IBOutlet var tapped: UIView!
@IBOutlet weak var myLabel: UILabel!
override func viewDidLoad() {
    super.viewDidLoad();

    //向自己的view添加绘制者
    animator = UIDynamicAnimator(referenceView: self.view)
}

@IBAction func tapped(sender: AnyObject) {

    //获取点击在view中的坐标
    let tap = sender as! UITapGestureRecognizer
    let point = tap.locationInView(self.view)

    //因为点击多次的，所以要清除上一次的behavior
    self.animator.removeAllBehaviors()

    //向label添加吸附动作
    self.snap = UISnapBehavior(item: self.myLabel, snapToPoint: point)
    self.animator.addBehavior(snap!)
}
</code></pre><h2 id="u63A8_u52A8_u6548_u679C"><a href="#u63A8_u52A8_u6548_u679C" class="headerlink" title="推动效果"></a>推动效果</h2><p>下面例子可以实现推动效果</p>
<pre><code>var animator = UIDynamicAnimator()
@IBOutlet var tapped: UIView!
@IBOutlet weak var myLabel: UILabel!
var push: UIPushBehavior?

override func viewDidLoad() {
    super.viewDidLoad();
    animator = UIDynamicAnimator(referenceView: self.view)
}

@IBAction func tapped(sender: AnyObject) {

    let tap = sender as! UITapGestureRecognizer
    let point = tap.locationInView(self.view)

    self.animator.removeAllBehaviors()

    //mode可以有一次性的和持续推力
    self.push = UIPushBehavior(items: [self.myLabel], mode:UIPushBehaviorMode.Instantaneous)

    //设置动作的方向和力度
    push?.pushDirection = CGVectorMake(point.x,point.y)
    push?.magnitude = 1
    self.animator.addBehavior(push!)
}
</code></pre><h2 id="u5438_u9644_u6548_u679C"><a href="#u5438_u9644_u6548_u679C" class="headerlink" title="吸附效果"></a>吸附效果</h2><p>写代码的时候试图写: <code>self.attach?.attachedBehaviorType = UIAttachmentBehaviorType.Items</code>,后来发现是一个getonly类型</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Storyboard中使用约束布局]]></title>
      <url>http://pengtianhao.com/2016/08/28/Storyboard%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<blockquote>
<p>之前一直使用纯代码布局，但是现在发现使用storyboard布局更快，现在学习一下</p>
</blockquote>
<a id="more"></a>
<p>布局可以用纯代码布局，运用setFrame，不过要注意取消auto layout<br>如果是Storyboard布局，运用无论是iOS还是MacOS,在拖控件之后都需要建立约束</p>
<h2 id="u529F_u80FD_u6309_u952E"><a href="#u529F_u80FD_u6309_u952E" class="headerlink" title="功能按键"></a>功能按键</h2><div align="left"><br><br><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1S0U2t3O3k1R3u2e0v0T/QQ20160828-0@2x.png" alt=""><br><br><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1S3b30210a3T3E2e2121/QQ20160828-1@2x.png" alt=""><br><br><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1S0U2t3O3k1R3u2e0v0T/QQ20160828-0@2x.png" alt=""><br><br></div>

<hr>
<h2 id="u4E00_u4E2A_u5C0F_u4F8B_u5B50"><a href="#u4E00_u4E2A_u5C0F_u4F8B_u5B50" class="headerlink" title="一个小例子"></a>一个小例子</h2><h3 id="u6700_u540E_u6548_u679C"><a href="#u6700_u540E_u6548_u679C" class="headerlink" title="最后效果"></a>最后效果</h3><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0g0E2d3G440q0Z1O2W3n/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-28%20%E4%B8%8B%E5%8D%881.59.55.png?v=a194c595" alt=""></p>
<h3 id="u8981_u6C42"><a href="#u8981_u6C42" class="headerlink" title="要求"></a>要求</h3><ul>
<li>输入框随着窗口的拖动放大缩小</li>
<li>输入框上下左右距离窗口边缘有固定距离</li>
<li>输入框不能太小，宽高要有一个最小值</li>
<li>加减号按钮、button有相同且特定的宽高</li>
<li>加减号按钮、button按钮在同一水平线上</li>
<li>加号按钮的前端和输入框后端对齐</li>
<li>button按钮后端和输入框后端对齐</li>
<li>加减号、button按钮与窗口底边距离固定</li>
<li>加减号之间有固定距离</li>
<li>加减号和button按钮有最短距离</li>
</ul>
<h3 id="u89E3_u51B3_u65B9_u6848"><a href="#u89E3_u51B3_u65B9_u6848" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>输入框随着窗口的拖动放大缩小、输入框上下左右距离窗口边缘有固定距离</p>
<p>  //View<br>  bottom = Bordered Scroll View - Text View.bottom + 60<br>  Bordered Scroll View - Text View.leading = leading + 20<br>  trailing = Bordered Scroll View - Text View.trailing + 20<br>  Bordered Scroll View - Text View.top = top + 20</p>
</li>
<li><p>输入框不能太小，宽高要有一个最小值</p>
<p>  //TextField<br>  aspect = 2:1<br>  height ≥ 220</p>
</li>
<li><p>加减号按钮、button有相同且特定的宽高</p>
<p>  //addButton<br>  height = 20<br>  width = 13</p>
<p>  //removeButton<br>  height = 20<br>  width = 13</p>
<p>  //Button<br>  height = 20<br>  width = 69</p>
</li>
<li><p>加减号按钮、button按钮在同一水平线上</p>
<p>  //View<br>  addButton.centerY = removeButton.centerY<br>  addButton.centerY = Button.centerY</p>
</li>
<li><p>加号按钮的前端和输入框前端对齐</p>
<p>  //View<br>  addButton.leading = Text View.leading</p>
</li>
<li><p>button按钮后端和输入框后端对齐</p>
<p>  //View<br>  Bordered Scroll View - Text View.trailing = Button.trailing</p>
</li>
<li><p>加减号、button按钮与窗口底边距离固定</p>
<p>  //View<br>  addButton.top = Bordered Scroll View - Text View.bottom + 20</p>
</li>
<li><p>加减号之间有固定距离</p>
<p>  //View<br>  removeButton.leading = addButton.trailing + 20</p>
</li>
<li><p>加减号和button按钮有最短距离</p>
<p>  //View<br>  Button.leading ≥ removeButton.trailing + 40</p>
</li>
</ul>
<h3 id="u7EA6_u675F_u7ED3_u679C"><a href="#u7EA6_u675F_u7ED3_u679C" class="headerlink" title="约束结果"></a>约束结果</h3><p><img src="https://d17oy1vhnax1f7.cloudfront.net/items/1g0K1M1f0l2q1g1B3k0j/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-28%20%E4%B8%8B%E5%8D%882.00.13.png?v=81813200" alt=""><br><img src="https://d17oy1vhnax1f7.cloudfront.net/items/0R2F33160Y3r000K0m0x/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-28%20%E4%B8%8B%E5%8D%882.28.29.png?v=b22e0827" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cocoa学习笔记]]></title>
      <url>http://pengtianhao.com/2016/08/25/cocoa%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>学完Swift以后，顺便对Cocoa框架也进行一次梳理。虽然之前用oc写了不少项目，但是因为有点即学即用的感觉，并没有形成系统的认知，为后面的开发估计埋下了不少坑，现在就慢慢填吧</p>
</blockquote>
<a id="more"></a>
<h2 id="u5404_u79CD_u547D_u540D"><a href="#u5404_u79CD_u547D_u540D" class="headerlink" title="各种命名"></a>各种命名</h2><h3 id="Mac_OS"><a href="#Mac_OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><ul>
<li><strong>MacOS</strong> 原来叫OS X，后来改名</li>
<li><strong>Cocoa</strong> MacOS上使用的库</li>
<li><strong>AppKit.framework</strong> MacOS的框架，每个app都会用到</li>
<li><strong>myapp.app</strong> 软件包（myapp代指app名）</li>
<li><strong>Contents</strong> 包含了程序本身的文件夹</li>
<li><strong>Info.plist</strong> 描述该应用的文件，启动的时候先读它</li>
<li><strong>MacOS</strong> 包含app编译后的二进制文件 </li>
<li><strong>myapp</strong> 二进制文件</li>
<li><strong>PkgInfo</strong> 介绍app的制作者和app是做什么用的,没什么用</li>
<li><strong>Resources</strong> 包含了所有编译在内的资源文件</li>
</ul>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul>
<li><strong>Cocoa Touch</strong> iOS上使用的库</li>
<li><strong>UIKit.framework</strong> iOS的框架，每个app都会用到</li>
<li><strong>myapp</strong> 二进制文件（myapp代指app名）</li>
<li><strong>Info.plist</strong> 描述该应用的文件，启动的时候先读它</li>
</ul>
<h3 id="nib_2Cxib_2Cstoryboard_u7684_u533A_u522B"><a href="#nib_2Cxib_2Cstoryboard_u7684_u533A_u522B" class="headerlink" title="nib,xib,storyboard的区别"></a>nib,xib,storyboard的区别</h3><p>nib是3.0版本以前的产物，在终端下我们可以看到，NIB其实是一个文件夹，里面有可执行的二进制文件；网上查到，nib的全称是NEXT Interface Builder，是乔帮主之前创办的NEXT公司的东西<br>xib是一个基于xml的描述文件，可以实现可视化编程<br>storyboard是多个xib文件集合的描述文件，也采用xml格式</p>
<h2 id="NSBundle_u67E5_u627E_u8D44_u6E90"><a href="#NSBundle_u67E5_u627E_u8D44_u6E90" class="headerlink" title="NSBundle查找资源"></a>NSBundle查找资源</h2><p>bundle是一个目录,其中包含了程序会使用到的资源，如图像、声音、二进制文件、nib</p>
<h3 id="main_bundle"><a href="#main_bundle" class="headerlink" title="main bundle"></a>main bundle</h3><p>整个程序是一个bundle，它是一个包含了nib文件、编译代码以及其他资源的目录。这个目录叫做main bundle</p>
<p>得到main bundle很容易</p>
<pre><code>let myBudle = NSBundle.mainBundle()
</code></pre><p>之后就可以来查找资源</p>
<pre><code>let imagePath: NSString? = NSBundle.mainBundle().pathForResource(&quot;head&quot;, ofType: &quot;jpg&quot;)
</code></pre><h2 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><ol>
<li>打开<code>Info.plist</code>，获取二进制文件位置</li>
<li>打开nib文件，对窗口控件进行解包、链接</li>
<li>nib文件解包时发送<code>awakeFromNib</code>消息，但是不会发<code>init</code>，因为在拖入界面时候已经初始化了</li>
<li>发送<code>applicationDidFinishLaunching</code>消息，app开始执行</li>
<li>app被切换时候（MacOS鼠标点击其他软件、iOS按下home键）发送<code>applicatonWillResignActive</code>,真正消失的时候发送<code>applicationDidResignActive</code></li>
<li>当焦点又回到app时候，收到<code>applicationWillBecomeActive</code>，真正显示之后<code>applicationDidBecomeActive</code></li>
<li>在app真正要退出时候，收到<code>applicationWillTerminate</code>，这是最后一次保存数据的机会</li>
</ol>
<h3 id="iOS-1"><a href="#iOS-1" class="headerlink" title="iOS"></a>iOS</h3><p>iOS拥有以上的所有特性，但是因为屏幕每次只能显示一个app，所以又有了多任务的概念</p>
<ol>
<li>当app进入后台的时候，会发送<code>applicationWillEnterBackground</code>和<code>applicationDidEnterBackground</code></li>
<li>当app进入前台的时候，会发送<code>applicationWillEnterForeground</code>和<code>applicationDidEnterForeground</code></li>
</ol>
<p>app内存如果占用过大，那么当手机内存不够用的时候，就会被终止<br>但是app的内存占用如果在<strong> 16MB以下 </strong>，当挂起之后，会储存到闪存芯片中，唤醒的时候就会回到原来的状态，避免了被终止</p>
<h4 id="u6302_u8D77_u540E_u53F0_u8FD0_u884C"><a href="#u6302_u8D77_u540E_u53F0_u8FD0_u884C" class="headerlink" title="挂起后台运行"></a>挂起后台运行</h4><p>如果在进入后台之后还要做一些事情，比如保存大型文件，那么就要申请后台运行，不过只有十分钟的运行时间</p>
<pre><code>func applicationDidEnterBackground(application: UIApplication) {

    var backGroundTask: UIBackgroundTaskIdentifier? = nil

    //时间耗尽之后，执行这段代码
    backGroundTask = application.beginBackgroundTaskWithExpirationHandler(){
        application.endBackgroundTask(backGroundTask!)
        backGroundTask = UIBackgroundTaskInvalid
    }

    let backGroundQueue = NSOperationQueue()

    //在这里写执行的代码，然后必须endBackgroundTask
    backGroundQueue.addOperationWithBlock(){
        application.endBackgroundTask(backGroundTask!)
        backGroundTask = UIBackgroundTaskInvalid
    }

}
</code></pre><h4 id="u540E_u53F0_u5B9A_u65F6_u5524_u9192"><a href="#u540E_u53F0_u5B9A_u65F6_u5524_u9192" class="headerlink" title="后台定时唤醒"></a>后台定时唤醒</h4><p>有些应用，比如天气，需要定时唤醒一次获取信息，就需要后台定时唤醒，不过只有<strong> 30s </strong>的时间</p>
<pre><code>func application(application: UIApplication, performFetchWithCompletionHandler completionHandler: (UIBackgroundFetchResult) -&gt; Void) {
    // 这里可以进行获取数据等操作
}
</code></pre><p>当然也要告诉系统多久进行一次唤醒，在<code>didFinishLaunchingWithOptions</code>里写</p>
<pre><code>application.setMinimumBackgroundFetchInterval(UIApplicationBackgroundFetchIntervalMinimum)
</code></pre><h4 id="u540E_u53F0_u901A_u77E5"><a href="#u540E_u53F0_u901A_u77E5" class="headerlink" title="后台通知"></a>后台通知</h4><p>聊天应用等有得到推送的场景，接到推送之后会触发</p>
<pre><code>func application(application: UIApplication, didReceiveRemoteNotification userInfo: [NSObject : AnyObject]) {

}
</code></pre><p>得到一个字典</p>
<h4 id="u7528NSNotification_u8FDB_u884C_u81EA_u5B9A_u4E49_u901A_u77E5"><a href="#u7528NSNotification_u8FDB_u884C_u81EA_u5B9A_u4E49_u901A_u77E5" class="headerlink" title="用NSNotification进行自定义通知"></a>用NSNotification进行自定义通知</h4><p>当程序挂起的时候，我除了给<code>AppDelegate</code>发通知之外，还想给其他对想法通知，这时候可以用<code>NSNotification</code>来做到，这时<code>NSNotification</code>还可用来传值等，但是记得注册通知之后要销毁，还有传值用代理更好</p>
<p>首先在目标类(比如<code>ViewController.swift</code>)里写一个当通知来了以后执行的方法</p>
<pre><code>func whenNotificationCome(notification :NSNotification){

    if notification.userInfo != nil {
        //这里处理收到的notification
        NSLog(&quot;%@&quot;,notification.userInfo!)
    }

    //移除监听
    NSNotificationCenter.defaultCenter().removeObserver(self, name: &quot;myNotification&quot;, object: nil)

}
</code></pre><p>然后在初始化的地方注册接收通知</p>
<pre><code>NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;whenNotificationCome:&quot;, name: &quot;myNotification&quot;, object: nil)
</code></pre><p>然后这时候如果在程序进入前台的时候发送通知</p>
<pre><code>func applicationWillEnterForeground(application: UIApplication) {

    let myNotification = NSNotificationCenter.defaultCenter()

    let userInfo: NSDictionary = [&quot;123&quot;:&quot;123&quot;,&quot;1234&quot;:&quot;1234&quot;]

    myNotification.postNotificationName(&quot;myNotification&quot;, object: nil, userInfo:userInfo as [NSObject : AnyObject])
}
</code></pre><p>那当我进入按下home键后再打开app，就会打印出</p>
<pre><code>2016-08-27 13:32:19.193 Swift-iOSTest[2983:266380] {
    123 = 123;
    1234 = 1234;
}
</code></pre><h2 id="MVC_u8BBE_u8BA1_u6A21_u5F0F"><a href="#MVC_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p>MVC的全称是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。模型负责数据储存，视图呈现用户界面、接受输入和触摸等，控制器作为二者中介，提供操作逻辑</p>
<p>在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，对应MVC中的V。UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。</p>
<h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><h3 id="Storyboard"><a href="#Storyboard" class="headerlink" title="Storyboard"></a>Storyboard</h3><p>Storyboard是一组通过<code>segue</code>链接的<code>viewController</code></p>
<h4 id="segue_u8DF3_u8F6C"><a href="#segue_u8DF3_u8F6C" class="headerlink" title="segue跳转"></a>segue跳转</h4><p>当需要跳转的时候，就先拉线建立连接，写identifier,然后在<code>viewController</code>里写</p>
<pre><code>self.performSegueWithIdentifier(&lt;#T##identifier: String##String#&gt;, sender: &lt;#T##AnyObject?#&gt;)
</code></pre><p>在跳转之前也可以通过写</p>
<pre><code>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {

}
</code></pre><p>来为跳转做准备，通常可以用<code>setObject</code>来为下一个页面传值，我以前写oc的时候喜欢这么写</p>
<pre><code>-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{
    if ([segue.identifier isEqualToString:@&quot;wantJump&quot;]) {
        UIViewController* view = segue.destinationViewController;
        [view setValue:strArea forKey:@&quot;strArea&quot;];
        [view setValue:endArea forKey:@&quot;endArea&quot;];
        [view setValue:customizeId forKey:@&quot;customizeId&quot;];
    }else if ([segue.identifier isEqualToString:@&quot;historyJump&quot;]){
        UIViewController* view = segue.destinationViewController;
        [view setValue:strArea forKey:@&quot;strArea&quot;];
        [view setValue:endArea forKey:@&quot;endArea&quot;];
        [view setValue:customizeId forKey:@&quot;customizeId&quot;];
    }
}
</code></pre><h4 id="u7EA6_u675F"><a href="#u7EA6_u675F" class="headerlink" title="约束"></a>约束</h4><p>约束值得单独写一篇，这里是传送门</p>
<p><a href="http://pengtianhao.com/2016/08/28/Storyboard%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80/">Storyboard中使用约束布局</a></p>
<h3 id="UI_Dynamics"><a href="#UI_Dynamics" class="headerlink" title="UI Dynamics"></a>UI Dynamics</h3><p>这个库可以向UI里加入物理效果，丰富动画等，传送门</p>
<p><a href="http://pengtianhao.com/2016/08/29/UI%20Dynamics%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/">UI Dynamics的简单应用</a></p>
<h3 id="Core_Animation"><a href="#Core_Animation" class="headerlink" title="Core Animation"></a>Core Animation</h3><p><code>Core Animation</code>可以向控件添加动画效果。在它与<code>UI Dynamics</code>区别上，个人的理解是<code>UI dynamics</code>效果其实是预设好的，只不过能够设置一些参数，但是<code>Core Animation</code>可以更精确地把握，下面放传送门</p>
<p>&lt;待续&gt;</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift学习笔记]]></title>
      <url>http://pengtianhao.com/2016/08/14/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>趁着这段时间有空，准备学习Swift替换oc用于iOS开发，没想到遇到了不少坑，这边记录一下</p>
</blockquote>
<a id="more"></a>
<h2 id="sorted_u51FD_u6570"><a href="#sorted_u51FD_u6570" class="headerlink" title="sorted函数"></a>sorted函数</h2><p>Swift2.0以后，<code>sorted</code>好像从</p>
<pre><code>sorted(array,{$1&gt;$2}）
</code></pre><p>变成了</p>
<pre><code>var arraySorted = array.sort(false)
</code></pre><h2 id="for_u5FAA_u73AF"><a href="#for_u5FAA_u73AF" class="headerlink" title="for循环"></a>for循环</h2><p>这里遇到一个很奇怪的错误，当我写</p>
<pre><code>for var i = 0;i&lt;=3;i++{
    print(&quot;Hello world&quot;)
}
</code></pre><p>碰到了错误，直到修改为</p>
<pre><code>for var i = 0;i&lt;=3;i++ {
    print(&quot;Hello world&quot;)
}
</code></pre><p>或</p>
<pre><code>for var i = 0;i&lt;=3;++i{
    print(&quot;Hello world&quot;)
}
</code></pre><p>才正确</p>
<h2 id="enumerate_u65B9_u6CD5"><a href="#enumerate_u65B9_u6CD5" class="headerlink" title="enumerate方法"></a>enumerate方法</h2><p>enumerate方法以前用</p>
<pre><code>for (index, value) in enumerate(numbers) {
    print(&quot;Item \(index + 1): \(value)&quot;)
}
</code></pre><p>现在改成了</p>
<pre><code>for (index, value) in numbers.enumerate() {
    print(&quot;Item \(index + 1): \(value)&quot;)
}
</code></pre><h2 id="print_u65B9_u6CD5"><a href="#print_u65B9_u6CD5" class="headerlink" title="print方法"></a>print方法</h2><p>以前打印方法有两种，<code>print</code>和<code>println</code>，现在只有<code>print</code>，默认换行，如果要不换行的话要这么写</p>
<pre><code>print(&quot;这样就&quot;,terminator: &quot;&quot;);
print(&quot;不换行了&quot;)
</code></pre><p>结果为</p>
<pre><code>&quot;这样就&quot;
&quot;不换行了\n&quot;
</code></pre><h2 id="u6570_u7EC4"><a href="#u6570_u7EC4" class="headerlink" title="数组"></a>数组</h2><p>数组空白初始化时候，原来用</p>
<pre><code>var array = Int[]()
</code></pre><p>现在用</p>
<pre><code>var array = [Int]()
</code></pre><h2 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h2><h3 id="u5185_u5916_u53C2_u6570_u95EE_u9898"><a href="#u5185_u5916_u53C2_u6570_u95EE_u9898" class="headerlink" title="内外参数问题"></a>内外参数问题</h3><p>碰到一个很奇怪的问题，当我调用函数：</p>
<pre><code>func f4(firstValue: Int, secondValue: Int) -&gt;Int{
    return firstValue + secondValue
}
</code></pre><p>调用的时候必须用</p>
<pre><code>f4(1, secondValue: 2)
</code></pre><p>这个可能和内外命名有关，可能是<code>firstValue</code>被当成内部命名，还需要探索，完整写出内外命名就没问题</p>
<pre><code>func f6(firstValue first:Int,secondValue second: Int)-&gt;Int{
    return first+second
}

f6(firstValue: 1, secondValue: 2)
</code></pre><h3 id="inout_u53C2_u6570"><a href="#inout_u53C2_u6570" class="headerlink" title="inout参数"></a>inout参数</h3><p>以前写c/c++的时候，要用函数交换函数要用到地址</p>
<pre><code>void swapTwoValues(int &amp;x, int &amp;y){
    int temp = x;
    x = y;
    y = temp;
}
</code></pre><p>现在就要用到<code>inout</code>参数</p>
<pre><code>func swapTwoValues&lt;T&gt;(inout x: T, inout y: T) {
    let temp = x
    x = y
    y = temp
}
</code></pre><h3 id="u95ED_u5305"><a href="#u95ED_u5305" class="headerlink" title="闭包"></a>闭包</h3><p>闭包其实就是一种没有函数名的函数，哪里都能用</p>
<h4 id="u5173_u4E8Ein"><a href="#u5173_u4E8Ein" class="headerlink" title="关于in"></a>关于in</h4><p>闭包里<code>in</code>之前的东西相当于函数的输入和返回</p>
<pre><code>let numberWord = number.map{
    (var s1)-&gt;Int in
    let output = 123
    return output
}
</code></pre><p>等于</p>
<pre><code>func myFunc(s1: Int)-&gt;Int{
    let output = 123
    return output
}

let numberWord = number.map(myFunc)
</code></pre><h4 id="u5173_u4E8E_u95ED_u5305_u5B58_u5728_u6027"><a href="#u5173_u4E8E_u95ED_u5305_u5B58_u5728_u6027" class="headerlink" title="关于闭包存在性"></a>关于闭包存在性</h4><pre><code>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)

// 10
incrementByTen()
// 20
incrementByTen()

let anotherIncrement = incrementByTen

//30,赋值以后也指向同一闭包
anotherIncrement()
</code></pre><h2 id="u6BD4_u8F83_u7B26_u53F7"><a href="#u6BD4_u8F83_u7B26_u53F7" class="headerlink" title="比较符号"></a>比较符号</h2><p>他们返回的是布尔值</p>
<h2 id="u7C7B_u548C_u7ED3_u6784_u4F53"><a href="#u7C7B_u548C_u7ED3_u6784_u4F53" class="headerlink" title="类和结构体"></a>类和结构体</h2><p>因为在Swift里看起来差不多，就记一起了</p>
<h3 id="u5C5E_u6027"><a href="#u5C5E_u6027" class="headerlink" title="属性"></a>属性</h3><h4 id="get_u548Cset"><a href="#get_u548Cset" class="headerlink" title="get和set"></a>get和set</h4><p><code>get</code>和<code>set</code>使得属性之间能够自动关联</p>
<pre><code>class myCLass {
    var varies1: Int = 1
    var varies2 :Int {
        get {
            return varies1*2
        }
        set(myInt) {
            varies1 = varies2
        }
    }
}

var myclasses = myCLass()

//varies1 = 1
myclasses.varies1

//varies2 = 2
myclasses.varies2

myclasses.varies2 = 3

//varies1 = 3
myclasses.varies1

//varies2 = 3
myclasses.varies2
</code></pre><h4 id="willSet_u548CdidSet"><a href="#willSet_u548CdidSet" class="headerlink" title="willSet和didSet"></a>willSet和didSet</h4><p>接着刚刚的类，<code>willSet</code>和<code>didSet</code>两个属性监视器每次被设置的时候就会调用,尝试过发现<strong>即使是被<code>get</code>修改，也会触发</strong></p>
<pre><code>class myCLass {
    var varies1: Int = 1{
        willSet {
            print(&quot;will set&quot;)
        }
    }
    var varies2 :Int {
        get {
            return varies1*2
        }
        set(myInt) {
            varies1 = varies2
        }
    }
}
</code></pre><h3 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h3><h4 id="struct_u4FEE_u6539_u5C5E_u6027"><a href="#struct_u4FEE_u6539_u5C5E_u6027" class="headerlink" title="struct修改属性"></a>struct修改属性</h4><p><code>struct</code>在修改属性的时候需要在<code>func</code>前加<code>mutating</code>，代表突变</p>
<pre><code>struct Point1 {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double){
        x += deltaX
        y += deltaY
    }
}
</code></pre><h3 id="u7EE7_u627F"><a href="#u7EE7_u627F" class="headerlink" title="继承"></a>继承</h3><h4 id="u521D_u59CB_u5316init"><a href="#u521D_u59CB_u5316init" class="headerlink" title="初始化init"></a>初始化init</h4><p>继承的时候初始化要加上<code>override</code>，这和之前只需要<code>init</code>不一样</p>
<pre><code>class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
</code></pre><h2 id="u81EA_u5224_u65AD_u94FE_u63A5"><a href="#u81EA_u5224_u65AD_u94FE_u63A5" class="headerlink" title="自判断链接"></a>自判断链接</h2><p>一般情况下一个值必须不空，如果要可以为｀nil｀的话，一定要</p>
<pre><code>var num : Int?
</code></pre><p>然后拆包的时候</p>
<pre><code>num!
</code></pre><p>这就碰到问题了，这里拆包要求非空才行，那么要是我不知道空不空怎么办呢？</p>
<p>普通值避免拆包就行了</p>
<pre><code>if let numTemp = num {
    print(&quot;not nill&quot;)
}else {
    print(&quot;is nill&quot;)
}
</code></pre><p>但是要是碰到需要操作类的属性，必须拆包呢？那就看下面</p>
<pre><code>class myClasses{
    var varies:Int = 0
}

var myClass:myClasses?

if let classTemp = myClass?.varies {
    print(&quot;not nill&quot;)
}else {
    print(&quot;is nill&quot;)
}
</code></pre><h2 id="u7C7B_u578B_u8F6C_u6362"><a href="#u7C7B_u578B_u8F6C_u6362" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="is"><a href="#is" class="headerlink" title="is"></a>is</h3><p>用来对比两者的类型，要这么用:</p>
<pre><code>var myDic = [123,&quot;this is a string&quot;]

for item in myDic{
    if item is String{
        print(&quot;\(item) is a string!&quot;)
    }
}
</code></pre><h3 id="as__u548C_as_3F"><a href="#as__u548C_as_3F" class="headerlink" title="as 和 as?"></a>as 和 as?</h3><p><code>as?</code>与<code>as</code>最大的区别是是否强制转换，<code>as</code>有可能出现错误，<code>as?</code>可以返回<code>nil</code>，下面是<code>as?</code>的用法</p>
<pre><code>for item in myDic {
    if let theString = item as? String {
        print(&quot;the item \&quot;\(theString)\&quot; is a string&quot;)
    } else if let theInt = item as? Int {
        print(&quot;the item \&quot;\(theInt)\&quot; is a interger&quot;)
    }
}
</code></pre><h2 id="Swift_u4E0Eoc_u7684_u5173_u7CFB"><a href="#Swift_u4E0Eoc_u7684_u5173_u7CFB" class="headerlink" title="Swift与oc的关系"></a>Swift与oc的关系</h2><p>oc切换到swift也不能算完全无缝，也碰到了不少问题</p>
<h3 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h3><p>oc初始化的时候一般是这么写的</p>
<pre><code>UILabel *label= [[UILabel alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
</code></pre><p>但是swift里<code>alloc</code>不用写了，变成了</p>
<pre><code>var label = UILabel(frame: CGRectMake(100, 100, 100, 100))
</code></pre><h3 id="u5B8F_u5B9A_u4E49"><a href="#u5B8F_u5B9A_u4E49" class="headerlink" title="宏定义"></a>宏定义</h3><p>swift里取消了oc延续自c的宏定义，oc里要确定系统版本要这么写</p>
<pre><code>#define IOS9 ([[[UIDevice currentDevice] systemVersion] floatValue]&gt;=9.0) &amp;&amp; ([[[UIDevice currentDevice] systemVersion] floatValue] &lt;10.0)
</code></pre><p>现在只能用<code>let</code>代替</p>
<pre><code>let IOS9 = (UIDevice.currentDevice().systemVersion as NSString).floatValue&gt;=9.0 &amp;&amp; (UIDevice.currentDevice().systemVersion as NSString).floatValue&lt;10.0
</code></pre><p>但是又碰到问题了，那么函数类的要传参的宏怎么办呢？以前oc很简单，RGB的例子</p>
<pre><code>#define RGB(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:(1)];
</code></pre><p>swift里只能用全局函数实现了</p>
<pre><code>func RGB (r:CGFloat, g:CGFloat, b:CGFloat)-&gt;UIColor{
    return UIColor(red: r/255.0, green: g/255.0, blue: b/255.0, alpha: 1)
}
</code></pre><h3 id="u8C03_u7528oc_u65B9_u6CD5"><a href="#u8C03_u7528oc_u65B9_u6CD5" class="headerlink" title="调用oc方法"></a>调用oc方法</h3><p>oc里一般是这么写方法的</p>
<pre><code>-(NSInteger)addTwoNumbers:(NSInteger)num1 and:(NSInteger)num2{
    return num1+num2;
}
</code></pre><p>调用的时候就写</p>
<pre><code>[self addTwoNumbers:1 and:2];
</code></pre><p>那么swift里用的时候就药这么调用</p>
<pre><code>addTwoNumbers(1, num2: 2)
</code></pre><h3 id="u672A_u77E5_u5BF9_u8C61_u7684_u5904_u7406_u65B9_u6CD5"><a href="#u672A_u77E5_u5BF9_u8C61_u7684_u5904_u7406_u65B9_u6CD5" class="headerlink" title="未知对象的处理方法"></a>未知对象的处理方法</h3><p>oc里有id类型来存任意对象，那么在swift里有anyObject，以我们最常用的从服务器取json串存为字典再提取的场景为例</p>
<pre><code>let lastRefreshDate: AnyObject? = userDefaults.objectForKey(&quot;LastRefreshDate&quot;)
</code></pre><p>这时候不一定会取到内容，而且转换也不一定会成功，这时候当我们要用的时候，就得类型转换</p>
<pre><code>if let date = lastRefreshDate as? NSDate {
    print(&quot;\(date.timeIntervalSinceReferenceDate)&quot;)
}
</code></pre><h3 id="oc_u4E2D_u7684block_u548Cswift_u4E2D_u7684_u95ED_u5305"><a href="#oc_u4E2D_u7684block_u548Cswift_u4E2D_u7684_u95ED_u5305" class="headerlink" title="oc中的block和swift中的闭包"></a>oc中的<code>block</code>和swift中的闭包</h3><p>oc中的block</p>
<pre><code>void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) {/* ... */};
</code></pre><p>swift里的闭包</p>
<pre><code>let completionBlock: (NSData, NSError) -&gt; Void = {data, error in /* ... */} 
</code></pre><p>他们是一摸一样的</p>
<h3 id="u6BD4_u8F83_u7B26_u53F7-1"><a href="#u6BD4_u8F83_u7B26_u53F7-1" class="headerlink" title="比较符号"></a>比较符号</h3><p>在比较值的时候，oc用<code>[object isEqual:object]</code>，swift则用<code>==</code></p>
<p>在比较对象地址（是否是同一个实例）的是偶户，oc用<code>==</code>,swift用<code>===</code></p>
<h3 id="oc_u4E2D_u7684@selector_u548Cswift_u4E2D_u7684Selector_u7C7B_u578B"><a href="#oc_u4E2D_u7684@selector_u548Cswift_u4E2D_u7684Selector_u7C7B_u578B" class="headerlink" title="oc中的@selector和swift中的Selector类型"></a>oc中的<code>@selector</code>和swift中的<code>Selector</code>类型</h3><p>在为一个按钮添加点按动作时候，oc里是这么写的</p>
<pre><code>[myButton addTarget:self action:@selector(tappedButton:) forControlEvents:UIControlEventTouchUpInside];
</code></pre><p>而在swift里可以把字符串转换为选择器类型</p>
<pre><code>myButton.addTarget(self, action: &quot;tappedButton:&quot;, forControlEvents: UIControlEvents.TouchUpInside)
</code></pre><p>当然也可以先赋值</p>
<pre><code>let mySelector: Selector = &quot;tappedButton:&quot;
</code></pre><h3 id="cocoa"><a href="#cocoa" class="headerlink" title="cocoa"></a>cocoa</h3><h4 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h4><p>swift里的String完全可以替代NSString，而且String可以安全从NSString转过来，所以转化的时候只要用as</p>
<pre><code>let myString:String = myNSString as String;
</code></pre><h4 id="NSLog"><a href="#NSLog" class="headerlink" title="NSLog"></a>NSLog</h4><p><code>NSLog</code>同样可用，形式为</p>
<pre><code>NSLog(&quot;%@&quot;,myString)
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[汇编小总结]]></title>
      <url>http://pengtianhao.com/2016/06/23/%E6%B1%87%E7%BC%96%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转自沈逸云的博客</p>
</blockquote>
<h1 id="u5BC4_u5B58_u5668"><a href="#u5BC4_u5B58_u5668" class="headerlink" title="寄存器"></a>寄存器</h1><p>8086寄存器分为8个通用寄存器，4个段寄存器，1个标志寄存器，1个指令寄存器, 均为16位 2字节<br>AX累加器<br>BX基址寄存器<br>CX计数器<br>DX数据寄存器<br>SI源地址寄存器<br>DI目的地址寄存器<br>BP基址指针<br>SP堆栈指针</p>
<p>CS代码段寄存器<br>SS堆栈段寄存器<br>DS数据段寄存器<br>ES附加段寄存器</p>
<p>FLAGS标志寄存器<br>IP指令指针  专用寄存器，具有自增功能</p>
<p>SP和BP均可于SS联用，SP自增自减不应用于其它功能</p>
<a id="more"></a>
<h2 id="u6807_u5FD7_u5BC4_u5B58_u5668"><a href="#u6807_u5FD7_u5BC4_u5B58_u5668" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><pre><code>CF(Carry Flag) CF = 1,表示本次运算中最高位(第7或第15位)有进位或借位，一般用于判断无符号数
OF(Overflow Flag) OF = 1,表示算数运算结果产生溢出，一般用于判断有符号数，两个操作数符号相同而结果却相反就取1
PF(Parity Flag) PF = 1, 表示本次运算结果的低八位中有偶数个1
AF(Auxiliary Carry Flag) AF = 1,表示8位运算中低四位像高四位有进位或借位，常用于BCD数运算
ZF(Zero Flag) ZF = 1,表示本次运算结果为0
SF(Sign Flag) SF = 1, 表示本次运算的最高位(第7或第15位)为1
</code></pre><h1 id="u5B58_u50A8_u5668"><a href="#u5B58_u50A8_u5668" class="headerlink" title="存储器"></a>存储器</h1><h2 id="u6570_u636E_u5B58_u50A8_u683C_u5F0F"><a href="#u6570_u636E_u5B58_u50A8_u683C_u5F0F" class="headerlink" title="数据存储格式"></a>数据存储格式</h2><p>位(bit):可以存放一位二进制数 0 或 1</p>
<p>字节(byte):8 个二进制位</p>
<p>字(word):在 8086 和 80286 中字由 2 个字节组成，16 位，位编号从右自左为$D_7 \sim D_0$。最低位称为最低有效位LSB(Least Significant Bit),即 $D_0$ 位;最高位称为最高有效位MSB(Most Significant Bit),字节为$D<em>7$位，字为$D</em>{15}$位。</p>
<h2 id="u5B58_u50A8_u65B9_u5F0F"><a href="#u5B58_u50A8_u65B9_u5F0F" class="headerlink" title="存储方式"></a>存储方式</h2><p>一个存储单元内容是1字节。存放时低字节存入低地址，高字节存入高地址。8086这种”低对低高对高”的存储方式称为”小端对齐(Little endian)”。</p>
<p>一个地址既可以看作字节单元地址也可以看作字单元地址。字节单元地址既可以是偶数也可以是奇数，字单元地址偶地址，双字模4地址</p>
<p>如[0002H] = 34H, [0003H] = 12H, 则2号字单元的内容为 [0002H] = 1234H, 12为高字节存在高地址，34为低字节存在低地址</p>
<h2 id="u5B58_u50A8_u5668_u7684_u5206_u6BB5_u7BA1_u7406"><a href="#u5B58_u50A8_u5668_u7684_u5206_u6BB5_u7BA1_u7406" class="headerlink" title="存储器的分段管理"></a>存储器的分段管理</h2><p>16位8086CPU可以方便表达$0000H \sim FFFFH$的16位存储器地址，即$2^{16} = 64KB$容量，但8086CPU的地址线是20位，所以最大寻址空间为$00000H \sim FFFFFH,2^{20}=1MB$</p>
<p>将1MB存储器空间分为很多逻辑段(Segment),每段最大限制为64KB，即16位<br>段基地址:段内偏移地址</p>
<p>段基地址:逻辑段在主存中的起始位置，模16地址,即$xxxx0H$,省略低4位0<br>段偏移地址:偏移量,由于每段不超过64KB，所以偏移地址可以用16位数据表示</p>
<p>每一个存储器单元都有一个唯一的20位地址，称为该单元的物理地址和绝对地址；而编程时使用的 “段地址:偏移地址” 称为逻辑地址</p>
<h2 id="u6BB5_u5BC4_u5B58_u5668"><a href="#u6BB5_u5BC4_u5B58_u5668" class="headerlink" title="段寄存器"></a>段寄存器</h2><pre><code>8086的段寄存器保存对应逻辑段的段基地址，每种段均有各自的用途
CS 代码段(Code Segment)
SS 堆栈段(Stack Segment)
DS 数据段(Data Segment)
ES 附加段(Extra Segment)
每段之间并不要求必须是64KB，各段之间可以重叠，所以同一个物理地址可以有多个逻辑地址
</code></pre><h1 id="8086_u5BFB_u5740_u65B9_u5F0F"><a href="#8086_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="8086寻址方式"></a>8086寻址方式</h1><h2 id="u7ACB_u5373_u6570_u5BFB_u5740_u65B9_u5F0F"><a href="#u7ACB_u5373_u6570_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="立即数寻址方式"></a>立即数寻址方式</h2><pre><code>操作数作为指令的一部分存放在操作码之后的主存单元中。立即数寻址方式常用于给寄存器和存储单元赋值
mov ax, 0102h ; 高字节01H存放于高地址ah中，02H放在低地址al中
</code></pre><h2 id="u5BC4_u5B58_u5668_u5BFB_u5740_u65B9_u5F0F"><a href="#u5BC4_u5B58_u5668_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="寄存器寻址方式"></a>寄存器寻址方式</h2><pre><code>寄存器寻址方式的操作数存放于CPU的某个内部寄存器中，不需要访问存储器，因而执行速度块
mov bx, ax
</code></pre><h2 id="u5B58_u50A8_u5668_u5BFB_u5740_u65B9_u5F0F"><a href="#u5B58_u50A8_u5668_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="存储器寻址方式"></a>存储器寻址方式</h2><pre><code>寄存器寻址虽然快，但CPU中寄存器数目有限，多数情况下操作数还是存储在主存中。
指令中给出的是主存地址信息，由于8086存储器是分段管理的，所以给出的只是偏移地址(称为有效地址EA)，而段地址在默认的和用超越前缀指定的段寄存器中
在汇编语言中用方括号[]表示存储段单元的内容
</code></pre><h3 id="u76F4_u63A5_u5BFB_u5740_u65B9_u5F0F"><a href="#u76F4_u63A5_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="直接寻址方式"></a>直接寻址方式</h3><pre><code>指令中直接包含有有效地址。默认有效地址与数据段寄存器DS一起构成存储单元的物理地址，也可以段超越
mov ax, [2000h]  ; ax &lt;- ds:[2000h]
mov ax, es:[2000h]  ; ax &lt;- es:[2000h]
</code></pre><h3 id="u5BC4_u5B58_u5668_u95F4_u63A5_u5BFB_u5740_u65B9_u5F0F"><a href="#u5BC4_u5B58_u5668_u95F4_u63A5_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="寄存器间接寻址方式"></a>寄存器间接寻址方式</h3><pre><code>有效地址存放在基址寄存器BX和变址寄存器SI、DI中。默认的段地址在DS中，可以段超越
mov ax, [si]  ; ax &lt;- ds:[si]
</code></pre><h3 id="u5BC4_u5B58_u5668_u76F8_u5BF9_u5BFB_u5740_u65B9_u5F0F"><a href="#u5BC4_u5B58_u5668_u76F8_u5BF9_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="寄存器相对寻址方式"></a>寄存器相对寻址方式</h3><pre><code>有效地址是寄存器内容与有符号8位和16位位移量之和。寄存器可以是BX，SI，DI或BP。BX，SI，DI寄存器默认数据段DS，BP默认堆栈段SS
mov ax, [di + 06h] ; ax &lt;- ds:[di + 06h]
mov ax, [bp + 06h] ; ax &lt;- ss:[bp + 06h]
有效地址超过FFFFH取64K的模
</code></pre><h3 id="u57FA_u5740_u53D8_u5740_u5BFB_u5740_u65B9_u5F0F"><a href="#u57FA_u5740_u53D8_u5740_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="基址变址寻址方式"></a>基址变址寻址方式</h3><pre><code>一个基址寄存器(BX或BP)的内容加上变址寄存器(SI或DI)的内容构成有效地址EA。若基址寄存器使用BX默认段位数据段DS，若基址寄存器为BP，默认段为SS
mov ax, [bx + si] ; ax &lt;- ds:[bx + si]
mov ax, [bp + di] ; ax &lt;- ss:[bp + si]
有效地址超过FFFFH取64K的模
</code></pre><h3 id="u76F8_u5BF9_u57FA_u5740_u53D8_u5740_u5BFB_u5740_u65B9_u5F0F"><a href="#u76F8_u5BF9_u57FA_u5740_u53D8_u5740_u5BFB_u5740_u65B9_u5F0F" class="headerlink" title="相对基址变址寻址方式"></a>相对基址变址寻址方式</h3><pre><code>即在基址变址的基础上在指令中还指定一个8位或16位的位移量
有效地址超过FFFFH取64K的模
</code></pre><h1 id="u6307_u4EE4_u7CFB_u7EDF"><a href="#u6307_u4EE4_u7CFB_u7EDF" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="u6570_u636E_u4F20_u9001_u7C7B"><a href="#u6570_u636E_u4F20_u9001_u7C7B" class="headerlink" title="数据传送类"></a>数据传送类</h2><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><pre><code>传送指令将1字节和字的操作数从源地址src传送至目的地址dest
mov reg/mem, imm  ; 8086不允许立即数传送至段寄存器
mov reg/mem/seg, reg
mov reg/sesg, mem
mov reg/mem, seg

mov byte ptr [si], 0ah ; 立即数0AH使用了前导0,十六进制数如果以字母开头要加前导0以便与标识符区分
</code></pre><h3 id="xchg"><a href="#xchg" class="headerlink" title="xchg"></a>xchg</h3><pre><code>交换指令将源操作数与目的操作数内容互换
xchg reg, reg/mem

xchg ax, [2000h]
</code></pre><h3 id="xalt"><a href="#xalt" class="headerlink" title="xalt"></a>xalt</h3><pre><code>转码指令将BX指定的缓冲区中，al指定的位移处的数据取出赋给al
xalt ; al &lt;- ds:[bx + al]
xalt label ; label 表示首地址的符号
</code></pre><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><pre><code>堆栈只有一个出口即当前栈顶，栈顶是地址较小的一端，由SP指定
进栈指令先将堆栈指针SP减2然后将一个字操作数存入栈顶。低字节存入低地址，高字节存入高地址
push r16/m16/seg ; SP &lt;- Sp -2, SS:[SP] &lt;- r16/m16/seg
</code></pre><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><pre><code>出栈指令将栈顶的一个字传送至指定的目的操作数，然后堆栈指针SP加2
pop r16/m16/seg ; r16/m16/seg &lt;- SS:[SP], SP &lt;- SP + 2
</code></pre><h3 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h3><pre><code>有效地址传送指令将存储器操作数的有效地址传送至指定寄存器

lea bx, [bx + si + 0f62h] ; bx &lt;- bx + si + 0f62h, 这里bx得到的是主存单元的有效地址，不是物理地址，也不是该单元的内容
</code></pre><h2 id="u7B97_u6570_u8FD0_u7B97_u7C7B_u6307_u4EE4"><a href="#u7B97_u6570_u8FD0_u7B97_u7C7B_u6307_u4EE4" class="headerlink" title="算数运算类指令"></a>算数运算类指令</h2><h3 id="u52A0_u51CF_u4E58_u9664"><a href="#u52A0_u51CF_u4E58_u9664" class="headerlink" title="加减乘除"></a>加减乘除</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><pre><code>add reg, imm/reg/mem ; reg &lt;- reg + imm/reg/mem
add mem, imm/reg ; mem &lt;- mem + imm/reg
</code></pre><h4 id="adc"><a href="#adc" class="headerlink" title="adc"></a>adc</h4><pre><code>adc reg, imm/reg/mem ; reg &lt;- reg + imm/reg/mem + CF
adc mem, imm/reg ; mem &lt;- mem + imm/reg + CF
</code></pre><h4 id="inc"><a href="#inc" class="headerlink" title="inc"></a>inc</h4><pre><code>inc reg/mem ; reg/mem &lt;- reg/mem + 1
</code></pre><h4 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h4><pre><code>sub reg, imm/reg/mem ; reg &lt;- reg - imm/reg/mem
sub mem, imm/reg ; mem &lt;- mem - imm/reg
</code></pre><h4 id="sbb"><a href="#sbb" class="headerlink" title="sbb"></a>sbb</h4><pre><code>sbb reg, imm/reg/mem ; reg &lt;- reg - imm/reg/mem - CF
sbb mem, imm/reg ; mem &lt;- mem - imm/reg - CF
</code></pre><h4 id="inc-1"><a href="#inc-1" class="headerlink" title="inc"></a>inc</h4><pre><code>dec reg/mem ; reg/mem &lt;- reg/mem - 1
</code></pre><h4 id="neg"><a href="#neg" class="headerlink" title="neg"></a>neg</h4><pre><code>求补指令对操作数进行求补运算，即用零减去操作数然后将结果返回操作数，也可以表达为将操作数按位取反加一
</code></pre><h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h4><pre><code>与sub执行同样的操作，同样影响标志(ZF和CF等)，只是不改变目的操作数
cmp reg, imm/reg/mem ; reg - imm/reg/mem
cmp mem, imm/reg ; mem - imm/reg
</code></pre><h4 id="mul__26amp_3B_26amp_3B_imul"><a href="#mul__26amp_3B_26amp_3B_imul" class="headerlink" title="mul &amp;&amp; imul"></a>mul &amp;&amp; imul</h4><pre><code>mul src
imul src
mul无符号数乘法, imul有符号数相乘，src不能为立即数
隐含操作数AX和DX，若字节相乘，得到16位的字存入AX；若字相乘，得到双字，高字存入DX，低字存入AX
只对OF，CF有影响，当相乘结果中高一半有有效数值，则OF＝CF＝1
</code></pre><h4 id="div__26amp_3B_26amp_3B_idiv"><a href="#div__26amp_3B_26amp_3B_idiv" class="headerlink" title="div &amp;&amp; idiv"></a>div &amp;&amp; idiv</h4><pre><code>div src
idiv src
div无符号数除法, idiv有符号数除法,src不能为立即数
隐含操作数AX和DX，若字节相除，8位商存入AL，8位余数存入AH；若字相乘，得到双字，16位商存入AX，16位余数存入DX
对所有条件标志均无定义
</code></pre><h3 id="u7B26_u53F7_u6269_u5C55_u6307_u4EE4"><a href="#u7B26_u53F7_u6269_u5C55_u6307_u4EE4" class="headerlink" title="符号扩展指令"></a>符号扩展指令</h3><pre><code>大多数指令要求两个操作数位数一致，但实际数据不一定满足要求，所以需要扩展。对有符号数使用符号扩展；无符号数使用零位扩展,直接将高位清零即可
</code></pre><h4 id="cbw"><a href="#cbw" class="headerlink" title="cbw"></a>cbw</h4><pre><code>将al符号扩展成ax
mov al, 80h
cbw  ;; ax = ff80h
</code></pre><h4 id="cwd"><a href="#cwd" class="headerlink" title="cwd"></a>cwd</h4><pre><code>将ax的内容符号扩展成dx，若ax最高位为0则dx＝0000h，若ax最高位为1,则dx＝ffffh
mov ax, z
cwd  ;; z -&gt; (dx, ax)
</code></pre><h3 id="u5341_u8FDB_u5236_u8C03_u6574_u6307_u4EE4"><a href="#u5341_u8FDB_u5236_u8C03_u6574_u6307_u4EE4" class="headerlink" title="十进制调整指令"></a>十进制调整指令</h3><h4 id="daa"><a href="#daa" class="headerlink" title="daa"></a>daa</h4><pre><code>压缩BCD码是通常的8421码，用4个二进制位表示一个十进制位，1字节可以表示2个十进制位00~99
使用daa或das指令之前，应先执行加法或减法指令
daa跟在以al为目的操作数的的add或adc之后，对al的二进制数结果进行十进制调整

 mov al, 34h
 add al, 59h   ;; al = 8DH
 daa           ;; al = 93H
 mov BCD, al
</code></pre><h4 id="das"><a href="#das" class="headerlink" title="das"></a>das</h4><pre><code>das跟在以al为目的操作数的的sub或sbb之后，对al的二进制数结果进行十进制调整

已知AX＝1234H，BX＝4612H，计算1234-4612的差
sub al, bl
das
xchg al, ah
sbb al, bh
das
xchg al, ah   ;; ax = 6622h, CF = 1
;; 若把1234H和4612H认为是无符号的十进制数，则利用借位1结果为6622,正确。
;; 若把1234H和4612H认为是有符号十进制数，则1234 - 4612 = -3378   10000 - 3378 = 6622, 正确，位数为n的十进制整数d，其补码为10^n-d
</code></pre><h4 id="aaa"><a href="#aaa" class="headerlink" title="aaa"></a>aaa</h4><pre><code>非压缩BCD码用8个二进制位表示一个十进制位，实际上只是用低4位表示0~9,高4位任意。ASCII中0~9为30H～39HH，也可以认为是非压缩BCD码
aaa加法的非压缩BCD码调整指令

mov ax, 0608h   ;; ax=0608h,表示非压缩BCD码68
mov bl, 09h
add, al, bl     ;; al = 08h + 09h = 11h
aaa             ;; ax = 0707h, 实现非压缩BCD码加法
</code></pre><h4 id="aas"><a href="#aas" class="headerlink" title="aas"></a>aas</h4><pre><code>减法的非压缩BCD码调整
</code></pre><h4 id="aam"><a href="#aam" class="headerlink" title="aam"></a>aam</h4><pre><code>乘法的非压缩BCD码调整。该指令跟在以AX为目的操作数的mul指令之后，利用mul相乘的两个非压缩BCD码的高四位必须为0

mov ax, 0608h
mov bl, 09h
mul bl        ;; ax = 0048h
aam           ;; ax = 0702h
</code></pre><h4 id="aad"><a href="#aad" class="headerlink" title="aad"></a>aad</h4><pre><code>除法的非压缩BCD码调整指令
</code></pre><h2 id="u4F4D_u64CD_u4F5C_u6307_u4EE4"><a href="#u4F4D_u64CD_u4F5C_u6307_u4EE4" class="headerlink" title="位操作指令"></a>位操作指令</h2><pre><code>位操作指令对二进制数的各位进行操作，包括逻辑运算指令和移位指令
</code></pre><h3 id="u903B_u8F91_u8FD0_u7B97"><a href="#u903B_u8F91_u8FD0_u7B97" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><pre><code>所有双操作数的逻辑指令均置CF＝OF＝0,根据结果置SF，ZF，PF状态，对AF未定义，所以一般用xor来清零，因为它同时可以清CF和OF
</code></pre><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><pre><code>and reg, imm/reg/mem
and mem, imm/reg
</code></pre><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><h4 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h4><pre><code>xor可用于求反某些位
</code></pre><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><pre><code>not reg/mem
not对操作数按位取反，操作数不能为立即数。not不是双操作数的逻辑指令，对符号位无影响
</code></pre><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><pre><code>test指令操作与and相同但不保存执行结果只改变标志位，常用于检测某些条件是否满足

test al, 01h
jnz there     ;; ZF＝0,即D0=1,则程序转移到there
</code></pre><h3 id="u79FB_u4F4D"><a href="#u79FB_u4F4D" class="headerlink" title="移位"></a>移位</h3><h4 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h4><pre><code>逻辑左移，最高位进入CF
</code></pre><h4 id="shr"><a href="#shr" class="headerlink" title="shr"></a>shr</h4><pre><code>逻辑右移，最低位进入CF
</code></pre><h4 id="sal"><a href="#sal" class="headerlink" title="sal"></a>sal</h4><pre><code>算数左移，和逻辑左移一样，根据最高位是否变化设置OF
</code></pre><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><pre><code>算数右移，最高位保持不变
</code></pre><h4 id="rol"><a href="#rol" class="headerlink" title="rol"></a>rol</h4><pre><code>不带进位循环左移
</code></pre><h4 id="ror"><a href="#ror" class="headerlink" title="ror"></a>ror</h4><pre><code>不带进位循环右移
</code></pre><h4 id="rcl"><a href="#rcl" class="headerlink" title="rcl"></a>rcl</h4><pre><code>带进位循环左移
</code></pre><h4 id="rcr"><a href="#rcr" class="headerlink" title="rcr"></a>rcr</h4><pre><code>带进位循环右移
</code></pre><h2 id="u63A7_u5236_u8F6C_u79FB_u7C7B_u6307_u4EE4"><a href="#u63A7_u5236_u8F6C_u79FB_u7C7B_u6307_u4EE4" class="headerlink" title="控制转移类指令"></a>控制转移类指令</h2><h3 id="u65E0_u6761_u4EF6_u8F6C_u79FB_u6307_u4EE4"><a href="#u65E0_u6761_u4EF6_u8F6C_u79FB_u6307_u4EE4" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><h4 id="u6BB5_u5185_u8F6C_u79FB_uFF0C_u76F8_u5BF9_u5BFB_u5740"><a href="#u6BB5_u5185_u8F6C_u79FB_uFF0C_u76F8_u5BF9_u5BFB_u5740" class="headerlink" title="段内转移，相对寻址"></a>段内转移，相对寻址</h4><pre><code>jmp label  ;; IP &lt;- IP + 位移量
位移量是紧接着JMP后的那条指令的偏移地址到目标指令(label)的偏移地址的地址位移。汇编器会自动根据label做加减法，并根据位移量的大小自动形成短转移和近转移
</code></pre><h4 id="u6BB5_u5185_u8F6C_u79FB_uFF0C_u95F4_u63A5_u5BFB_u5740"><a href="#u6BB5_u5185_u8F6C_u79FB_uFF0C_u95F4_u63A5_u5BFB_u5740" class="headerlink" title="段内转移，间接寻址"></a>段内转移，间接寻址</h4><pre><code>jmp word ptr [2000h]  ;; IP &lt;- [2000h]
</code></pre><h4 id="u6BB5_u95F4_u8F6C_u79FB_uFF0C_u76F4_u63A5_u5BFB_u5740"><a href="#u6BB5_u95F4_u8F6C_u79FB_uFF0C_u76F4_u63A5_u5BFB_u5740" class="headerlink" title="段间转移，直接寻址"></a>段间转移，直接寻址</h4><pre><code>jmp far ptr label  ;; IP &lt;- label的偏移地址,CS &lt;- label的段地址
</code></pre><h4 id="u6BB5_u95F4_u8F6C_u79FB_uFF0C_u95F4_u63A5_u5BFB_u5740"><a href="#u6BB5_u95F4_u8F6C_u79FB_uFF0C_u95F4_u63A5_u5BFB_u5740" class="headerlink" title="段间转移，间接寻址"></a>段间转移，间接寻址</h4><pre><code>jmp far ptr mem  ;; IP &lt;- [mem], CS &lt;- [mem + 2]

mov word ptr [bx], 0
mov word ptr [bx + 2], 1500h
jmp far ptr [bx]
</code></pre><h3 id="u6761_u4EF6_u8F6C_u79FB_u6307_u4EE4"><a href="#u6761_u4EF6_u8F6C_u79FB_u6307_u4EE4" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><h3 id="u5FAA_u73AF_u6307_u4EE4"><a href="#u5FAA_u73AF_u6307_u4EE4" class="headerlink" title="循环指令"></a>循环指令</h3><pre><code>cx存放循环次数，只能使用段内相对寻址的8位位移量
loop label  ;; cx &lt;- cx + 1; 若cx != 0,循环: IP &lt;- IP + 位移量
loopz label  ;; cx &lt;- cx + 1; 若cx != 0且ZF ＝ 1,循环: IP &lt;- IP + 位移量
loopnz label  ;; cx &lt;- cx + 1; 若cx != 0且 ZF ！＝ 1,循环: IP &lt;- IP + 位移量
</code></pre><h3 id="u5B50_u7A0B_u5E8F_u6307_u4EE4"><a href="#u5B50_u7A0B_u5E8F_u6307_u4EE4" class="headerlink" title="子程序指令"></a>子程序指令</h3><pre><code>栈顶是IP
call label    ;; 段内调用，相对寻址: SP &lt;- SP - 2, SS:[SP] &lt;- IP
              ;; IP &lt;- IP + 16位位移量
call r16/m16  ;; 段内调用，间接寻址: SP &lt;- SP - 2, SS:[SP] &lt;- IP
              ;; IP &lt;- r16/m16
call far ptr label   ;; 段间调用，直接寻址:SP &lt;- SP - 2, SS:[SP] &lt;- CS
                     ;; SP &lt;- SP - 2, SS:[Sp] &lt;- IP
                     ;; IP &lt;- label偏移地址,CS &lt;- label段地址
call far ptr mem     ;; 段间调用，间接寻址:SP &lt;- SP - 2, SS:[SP] &lt;- CS
                     ;; SP &lt;- SP - 2, SS:[Sp] &lt;- IP
                     ;; IP &lt;- [mem],CS &lt;- [mem + 2]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++小总结]]></title>
      <url>http://pengtianhao.com/2016/06/23/C++%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>来自沈逸云的博客</p>
</blockquote>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>定义一个常数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>保护被修饰的东西</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u6307_u9488_u51FD_u6570"><a href="#u6307_u9488_u51FD_u6570" class="headerlink" title="指针函数"></a>指针函数</h1><p>返回一个指针的函数</p>
<a id="more"></a>
<h1 id="u51FD_u6570_u6307_u9488"><a href="#u51FD_u6570_u6307_u9488" class="headerlink" title="函数指针"></a>函数指针</h1><p>指向一个函数的指针 1.指向的函数的返回类型要与声明的函数指针一致 2.指向的函数的参数类型及个数要与声明的函数指针一致</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> (*pfunc)(<span class="keyword">double</span> x);</span><br><span class="line">    pfunc = func;</span><br><span class="line">    (*pfunc)(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要把函数入口的地址给函数指针就可以用函数指针执行函数了(函数名本来就是一个地址，普通函数的调用既可以 函数名(参数列表) 也可以 (*函数名)(参数列表) 只是后者不太用)。</p>
<p>也可以使用 typedef 将函数指针声明为一个类型，然后接可以像用 int 一样来定义函数指针了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*PFunc)</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    PFunc pfunc;</span><br><span class="line">    pfunc = func;</span><br><span class="line">    (*pfunc)(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>妙用，因为函数指针是指针，可以将其放到指针数组里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PFunc)</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcC</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    PFunc pfunc[<span class="number">3</span>] = &#123;funcA, funcB, funcC&#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pfunc[choice](choice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u81EA_u5B9A_u4E49_u6570_u636E_u7C7B_u578B"><a href="#u81EA_u5B9A_u4E49_u6570_u636E_u7C7B_u578B" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h1><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef 已有类型名 新类型名</p>
<p>typedef double Area, Volume</p>
<h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><h1 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h1><h2 id="u53C2_u6570_u4F20_u9012"><a href="#u53C2_u6570_u4F20_u9012" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="u503C_u4F20_u9012_28_u4F20_u503C_29"><a href="#u503C_u4F20_u9012_28_u4F20_u503C_29" class="headerlink" title="值传递(传值)"></a>值传递(传值)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    swap(x, y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"  "</span> &lt;&lt; y &lt;&lt; endl;  <span class="comment">// 5  10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5F15_u7528_u4F20_u9012_28_u4F20_u5740_29"><a href="#u5F15_u7528_u4F20_u9012_28_u4F20_u5740_29" class="headerlink" title="引用传递(传址)"></a>引用传递(传址)</h3><p>引用是一种特殊类型的变量，可以被认为是另一种变量的别名 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如： int a=1;int *p=&a; int a=1;int &amp;b=a;</p>
<ul>
<li>声明一个变量时必须同时初始化，使它指向一个已存在的对象</li>
<li>一旦初始化后就不能改为指向其它对象 引用可以作为形参，此时引用在调用时初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    swap(x, y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"  "</span> &lt;&lt; y &lt;&lt; endl;  <span class="comment">// 10  5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5185_u8054_u51FD_u6570"><a href="#u5185_u8054_u51FD_u6570" class="headerlink" title="内联函数"></a>内联函数</h2><p>内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入到每一个调用处。这样节省了参数传递，控制转移等开销，内联函数要求是比较简单的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">calArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5E26_u9ED8_u8BA4_u53C2_u6570_u503C_u7684_u51FD_u6570"><a href="#u5E26_u9ED8_u8BA4_u53C2_u6570_u503C_u7684_u51FD_u6570" class="headerlink" title="带默认参数值的函数"></a>带默认参数值的函数</h2><p>函数在定义时可以预先声明默认的形参值。 有默认值的形参必须在形参列表的最后。 在相同的作用域内，不允许在同一个函数的多个声明中对同一个参数的默认值重复定义，即时前后定义的值相同也不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x = <span class="number">5</span>, <span class="keyword">int</span> y = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    add();</span><br><span class="line">    add(<span class="number">6</span>);</span><br><span class="line">    add(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x <span class="comment">/* = 5*/</span>, <span class="keyword">int</span> y <span class="comment">/* = 6*/</span>)</span> </span>&#123; <span class="comment">// 函数的定义也属于声明，所以在相同作用域内一个函数在定义之前又有原型声明，默认形参值应在原型声明中给出</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u51FD_u6570_u91CD_u8F7D"><a href="#u51FD_u6570_u91CD_u8F7D" class="headerlink" title="函数重载"></a>函数重载</h2><p>两个以上的函数，具有相同的函数名，但是形参的类型或者个数不同，编译器根据实参和形参的类型和个数的最佳匹配自动确定调用哪一个函数</p>
<h1 id="u7C7B_u548C_u5BF9_u8C61"><a href="#u7C7B_u548C_u5BF9_u8C61" class="headerlink" title="类和对象"></a>类和对象</h1><p>类和对象的关系就相当于基本数据类型和变量的关系，即一般与特殊的关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock &#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 类的外部接口，在类外只能访问公有成员</span></span><br><span class="line">    Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS); <span class="comment">// 构造函数,对象的初始化，构造函数在对象被创建时被自动调用</span></span><br><span class="line">    Clock() &#123;                            <span class="comment">// 重载构造函数，现在有两种重载，带参数的和无参数的</span></span><br><span class="line">        hour = <span class="number">0</span>;</span><br><span class="line">        minute = <span class="number">0</span>;</span><br><span class="line">        second = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Clock(Clock &amp;c);                     <span class="comment">// 复制构造函数</span></span><br><span class="line">    ~Clock();                            <span class="comment">// 析构函数，在对象的生存周期结束时被调用，不能重载不接受参数，用于释放对象开辟的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH = <span class="number">0</span>, <span class="keyword">int</span> newM = <span class="number">0</span>, <span class="keyword">int</span> newS = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;<span class="comment">// 函数的原型声明写在类体中，原型说明了函数的参数表和返回类型。而函数的具体实现写在类定义之外</span></span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// 私有成员只能被本类的成员函数访问</span></span><br><span class="line">    <span class="keyword">int</span> hour, minute, second;</span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">// 保护成员的性质和私有成员一样，只是派生时派生类可以访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) &#123;</span><br><span class="line">    hour = newH;</span><br><span class="line">    minute = newM;</span><br><span class="line">    second = newS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制构造函数，调用一个已存在的对象来初始化当前对象</span></span><br><span class="line">Clock::Clock(Clock &amp;c) &#123;</span><br><span class="line">    hour = c.hour;</span><br><span class="line">    minute = c.minute;</span><br><span class="line">    second = c.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Clock::~Clock() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Clock is destoried"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与普通函数不同的是，实现类的成员函数要指明类的名称</span></span><br><span class="line"><span class="keyword">void</span> Clock::setTime( <span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS ) &#123;</span><br><span class="line">    hour = newH;</span><br><span class="line">    minute = newM;</span><br><span class="line">    second = newS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数，函数调用要耗时，如果某一类的函数要频繁调用且长度不长，可以使用内联函数</span></span><br><span class="line"><span class="comment">// 函数体在编译时会插入到每一个调用它的地方，使用 inline 声明，或者直接在class里写，</span></span><br><span class="line"><span class="comment">// 但为了简洁，常在外面写并加上inline</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Clock::showTime() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hour &lt;&lt; <span class="string">":"</span> &lt;&lt; minute &lt;&lt; <span class="string">":"</span> &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7C7B_u7684_u7EC4_u5408"><a href="#u7C7B_u7684_u7EC4_u5408" class="headerlink" title="类的组合"></a>类的组合</h2><p>类的组合描述的是一个类内嵌其他类的对象作为成员的情况，它们之间的关系是一种包含与被包含的关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123; x = xx; y = yy; &#125;</span><br><span class="line">    Point(Point &amp;p);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point::Point(Point &amp;p) &#123;</span><br><span class="line">    x = p.x;</span><br><span class="line">    y = p.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Line &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(Point xp1, Point xp2);</span><br><span class="line">    Line(Line &amp;l);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point p1, p2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::Line(Point xp1, Point xp2) :p1(xp1), p2(xp2) &#123;&#125;</span><br><span class="line">Line::Line(Line &amp;l) : p1(l.p1), p2(l.p2) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const_u4FEE_u9970_u7684_u7C7B_u6210_u5458"><a href="#const_u4FEE_u9970_u7684_u7C7B_u6210_u5458" class="headerlink" title="const修饰的类成员"></a>const修饰的类成员</h2><h3 id="u5E38_u6210_u5458_u51FD_u6570"><a href="#u5E38_u6210_u5458_u51FD_u6570" class="headerlink" title="常成员函数"></a>常成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> a) : a(a)&#123; <span class="comment">// 常数据成员只能通过初始化列表来获得初值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 常成员函数，常对象只能调用常成员函数，</span></span><br><span class="line">                        <span class="comment">// 无论是否通过常对象调用常成员函数，在常成员函数调用期间目的对象都被视为常对象，</span></span><br><span class="line">                        <span class="comment">// 因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中的非常成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">float</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span></span>; <span class="comment">// 常引用，复制构造函数一般也使用常引用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a; <span class="comment">// 常数据成员,任何函数不能对其赋值，构造函数只能通过初始化列表进行初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = p1.x - p2.x; <span class="comment">// 友元可以访问私有属性</span></span><br><span class="line">    <span class="keyword">double</span> y = p1.y - p2.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x * x + y * y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Point::print() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"print"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Point::print() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"print const"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">     <span class="function">Point <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">const</span> Point <span class="title">c</span><span class="params">(<span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 常对象，常对象必须被初始化，而且不能被更新</span></span><br><span class="line">     a.print(); <span class="comment">// print</span></span><br><span class="line">     c.print(); <span class="comment">// print const</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; dist(a, b); <span class="comment">// 1.41421</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u53CB_u5143"><a href="#u53CB_u5143" class="headerlink" title="友元"></a>友元</h2><p>(1)友元关系不能被继承。 (2)友元关系是单向的，不具有交换性。 (3)友元关系不具有传递性。</p>
<h3 id="u53CB_u5143_u51FD_u6570"><a href="#u53CB_u5143_u51FD_u6570" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数在类中用friend修饰的非成员函数。友元函数可以是一个普通函数也可以是其它类的函数。虽然不是本类的成员函数，但在它的函数体中可以通过对象名访问类的私有和保护对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">float</span> <span class="title">dist</span><span class="params">(Point &amp;p1, Point &amp;p2)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dist</span><span class="params">(Point &amp;p1, Point &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = p1.x - p2.x;  <span class="comment">// 通过对象访问私有数据成员</span></span><br><span class="line">    <span class="keyword">double</span> y = p1.y - p2.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="built_in">sqrt</span>(x*x+y*y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u53CB_u5143_u7C7B"><a href="#u53CB_u5143_u7C7B" class="headerlink" title="友元类"></a>友元类</h3><p>若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> B::<span class="built_in">set</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    a.x = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7C7B_u578B_u517C_u5BB9_u89C4_u5219"><a href="#u7C7B_u578B_u517C_u5BB9_u89C4_u5219" class="headerlink" title="类型兼容规则"></a>类型兼容规则</h2><p>类型兼容规则指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base2 : <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base3 : <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Base1 *ptr)</span> </span>&#123;</span><br><span class="line">ptr-&gt;display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base1 b1;</span><br><span class="line">    Base2 b2;</span><br><span class="line">    Base3 b3;</span><br><span class="line">    func(&amp;b1);  <span class="comment">// Base1</span></span><br><span class="line">    func(&amp;b2);  <span class="comment">// Base1</span></span><br><span class="line">    func(&amp;b2);  <span class="comment">// Base1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7ED3_u6784_u4F53"><a href="#u7ED3_u6784_u4F53" class="headerlink" title="结构体"></a>结构体</h2><p>为了保持与C的兼容C++也有结构体，结构体与类的唯一区别在于，类中对未指定访问控制属性的成员其访问控制属性位私有类型，在结构体中默认位公有类型</p>
<h2 id="u8054_u5408_u4F53"><a href="#u8054_u5408_u4F53" class="headerlink" title="联合体"></a>联合体</h2><p>全部数据成员共享同一组内存单元</p>
<h1 id="u751F_u5B58_u5468_u671F"><a href="#u751F_u5B58_u5468_u671F" class="headerlink" title="生存周期"></a>生存周期</h1><h2 id="u9759_u6001_u751F_u5B58_u671F"><a href="#u9759_u6001_u751F_u5B58_u671F" class="headerlink" title="静态生存期"></a>静态生存期</h2><p>局部作用域中静态变量的特点，它并不会随着每次函数调用而产生一个副本，也不会随着函数返回而失效</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    Point(Point &amp;p) &#123;</span><br><span class="line">        x = p.x;</span><br><span class="line">        y = p.y;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Point() &#123; count--; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(Point p)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">// 静态数据成员声明，用于记录Point的个数，所有对象共享相同的静态属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Point::count = <span class="number">0</span>; <span class="comment">// 静态数据成员定义和初始化，使用类名限定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Point::out(Point p) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count; <span class="comment">// 静态函数成员能直接访问静态属性</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.x;    <span class="comment">// 但静态函数成员必须通过对象名访问非静态成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u7EE7_u627F_u4E0E_u6D3E_u751F"><a href="#u7EE7_u627F_u4E0E_u6D3E_u751F" class="headerlink" title="继承与派生"></a>继承与派生</h1><p>类的继承时新的类从已有类那里得到已有的特性，从另一个角度看，从已有类产生新类的过程是类的派生 原有的类称为基类或父类，产生的新类称为派生类或子类 继承方式有三种，默认是私有继承</p>
<h2 id="u516C_u6709_u7EE7_u627F"><a href="#u516C_u6709_u7EE7_u627F" class="headerlink" title="公有继承"></a>公有继承</h2><p>基类的公有成员和保护成员的访问属性在派生类中不变，而基类的私有成员不可直接访问</p>
<h2 id="u79C1_u6709_u7EE7_u627F"><a href="#u79C1_u6709_u7EE7_u627F" class="headerlink" title="私有继承"></a>私有继承</h2><p>基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可直接访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initPoint</span><span class="params">(<span class="keyword">float</span> x = <span class="number">0</span>, <span class="keyword">float</span> y = <span class="number">0</span>)</span> </span>&#123;<span class="keyword">this</span>-&gt;x = x; <span class="keyword">this</span>-&gt;y = y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rectangle: <span class="keyword">private</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initRectangle</span><span class="params">(<span class="keyword">float</span> x,  <span class="keyword">float</span> y, <span class="keyword">float</span> w, <span class="keyword">float</span> h)</span> </span>&#123;</span><br><span class="line">        initPoint(x, y);  <span class="comment">// 调用基类公有成员函数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">        <span class="keyword">this</span>-&gt;h = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> Point::getX();&#125;   <span class="comment">// 由于私有继承，基类的公有成员变成了派生类的私有成员，外部无法访问，所以重写</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> Point::getY();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> w, h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="u4FDD_u62A4_u7EE7_u627F"><a href="#u4FDD_u62A4_u7EE7_u627F" class="headerlink" title="保护继承"></a>保护继承</h2><p>基类中的公有成员和保护成员都以保护成员身份出现在派生类中，而基类的私有成员在派生类中不可直接访问</p>
<h2 id="u6784_u9020_u51FD_u6570"><a href="#u6784_u9020_u51FD_u6570" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数不能被继承，子类只能调用父类的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base1(<span class="keyword">int</span> i) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1  "</span> &lt;&lt; i &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base2(<span class="keyword">int</span> i) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2  "</span> &lt;&lt; i &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base3 : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base3(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k) : Base1(i), Base2(j) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3  "</span> &lt;&lt; k &lt;&lt; endl; &#125;  <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Base3 <span class="title">obj</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base2 2</span></span><br><span class="line"><span class="comment">// Base1 1</span></span><br><span class="line"><span class="comment">// Base3 3</span></span><br><span class="line"><span class="comment">// 基类构造函数调用的顺序是按照派生类定义时的顺序，先Base2再Base1最后Base3</span></span><br></pre></td></tr></table></figure>
<h1 id="u591A_u6001_u6027"><a href="#u591A_u6001_u6027" class="headerlink" title="多态性"></a>多态性</h1><h2 id="u8FD0_u7B97_u7B26_u91CD_u8F7D"><a href="#u8FD0_u7B97_u7B26_u91CD_u8F7D" class="headerlink" title="运算符重载"></a>运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Complex &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>): real(r), imag(i)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>;</span><br><span class="line">    Complex <span class="keyword">operator</span>- (<span class="keyword">const</span> Complex &amp;c2) <span class="keyword">const</span>;</span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>++ ();  <span class="comment">// 前置单目运算符</span></span><br><span class="line">    Complex <span class="keyword">operator</span>++ (<span class="keyword">int</span>);  <span class="comment">// 后置单目运算符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real;</span><br><span class="line">    <span class="keyword">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+( <span class="keyword">const</span> Complex &amp;c2 ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(real + c2.real, imag + c2.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-( <span class="keyword">const</span> Complex &amp;c2 ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(real - c2.real, imag - c2.imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    imag++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>++( <span class="keyword">int</span> ) &#123;</span><br><span class="line">    Complex old = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u865A_u51FD_u6570"><a href="#u865A_u51FD_u6570" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数是动态绑定的基础。虚函数必须是非静态函数 运行过程中的多态需要满足3个条件</p>
<ol>
<li>满足赋值兼容规则</li>
<li>声明虚函数</li>
<li>由成员函数来调用或者通过指针、引用来访问虚函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayv</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displaynv</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Base1::displayv() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bsae1 virtual"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Base1::displaynv() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1 not virtual"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base2: <span class="keyword">public</span> Base1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayv</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displaynv</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Base2::displayv() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2 virtual"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Base2::displaynv() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2 not virtual"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Base1 *ptr)</span> </span>&#123;</span><br><span class="line">    ptr-&gt;displayv();</span><br><span class="line">    ptr-&gt;displaynv();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base1 b1;</span><br><span class="line">    Base2 b2;</span><br><span class="line">    func(&amp;b1);</span><br><span class="line">    func(&amp;b2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Base1 virtual</span></span><br><span class="line"><span class="comment">// Base1 not virtual</span></span><br><span class="line"><span class="comment">// Base2 virtual</span></span><br><span class="line"><span class="comment">// base1 not virtual</span></span><br></pre></td></tr></table></figure>
<p>Base1,Base2属于同一个类族且通过公有派生而来，满足赋值兼容规则，display声明为虚函数，程序中使用对象指针来访问成员函数。通过基类类型的指针能访问到正在指向的对象的成员</p>
<h2 id="u7EAF_u865A_u51FD_u6570_u4E0E_u62BD_u8C61_u7C7B"><a href="#u7EAF_u865A_u51FD_u6570_u4E0E_u62BD_u8C61_u7C7B" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h2><p>纯虚函数是在基类中声明的虚函数，没有定义具体的操作内容 抽象类是带有纯虚函数的类。抽象类不能实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base1 &#123;  <span class="comment">// 抽象类</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="u6A21_u7248"><a href="#u6A21_u7248" class="headerlink" title="模版"></a>模版</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  <span class="comment">// 函数模版</span></span><br><span class="line"><span class="function">T <span class="title">abs</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;  <span class="comment">// 类模版</span></span><br><span class="line"><span class="keyword">class</span> Store &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Store();</span><br><span class="line">  <span class="function">T &amp;<span class="title">getElem</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putElem</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T item;</span><br><span class="line">  <span class="keyword">bool</span> haveValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">Store&lt;T&gt;::Store(): haveValue(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line">T &amp;Store&lt;T&gt;::getElem() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!haveValue) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"No item present"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Store&lt;T&gt;::putElem(<span class="keyword">const</span> T &amp;x) &#123;</span><br><span class="line">  haveValue = <span class="literal">true</span>;</span><br><span class="line">  item = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">float</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = -<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">double</span> n2 = -<span class="number">5.1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(n1) &lt;&lt; endl;  <span class="comment">// 编译器从实参类型推导出函数模版的类型参数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(n2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Student stu = &#123; <span class="number">1000</span>, <span class="number">23</span> &#125;;</span><br><span class="line">    Store&lt;Student&gt; s1;  <span class="comment">// 定义Store&lt;Student&gt;类对象，数据类型为Student结构体</span></span><br><span class="line">    s1.putElem(stu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"id = "</span> &lt;&lt; s1.getElem().gpa &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Store&lt;<span class="keyword">double</span>&gt; s2;  <span class="comment">// 定义Store&lt;double&gt;类对象，数据类型为double</span></span><br><span class="line">    s2.putElem(<span class="number">2.0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"value = "</span> &lt;&lt; s2.getElem() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="u6CDB_u578B_u7A0B_u5E8F_u8BBE_u8BA1"><a href="#u6CDB_u578B_u7A0B_u5E8F_u8BBE_u8BA1" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><p>就是编写不依赖于具体数据类型的程序</p>
<h2 id="u5BB9_u5668"><a href="#u5BB9_u5668" class="headerlink" title="容器"></a>容器</h2><h3 id="u987A_u5E8F_u5BB9_u5668"><a href="#u987A_u5E8F_u5BB9_u5668" class="headerlink" title="顺序容器"></a>顺序容器</h3><p>s.erase(p1)<br>s.erase(p1, p2)<br>s.push_back(t)<br>s.pop_back()<br>s.push_front(t)<br>s.pop_front()</p>
<h2 id="u8FED_u4EE3_u5668"><a href="#u8FED_u4EE3_u5668" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是范化的指针，STL算法利用迭代器对存储在容器中的元素序列进行遍历</p>
<h2 id="u51FD_u6570_u5BF9_u8C61"><a href="#u51FD_u6570_u5BF9_u8C61" class="headerlink" title="函数对象"></a>函数对象</h2><h2 id="u7B97_u6CD5"><a href="#u7B97_u6CD5" class="headerlink" title="算法"></a>算法</h2><h1 id="u968F_u673A_u6570"><a href="#u968F_u673A_u6570" class="headerlink" title="随机数"></a>随机数</h1><p>C++中不能使用 random()。C++中常使用 rand()函数来生成随机数，但严格意义上生成的是伪随机数。 rand()不能指定随机数的范围，生成的数在 0 到 RAND_MAX 之间。可以自己写能指定生成范围的随机函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">random</span><span class="params">(<span class="keyword">double</span> start, <span class="keyword">double</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start + (end - start) * rand() / (RAND_MAX + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="u5224_u65AD_u6570_u7EC4_u5143_u7D20_u4E2A_u6570"><a href="#u5224_u65AD_u6570_u7EC4_u5143_u7D20_u4E2A_u6570" class="headerlink" title="判断数组元素个数"></a>判断数组元素个数</h2><p>静态数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">int</span> *sbeg = begin(s);</span><br><span class="line"><span class="keyword">int</span> *send = end(s);</span><br><span class="line"><span class="keyword">auto</span> len = send - sbeg;</span><br></pre></td></tr></table></figure>
<p>动态数组没有办法判断 因为 int s[] = { 1, 2, 3 }声明的静态数组存放在栈空间，s 指向的是整个数组的空间，所以可以用 sizeof(s) / sizeof(s[0])来判断元素个数。而 int *s = new int[10]数组的内容放在堆空间，s 只指向首地址，只有 4 字节，无法获取整个数组的大小。 通过栈空间和堆空间也不难理解为什么函数中声明的静态数组无法返回，动态数组可以返回，因为栈空间里的内容会被自动释放，堆空间需要 delete 才会释放。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[包子行走隐私政策]]></title>
      <url>http://pengtianhao.com/2016/04/14/%E5%8C%85%E5%AD%90%E8%A1%8C%E8%B5%B0%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/</url>
      <content type="html"><![CDATA[<p>APP Store搜索:包子行走</p>
<a id="more"></a>
<blockquote>
<p>包子行走尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务， 包子行走会按照本隐私权政策的规定使用和披露您的个人信息。但 包子行走将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下， 包子行走不会将这些信息对外披露或向第三方提供。 包子行走会不时更新本隐私权政策。 您在同意 包子行走服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于 包子行走服务使用协议不可分割的一部分。 </p>
</blockquote>
<h2 id="1-__u9002_u7528_u8303_u56F4"><a href="#1-__u9002_u7528_u8303_u56F4" class="headerlink" title="1. 适用范围"></a>1. 适用范围</h2><p>a) 在您注册 包子行走帐号时，您根据 包子行走要求提供的个人注册信息； </p>
<p>b) 在您使用 包子行走网络服务， 包子行走自动接收并记录的您的手机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据； </p>
<p>c)  包子行走通过合法途径从商业伙伴处取得的用户个人数据。 </p>
<p><strong>您了解并同意，以下信息不适用本隐私权政策：</strong></p>
<p>a) 您在使用 包子行走平台提供的搜索服务时输入的关键字信息； </p>
<p>b)  包子行走收集到的您在 包子行走发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情； </p>
<p>c) 违反法律规定或违反 包子行走规则行为及 包子行走已对您采取的措施。 </p>
<h2 id="2-__u4FE1_u606F_u4F7F_u7528"><a href="#2-__u4FE1_u606F_u4F7F_u7528" class="headerlink" title="2. 信息使用"></a>2. 信息使用</h2><p>a)  包子行走不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和 包子行走（含 包子行走关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 </p>
<p>b)  包子行走亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何 包子行走平台用户如从事上述活动，一经发现， 包子行走有权立即终止与该用户的服务协议。 </p>
<p>c) 为服务用户的目的， 包子行走可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与 包子行走合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 </p>
<h2 id="3-__u4FE1_u606F_u62AB_u9732"><a href="#3-__u4FE1_u606F_u62AB_u9732" class="headerlink" title="3. 信息披露"></a>3. 信息披露</h2><p><strong>在如下情况下， 包子行走将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： </strong></p>
<p>a) 经您事先同意，向第三方披露； </p>
<p>b) 为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； </p>
<p>c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p>
<p>d) 如您出现违反中国有关法律、法规或者 包子行走服务协议或相关规则的情况，需要向第三方披露；  </p>
<p>e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；</p>
<p>f) 在 包子行走平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的， 包子行走有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。  </p>
<p>g) 其它 包子行走根据法律、法规或者网站政策认为合适的披露。  </p>
<h2 id="4-__u4FE1_u606F_u5B58_u50A8_u548C_u4EA4_u6362"><a href="#4-__u4FE1_u606F_u5B58_u50A8_u548C_u4EA4_u6362" class="headerlink" title="4. 信息存储和交换"></a>4. 信息存储和交换</h2><p> 包子行走收集的有关您的信息和资料将保存在 包子行走及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或 包子行走收集信息和资料所在地的境外并在境外被访问、存储和展示。 </p>
<h2 id="5-_Cookie_u7684_u4F7F_u7528"><a href="#5-_Cookie_u7684_u4F7F_u7528" class="headerlink" title="5. Cookie的使用"></a>5. Cookie的使用</h2><p>a) 在您未拒绝接受cookies的情况下， 包子行走会在您的计算机上设定或取用cookies<br>，以便您能登录或使用依赖于cookies的 包子行走平台服务或功能。 包子行走使用cookies可为您提供更加周到的个性化服务，包括推广服务。  </p>
<p>b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的 包子行走网络服务或功能。 </p>
<p>c) 通过 包子行走所设cookies所取得的有关信息，将适用本政策。 </p>
<h2 id="6-__u4FE1_u606F_u5B89_u5168"><a href="#6-__u4FE1_u606F_u5B89_u5168" class="headerlink" title="6. 信息安全"></a>6. 信息安全</h2><p>a)  包子行走帐号均有安全保护功能，请妥善保管您的用户名及密码信息。 包子行走将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。  </p>
<p>b) 在使用 包子行走网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是 包子行走用户名及密码发生泄露，请您立即联络 包子行走客服，以便 包子行走采取相应措施。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我用过的iOS开发SDK自我记录（不定时更新）]]></title>
      <url>http://pengtianhao.com/2016/03/13/%E6%88%91%E7%94%A8%E8%BF%87%E7%9A%84iOS%E5%BC%80%E5%8F%91SDK%E8%87%AA%E6%88%91%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>记录好用的SDK，备忘</p>
</blockquote>
<a id="more"></a>
<h2 id="u7F51_u7EDC_u8FDE_u63A5"><a href="#u7F51_u7EDC_u8FDE_u63A5" class="headerlink" title="网络连接"></a>网络连接</h2><p><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a></p>
<h2 id="u56FE_u50CF_u5904_u7406"><a href="#u56FE_u50CF_u5904_u7406" class="headerlink" title="图像处理"></a>图像处理</h2><p><a href="http://tusdk.com" target="_blank" rel="external">TUSDK(滤镜)</a></p>
<p><a href="http://www.dejohndong.com/2015/02/25/实现iOS的瀑布流：DDCollectionViewFlowLayout/" target="_blank" rel="external">瀑布流</a></p>
<h2 id="u5730_u56FE"><a href="#u5730_u56FE" class="headerlink" title="地图"></a>地图</h2><p><a href="http://lbs.amap.com" target="_blank" rel="external">高德地图SDK</a></p>
<h2 id="mysql_u8FDE_u63A5"><a href="#mysql_u8FDE_u63A5" class="headerlink" title="mysql连接"></a>mysql连接</h2><p><a href="https://github.com/thrivesmart/just-mysql-example-mac-app-objective-c-xcode" target="_blank" rel="external">在osx上连接mysql</a></p>
<h2 id="u5012_u8BA1_u65F6"><a href="#u5012_u8BA1_u65F6" class="headerlink" title="倒计时"></a>倒计时</h2><p><a href="https://github.com/mineschan/MZTimerLabel" target="_blank" rel="external">MZTimerLable</a></p>
<h2 id="u793E_u533A"><a href="#u793E_u533A" class="headerlink" title="社区"></a>社区</h2><p><a href="http://www.umeng.com/wsq" target="_blank" rel="external">友盟微社区</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构备忘（单链表-二叉树）]]></title>
      <url>http://pengtianhao.com/2016/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%87%E5%BF%98%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>二叉树和单链表是数据结构的重要基础</p>
</blockquote>
<a id="more"></a>
<h2 id="u5355_u94FE_u8868"><a href="#u5355_u94FE_u8868" class="headerlink" title="单链表"></a>单链表</h2><pre><code>#include &lt;iostream&gt;
using namespace std;

struct List
{
    int num;
    List *next;
};

//在下一行建立头指针
List *head;

List *Create()
{
        //从下一行开始构造单链表
    List *p = NULL;
    List *q = NULL;
    head = NULL;
    for(int i =0; i &lt; 3; i++){
        p=new List;
        cin &gt;&gt; p-&gt;num;
    if(head == NULL){
    head = p;
    }else{
        q-&gt;next = p;
        }
        q=p;
    }
    if(head != NULL){
    q-&gt;next = NULL;
    }
    return head;
}

void displayList(List *head)
{
    while ( head != NULL ) {
        cout &lt;&lt; head-&gt;num &lt;&lt; endl;
        head = head-&gt;next;
    }
}

int main() {
       Create();
    displayList(head);
    return 0;
}
</code></pre><h2 id="u4E8C_u53C9_u6811"><a href="#u4E8C_u53C9_u6811" class="headerlink" title="二叉树"></a>二叉树</h2><pre><code>#include &lt;iostream&gt;
using namespace std;
struct BiTNode{
    char data;
    struct BiTNode *lchild, *rchild;
};
BiTNode*T;
void CreateBiTree(BiTNode* &amp;T);
void Inorder(BiTNode* &amp;T);
void PreOrderTraverse(BiTNode* &amp;T);
void Posorder(BiTNode* &amp;T);

int main(){
    CreateBiTree(T);
    cout&lt;&lt;&quot;先序递归遍历：&quot;&lt;&lt;endl;
    PreOrderTraverse(T);
    cout&lt;&lt;endl;
    cout&lt;&lt;&quot;中序递归遍历：&quot;&lt;&lt;endl;
    Inorder(T);
    cout&lt;&lt;endl;
    cout&lt;&lt;&quot;后序递归遍历：&quot;&lt;&lt;endl;
    Posorder(T);
    cout&lt;&lt;endl;
    return 1;
}

void CreateBiTree(BiTNode* &amp;T){
    char ch;
    if((ch=getchar())==&apos;#&apos;){
        T=NULL;
    }
    else{
        T=new BiTNode;
        T-&gt;data=ch;
        CreateBiTree(T-&gt;lchild);//递归创建左子树
        CreateBiTree(T-&gt;rchild);//递归创建右子树
    }
}

void PreOrderTraverse(BiTNode* &amp;T){
    if(T){
        cout&lt;&lt;T-&gt;data;
        PreOrderTraverse(T-&gt;lchild);//
        PreOrderTraverse(T-&gt;rchild);
    }else cout&lt;&lt;&quot;&quot;;
}

void Inorder(BiTNode* &amp;T){
    if(T){
        Inorder(T-&gt;lchild);
        cout&lt;&lt;T-&gt;data;
        Inorder(T-&gt;rchild);
    }
    else cout&lt;&lt;&quot;&quot;;
}

void Posorder(BiTNode* &amp;T){
    if(T){
        Posorder(T-&gt;lchild);
        Posorder(T-&gt;rchild);
        cout&lt;&lt;T-&gt;data;
    }
    else cout&lt;&lt;&quot;&quot;;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[远离百度，我们有更好的]]></title>
      <url>http://pengtianhao.com/2016/01/11/%E8%BF%9C%E7%A6%BB%E7%99%BE%E5%BA%A6%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84/</url>
      <content type="html"><![CDATA[<blockquote>
<p>前言：俗话说得好『no zuo no die why you try』，然而作为人见人删的互联网界的阿三哥，百度最近又干出了一件丧心病狂的事情——把血友病吧卖了！好吧，既然你这么没节操，那么作为弱势群体的互联网众们，惹不起还躲不起吗？现在就奉上躲开『度三哥』的终极法宝，让百度全家桶吃*去吧！！</p>
</blockquote>
<p><img src="https://s3.amazonaws.com/f.cl.ly/items/3p3X2i1h3I3w0S0Y3632/images.jpg?v=12e1e7ac" alt=""></p>
<p><strong>本文提及的百度产品根据<a href="http://www.zhihu.com/question/29816213" target="_blank" rel="external">百度全家桶都包含哪些产品？</a>中『ytytytyt』的回答列举，侵删</strong></p>
<a id="more"></a>
<h2 id="u767E_u5EA6_u641C_u7D22"><a href="#u767E_u5EA6_u641C_u7D22" class="headerlink" title="百度搜索"></a>百度搜索</h2><p>作为百度赖以生存的拳头产品，如果不把它的核心功能干死，那么其他功夫也是白费。据说GooglePlay快要回归中国了，那么也许Google入华也会在未来几年实现。然而，难道不太会翻墙的同学们就真不能看谷歌了？拿衣服！现在就推荐几个谷歌镜像，让大家爽个够~</p>
<p><a href="https://www.guge.link/" target="_blank" rel="external">guge.link</a></p>
<p><a href="https://www.psea.in/" target="_blank" rel="external">psea.in</a></p>
<p><a href="https://www.guge.click/" target="_blank" rel="external">guge.click</a></p>
<p><a href="https://www.souguge.com/" target="_blank" rel="external">souguge.com</a></p>
<p>没有一大堆恶心的某田系医院和留学IT挖掘机按摩抠脚培训广告，干干净净的谷歌才是真爱好嘛！</p>
<p><img src="https://s3.amazonaws.com/f.cl.ly/items/1x0l3D250x011j2y2604/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-11%20%E4%B8%8B%E5%8D%8812.57.21.png?v=9920dae7" alt="谷歌搜索"></p>
<h2 id="u767E_u5EA6_u536B_u58EB+_u767E_u5EA6_u6740_u6BD2"><a href="#u767E_u5EA6_u536B_u58EB+_u767E_u5EA6_u6740_u6BD2" class="headerlink" title="百度卫士+百度杀毒"></a>百度卫士+百度杀毒</h2><p>这个替代方案就多了，国内有鹅厂的『<a href="http://guanjia.qq.com/" target="_blank" rel="external">腾讯电脑管家</a>』，360的『<a href="http://www.360.com/" target="_blank" rel="external">360安全卫士</a>』，猎豹的『<a href="http://cn.cmcm.com/cm-security/?f=cmcn" target="_blank" rel="external">猎豹安全大师</a>』等，国外的『<a href="http://www.avg.com/us-en/free-antivirus-protection" target="_blank" rel="external">AVG</a>』，『<a href="https://www.avast.com/free-mobile-security" target="_blank" rel="external">Avast</a>』等，都能很好地替代百度安全卫士。</p>
<p>即使是360这种把不要脸写在脸上（话说这是怎么办到的~）的公司，也比百度的道貌岸然要好上不少。</p>
<p>您说是吧，雷总~</p>
<p><img src="https://s3.amazonaws.com/f.cl.ly/items/2T053Y1W1W1m0L0F2J1R/81733965.jpg?v=7af8b9b4" alt=""></p>
<p>但是，怎么卸载呢？</p>
<p>请看<a href="https://www.zhihu.com/question/30796689/answer/49517439" target="_blank" rel="external">如何彻底删除百度相关插件？</a></p>
<h2 id="hao123"><a href="#hao123" class="headerlink" title="hao123"></a>hao123</h2><p>您说导航类网站一定得有？这个我就无奈了 ╮(╯_╰)╭</p>
<p>好吧，其实还是有不少的，为了不用百度全家桶，拼了！</p>
<p><a href="http://hao.360.cn/" target="_blank" rel="external">360网址导航</a></p>
<p><a href="http://www.114la.com/" target="_blank" rel="external">114啦</a></p>
<p><a href="http://www.2345.com/" target="_blank" rel="external">2345</a></p>
<h2 id="u6A58_u5B50_u6D4F_u89C8_u5668"><a href="#u6A58_u5B50_u6D4F_u89C8_u5668" class="headerlink" title="橘子浏览器"></a>橘子浏览器</h2><p>众所周知，hao123简直是流氓中的流氓，那么由hao123搞出来的橘子浏览器会青出于蓝也是不奇怪的。</p>
<p><a href="http://www.pingwest.com/juzi-browser/" target="_blank" rel="external">“流氓软件”桔子浏览器，原来是百度造？</a></p>
<p>替代品就不说了，大家一定有最心爱的几款，比如作者就最喜欢Chrome和Safari。</p>
<p>那么怎么才能干掉这款软件呢？</p>
<p>看这位兄弟的血泪控诉——<a href="http://blog.ifeng.com/article/33138785.html" target="_blank" rel="external">花大半天时间硬搞掉桔子浏览器</a></p>
<h2 id="u767E_u5EA6_u5F71_u97F3"><a href="#u767E_u5EA6_u5F71_u97F3" class="headerlink" title="百度影音"></a>百度影音</h2><p><img src="https://s3.amazonaws.com/f.cl.ly/items/1539080o1G3N1F2t2p13/屏幕快照%202016-01-11%20下午1.42.25.png?v=b0bf0612" alt=""></p>
<p>咳咳，最近快播又搞出了个大新闻，但是百度好像也有那么一款产品在做同样的事情，怎么就没人查呢?</p>
<p><img src="https://s3.amazonaws.com/f.cl.ly/items/0I3W3O290g2f262b3Y1s/屏幕快照%202016-01-11%20下午2.38.05.png?v=9fbbf124" alt=""></p>
<p>然而作为一个有文化有素质的互联网众，纯洁的我们怎么能放任这等龌龊事不管，而让某公司产品继续发扬光大呢？</p>
<p>看片不求人，更不求某度，现在就提供两大绝招，原理全家桶，珍爱生命：</p>
<p>1.BT搜索引擎：<a href="http://www.btbook.com" target="_blank" rel="external">BTBOOK</a></p>
<p>2.以『影片名+ed2k』格式搜索</p>
<p>恩，你懂的~</p>
<p><img src="https://s3.amazonaws.com/f.cl.ly/items/1z2s0n1c0A3a1n3q2F3S/b219ebc4b74543a926969bd618178a82b901141e.jpg?v=aebc35c1" alt=""></p>
<h2 id="u6700_u540E_u7684_u8BDD"><a href="#u6700_u540E_u7684_u8BDD" class="headerlink" title="最后的话"></a>最后的话</h2><p>互联网的精神应该是开放，共享的，然而百度作为中国目前第三大互联网公司，众多无下限的行为已经令人反感。以上虽然列举这么多，但是到目前为止百度依然会出现在大多数人的生活中。也许这小小的挣扎并不会被人所接受，然而，我们努力了，就够了。</p>
<p>中国互联网的明天，是属于谁的呢？</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIsAAABFCAMAAABNJeUJAAABklBMVEX////mAAAAAADnAADwIiAfGN/tIyP2vLznCQj6pKbsIiToJSTzn5n98fHrUlL62tWVlpX4+PjmIir5w8PxkJDf3d+qqKrqREH75eLoIijzpJ7Sz9KIhogaGRrjIS0AANz2fH7v7+/sNTb8z9DxGRX93t9lY2W4uLjxjon4jpD/+PjvAACCf+3x8f33ycnyW13a2doyGNM9HM34rKxQT1DyTlGsrKw8OzwxMDENDA35+f8eIx6Miu7r6v4mHd9lY+j1s61KRui8r+nm2O92c+xvY96YlO3GwOueHXbNH0jVIkTwY2acHIcoC9VRTORhWOXZ0/bdJTXpbGzftbbsfoFaGbv2fHe5DFTfj6qHDYtvDassMuatWpy8FmNSKtKxH26mKoWnneh8IaFpGrCyQJVPAACXYGG9q6oVAACfAAB3dXdaWFozNzNFR0WLiIvokpbZmp6WNTI/AwLKHSd+AAC9kZQwRUczBwWtXl7eVl9yISHe3frjorm3puu7uvJTL8zSQmDcPEvgeJHFhribgdGQSrqy694PAAANFElEQVRogd1Zi1vb1hWXJVm2JGxj2SApGMuWZR52wBhHPBIwkNKQRIEAMclSmra067pCaLa16x6sbN3j/9455+pl3mT7vnzbIbIe9+re3z3ndx5X4bj/Fzk5PT1d/tAgmJyuWZb1cQBm+eDg5INBWU5a3WTSeh4ASyb3Dz4UljWr2012u9Yp3jy0CNijDwPlBIC0k8n25hbeWHCVhOO/aKZMIVWo36zrAU0O0p3iuBULL+DB0g3ebGSMzPVIZNe2bd0r3gTOIwIyCxBOuO1ust3FW2tl6prXjE6l5bqefA2aelbSJEVxnLTTmr4W+RKggPm7iAVxdel+60ojZQqerTiSIoqKZ1w5ekuRRFNRNEk1xbJXaFyNBeZHXbQ3AcsS2asLRnp+ebzJ1AZgBkWSTNGUVGXyytF1gCBKkkq4RX3yakv9NIs6wT/UUZdxx1q/FEnnpW1KomIqcEiSprSuGrxhi5oimqaoaGAqTdT04oWGmjpY2rgPp/1o+kdkn1kAdEmEadzJwogSrpUOAOVdicUD3CCoG9ALKEdyC+fRQCSxrDWgxZLFsMDlRnKTrttbF45spFxUiQQKp0MRy4qdugoLV4A3wJjIGRFtCme1d9ZQ22sIwdra5qae49UmhbeVTSKvtX1+1My03ILRYFhJAZ3TIYm2fA0dU2AlUAzYtCxpyBkQV74f73IftDELTLXWp7iT9U0reUDNy5CaklbyIXQ4PY27Uk3e1TXUtanAkGUR3QIUpHeugQKa8VxbKyMEsquplkE5bidmqBOfpN0zKpg6XV85WAao2LgVtGWKLq5OA0VI9E9EFmjZib71XSKZXKEz6SqiSobCIZDNXkSbDYvF+qR1YYRlHLIYUCPlITlQxWXF1FAnQAG917k6tMSlUZddNBUYFmMfKsne7dTCyXwsH1+wtuV9YA22b93n6p1dW2IcUUVfFLHVqV1rnT7JZyYlYpsKkQ/WpIE7ukWae50SD9J0/QIsP1EchviX/AkIyyhHblkmyoju6vWJ6Lw0ii1AIDI7I3kU0U7Biu5a7TalIR/L/e1Ha/vPT/0stIT5CZPk47LoSMgTJB/yBGzuVmrvAYQkAzoG4kGchLCHYUGRWinjlAWVbtJ6iJ2W74L/AD/WGFvvUuvesx0HNAL2BeMA5xRVkXYq8rkwnisUCn0Wq08WYyLHs1BmetJG2gPhkDdge8n7y2fMjzbbOPvySmCyfaqo0IJ7z56iLgiLiVhgPZBPLmDJRCKRaMWNlkrERVCz8XjYyEzaoBh0JzIYDPtq1qKotj7F9NCFaINW2z+h+y/f7FDoxlSCkMosTOmtLJMO18kGoiXSguT6NzXCIqSZJPBHSCQqfeCNSbQU5RHAowANHs92LWsd8/GBxfhB/Fmb4hr/eOI4LNsASQBHGZgCY8akyMkJQfAXLghpIVBCgelFEMInAqI5kykKHksMTN+i6GjP/nWAWtn2s6OfI/+56om+TSRNRXVCKYTzw5jpYALEkk6LjqOoKsKE5UumqabFacICCoE2EsAEWLJn7GrILlq+jPPghejYA2Dm5edQblubFpWa7a9eP0GFMCwKxhRHsd1W9k+eiWvNTjApoF4SE7WUp+vFGklP1+1aLRPwpWdkmEygbvRzjDdkG+O4qZJ7IyFanY+2wELd7SmoHdp7j5/skN9KZVMhSKaqy0am0WjkOR1YIEa6Br0k5NyqnnYmcySe4Ag5HwtoYiLsaSOf4MWBO4F06kR12SYDEAeAC47z9BNQSBdo89fXWtOBlCexooDyYLaYMlbZ+0XkgOqPt8qRXiqw5JAqYDP4STHuJhIToce5gEUD28V9y0Nb1uw0pgWsJcBS4K+O+Pke1Lq5gaeORFEafIe4oigeZpxc+H46mtdmekEsQjQB0olhgbZQL3Ukmg6KSMS4n5AKiAXwK5RTMEfh4ew8m+3pjknxDOoM5IkpOi2WSXPB24kYKJ1hKRZ7alqo1KZBall4MDCR8/kiZCeZ9DQBGrD6QxKn0ecEfJI2AAtctWotG2ygwbwaJbwdB2KqYvp1I7iA9nMQSXPwovCu16sEsgsT6cxGd7g6sEhmHT14EMW6yHQwnyAgdXOBFG3UcAVeBk22ME67TDlSmepousT6S9RM/c3rWWtpKsACo8YdoJEI9cKweHcGQN5F/VKkASIQi3Xp1X4fSomA20a9ABZcc/3TJ8ALFe1l4v4C/Bfjz5u/p2qYj6y7UwGWdB+WTIAl4WOJTCcEWDDeMMtSIBR6Z/zZhDHjWKb228/KmC81zJvIE1H7+dne5gZWN9EG/xyWRmAjwqLFvaMYYElTaEwjJoEoXYEZG7KpMpFQh4QlwbAc7L3CmoSEakbFNP8GEDZYWddNsqSNNhLUuAgxGzUycYE4FOgl0XrRWU11XnTkXVJOh8u0QkdCjKFeuEZOLjcdjfGV6glRBSd3yq/bTC8QdNhXkBxlm3guEkIbrYqJMxLmo8in8x5Cq3CTiXRI6HRgIyHhdiYdijIS8gXSDZ4RmKQ6r35hcFR5t5mRcrHM1+/TgMWmqMOeksc2C4Feolh3B10pm7JRIYznE6JvI0hbMDvGEJOKYOfp608eNx1Wx+KTbOcuFrtda+l+4EcDMSlGfrTao4Ts1urGAEVCgfYomBtjOaCHaN1JBX53fe6qpJcC5oCyX3GCA7uV+vbKyspHL3WqIsu03Sjv4ZYlwJI460ex+DKtIzntXAWhiJV86EeJl3VfOmQRryjBbzHAAmPYsi1htsF601HLr774Mtw4G188gdBL+1LTaX7+VdsvPy/3aeQuOIdORhIEZzeogykfqToTlSWPYkrC82oBpSOhGaDekCSVtpW7n3yFZcJSsD3c3/ul6+BnAcCJecHa3wixGDGpYQkQYuGYN4B9iiFaytPpsNJCKNJ0RsVKJo2OaKqiQnWdhnYQ3JSRwboFbLG2fpcEbj57LDps0wAd33wa5CPQQ0zsgLtC4p0sy8WWxHzL3cUMUQ9sRPGOEGEr5IlV8kY4gu8OJIJOHP8ItvfkuyRU0yXbj5+IWDdAV+A3fgHL9SdGVj76flTx79O6HmjB9+k+UXdf4HyrWShcHeKHBO7b3GnZQDaP+dv2c8SwCTWdtdld21rZWoMKePbZU8pLKkAX3DqmfPyjf3SRpnKX6zQhtDeb8EjblfOG7Nk6/iFnjFS/TPvubdTuwL4e9yNOWvVWp40a7mZ8wy4/XF9Z+XhlZenRxsb2yfLJ9sbByr41+/qV6YjIY9Oxi8Z04Zzgbs+Ac53uWEbPUKF50Z4lklXaVDuQTi/6BDpFcj/ax04tgwwZnuOUiV+OWzz30vtJpiY2MYbplRt+7Q3FqKgO2/qqTud9ds9nxyvoCaxpveLNv05EkurtpLHeFM1m64JvbLeS+qQHOnGau9PvgwSkUevojkifZkWv8J8gwa/Bmmi/+2akv2GkdHRUGoo/qY7EpOrfzeSp4TewGjSUY7ovuFjTzSVjNJuirn/7B/7Ht/OL/PxwOPc4z8+Pjc3zC+NR77lRnucXF0DgPDyOv/zCWBUa8PLPf8IiRzPFpv7Hr7Fp9LB6Cyg5L2H35Nr4jzxfHaqOlGBoXznDPD8II1W/g3PUf6iEj4eGhmDyYbpbIPD56jC/MFft4GcKSA2wYf3t7/j526il9tK2C+jneRiULXzB1wNCoZHyAGYuemVmFDCgjOC5esSP+oocYpB//8P3YlNTVE36/oexmyMxim7LDzghFm5ukX87A1PO80f+oqrH/Gik6qEHPhbu3jCD/B27Lc3PsDX8+hvYcFKNI96YxUYxCk0RFm6MRh/kgymZiiIsTC9VvxUw32NAH5SCzqDXes/D/wNo7t42VvVjmeH5B/nqPZ6fCRrHR/lI2z6WcT4fQiebjiyOxLCAl3e+VTFZybf28BgWjkcaj0b33MhCsHaGZY544mMBm5bw8vAt14eFq/Jf/8oV0s2diVvGrDiWRcTCn8ESejpgWTg+hj6BizwgT5pZGD6HBbUpg0uZt0tTcSyji4BlMY5lvl8vR6XS4UKIpUSTDwbdz2DhuOKu03Rvo5pzNrpKL+jhgyEW6HoPbFa6DAuXSRWb9sDNP33HsOQRS3UefoLG8cUruMvlj6HrDB+kj/NYQKDAb934q3MMC4T+w3yfT8/xfCnsGfg0zD0yGDSPHY4FyC/AUkWtym7n9liO+YUZskuwKvCZxShBDgVxl6uOzdN5BlLRYpizhoPrCMswU3Hqht6NgZ5eqA4uLtJcJX7UH3+wPyGNMh9GBY6F6zgOwc6d08vQcUS9G2EZY3aoHgbJJ/+WHx3xoXwXS3FAniOGeoE/Ch8dhu2lwLjA6QW6GONvg6VaWsQMzz+AWBFl+bFR/nh8cJ5/MBz1HD/2O0LXkEXVe37M5fKHb6m9hHEA5e09fLB4Cyz5wUDG4/XGyODh0dHh4FDfo7gEWWJu8OxAZzreAsvlIKvVWxVm/8vyb+coub4+iAXVAAAAAElFTkSuQmCC" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS实现圆周运动效果]]></title>
      <url>http://pengtianhao.com/2016/01/01/iOS%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%91%A8%E8%BF%90%E5%8A%A8%E6%95%88%E6%9E%9C/</url>
      <content type="html"><![CDATA[<blockquote>
<p>刚刚基于iOS用定时器写了一个简单的圆周运动，这里写一下实现</p>
</blockquote>
<a id="more"></a>
<h2 id="u8BB0_u5F55_u4E0B360_u4E2Asin/cos_u503C"><a href="#u8BB0_u5F55_u4E0B360_u4E2Asin/cos_u503C" class="headerlink" title="记录下360个sin/cos值"></a>记录下360个sin/cos值</h2><p>像这样</p>
<pre><code>for(int i=0;i&lt;360;i++){
    array[0][i]=sin(PI/180*i);
    array[1][i]=cos(PI/180*i);
}
</code></pre><h2 id="u8BBE_u7F6E_u5B9A_u65F6_u5668"><a href="#u8BBE_u7F6E_u5B9A_u65F6_u5668" class="headerlink" title="设置定时器"></a>设置定时器</h2><p>设置每0.01秒执行一次<code>task</code>方法</p>
<pre><code>NSDate *scheduledTime = [NSDate dateWithTimeIntervalSinceNow:0];
NSString *customUserObject = @&quot;To demo userInfo&quot;;
NSTimer *timer = [[NSTimer alloc] initWithFireDate:scheduledTime
                                          interval:0.00000001
                                            target:self
                                          selector:@selector(task)
                                          userInfo:customUserObject
                                           repeats:YES];
NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
[runLoop addTimer:timer forMode:NSDefaultRunLoopMode];
</code></pre><h2 id="task_u65B9_u6CD5_u8D1F_u8D23_u6539_u53D8_u5706_u7684_u4F4D_u7F6E"><a href="#task_u65B9_u6CD5_u8D1F_u8D23_u6539_u53D8_u5706_u7684_u4F4D_u7F6E" class="headerlink" title="task方法负责改变圆的位置"></a>task方法负责改变圆的位置</h2><pre><code>-(void)task{
    _Circle.frame = CGRectMake(250+array[1][n]*R,250+array[0][n]*R, cW, cH);
    n++;
    n%=360;
    NSLog(@&quot;%f %f&quot;,_Circle.frame.origin.x,_Circle.frame.origin.y);
}
</code></pre><p><a href="https://github.com/pthtc/circular-motion-iOS" target="_blank" rel="external">点击这里下载demo</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[详解LL(1)文法的判断]]></title>
      <url>http://pengtianhao.com/2015/12/26/%E8%AF%A6%E8%A7%A3LL-1-%E6%96%87%E6%B3%95%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      <content type="html"><![CDATA[<blockquote>
<p>LL（1）文法：第一个L代表从左向右扫描输入符号串，第二个L代表产生最左推导，1代表在分析过程中执行每一步推导都要向前查看一个输入符号——当前正在处理的输入符号</p>
</blockquote>
<a id="more"></a>
<h2 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h2><h3 id="1-__u5224_u65ADFirst_u96C6_28_u5224_u65AD_u7684_u662F_u53F3_u90E8_u7684First_u96C6_29"><a href="#1-__u5224_u65ADFirst_u96C6_28_u5224_u65AD_u7684_u662F_u53F3_u90E8_u7684First_u96C6_29" class="headerlink" title="1. 判断First集(判断的是右部的First集)"></a>1. <strong>判断First集(判断的是右部的First集)</strong></h3><pre><code>直接收取对形如U－&gt;a…的产生式（其中a是终结符），把a收入到First(U)中

反复传送：对形入U－&gt;P…的产生式（其中P是非终结符），应把First(P)中的全部内容传送到First(U)中【意思就是只需要把第一个非终结符的First集传过去~这个地方是要注意的地方，也是难点】
</code></pre><h3 id="2-__u5224_u65ADFollow_u96C6_28_u5224_u65AD_u7684_u662F_u5DE6_u90E8_u7684Follow_u96C6_u5408_29"><a href="#2-__u5224_u65ADFollow_u96C6_28_u5224_u65AD_u7684_u662F_u5DE6_u90E8_u7684Follow_u96C6_u5408_29" class="headerlink" title="2. 判断Follow集(判断的是左部的Follow集合)"></a>2. <strong>判断Follow集(判断的是左部的Follow集合)</strong></h3><pre><code>直接收取：注意产生式右部的每一个形如“…Ua…”的组合，把a直接收入到Follow(U)中。因a是紧跟在U后的终结符。

直接收取：对形如“…UP…”(P是非终结符)的组合，把First(P)直接收入到Follow(U)中【在这里，如果First（P）中有空字符，那么就要把左部（假设是S）的Follow（S）送入到Follow（U）中。还有就是Follow集中是没有空字符的】。

直接收取：若S－&gt;…U，即以U结尾，则井∈Follow(U)

反复传送：对形如U－&gt;…P的产生式（其中P是非终结符），应把Follow(U)中的全部内容传送到Follow(P)中。
</code></pre><h3 id="3-__u5224_u65ADSelect_u96C6"><a href="#3-__u5224_u65ADSelect_u96C6" class="headerlink" title="3. 判断Select集"></a>3. <strong>判断Select集</strong></h3><pre><code>若α不能推出ε，则select（A—&gt;α） = first（α）。

若α能推出ε，则select（A—&gt;α）= first（α）∪ follow(A)。
</code></pre><h3 id="4-__u68C0_u9A8C_u76F8_u540C_u975E_u7EC8_u7ED3_u7B26_u7684Select_u662F_u5426_u76F8_u540C"><a href="#4-__u68C0_u9A8C_u76F8_u540C_u975E_u7EC8_u7ED3_u7B26_u7684Select_u662F_u5426_u76F8_u540C" class="headerlink" title="4. 检验相同非终结符的Select是否相同"></a>4. <strong>检验相同非终结符的Select是否相同</strong></h3><pre><code>如果都相同，则为LL(1)文法
如果不同，则不是
</code></pre><h2 id="u4F8B_u9898"><a href="#u4F8B_u9898" class="headerlink" title="例题"></a>例题</h2><pre><code>若文法G[S]为
S-&gt;AB
S-&gt;bC
A-&gt;ε
A-&gt;b
B-&gt;ε
B-&gt;aD
C-&gt;AD
C-&gt;b
D-&gt;aS
D-&gt;c
</code></pre><h3 id="1-__u6C42First_u96C6"><a href="#1-__u6C42First_u96C6" class="headerlink" title="1. 求First集"></a>1. 求First集</h3><pre><code>First(AB) = {b,a,ε}

First(bC) = {b}

First(ε) = {ε}

First(b) = {b}

First(aD) = {a}

First(AD) = {a,b,c}

First(aS) = {a}

First(c) = {c}
</code></pre><h3 id="2-__u6C42Follow_u96C6"><a href="#2-__u6C42Follow_u96C6" class="headerlink" title="2. 求Follow集"></a>2. 求Follow集</h3><pre><code>Follow(S) = {井}

Follow(A) = First(B) ∪ First(D) ∪ Follow(S)= {a,c,井}

Follow(B) = {井}

Follow(C) = {井}

Follow(D) = {井}
</code></pre><h3 id="3-__u6C42Select_u96C6"><a href="#3-__u6C42Select_u96C6" class="headerlink" title="3. 求Select集"></a>3. 求Select集</h3><pre><code>Select(S-&gt;AB) = First(AB) ∪ Follow(s) = {a,b,井,ε}
Select(S-&gt;bC) = First(bC) = {b}

【到此已不需要继续求下去了】
</code></pre><h3 id="4-__u6BD4_u8F83"><a href="#4-__u6BD4_u8F83" class="headerlink" title="4. 比较"></a>4. 比较</h3><pre><code>∵Select(S-&gt;AB)≠Select(S-&gt;bC)
∴不是LL(1)文法
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[记一次创业失败]]></title>
      <url>http://pengtianhao.com/2015/12/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%88%9B%E4%B8%9A%E5%A4%B1%E8%B4%A5/</url>
      <content type="html"><![CDATA[<blockquote>
<p>失败了，你可能会失望；但如果不去尝试，那么你注定要失败<br>—— 贝弗利·西尔斯</p>
</blockquote>
<p>开始写这篇文章的时候，电脑正压在蓝白条纹的床单上。零点已过，这算是散心旅行的最后一天。</p>
<p>说起失败，人们总是想起美丽到不自然的鲜血，重重倒下后的尘土飞扬以及声嘶力竭的呐喊。但是，事情往往并非如此。就在不久前，我们的留学app项目失败了。</p>
<p>一次无声无息的创业失败，承认起来并没有想象中那么困难。既然是失败，总能从中总结出点什么。然而草草理一下，发现尽是些老生常谈的琐碎，然而只有亲身体会之后，才能体会。</p>
<a id="more"></a>
<h2 id="u5386_u7A0B_uFF1A"><a href="#u5386_u7A0B_uFF1A" class="headerlink" title="历程："></a>历程：</h2><p>从今年年初立项，到十月团队解散，大约是半年的时间。期间团队人数升升降降。期间整个商业模式改变过四次，尝试过用子项目养活团队。最终因为重要合伙人离开，项目失败，团队解散。<br>虽然失败的直接原因是技术合伙人离开，但实质上失败的种子在团队组建的那天就已经埋下。</p>
<h2 id="1-_u4EBA_uFF0C_u8FD8_u662F_u4EBA"><a href="#1-_u4EBA_uFF0C_u8FD8_u662F_u4EBA" class="headerlink" title="1.人，还是人"></a>1.人，还是人</h2><p><strong>不得不承认，整个团队战斗力并不高。</strong></p>
<p>从最开始的2个人，到最多时候的11个人，看似整个项目有过上升阶段，然而现在回想来却发现，整个项目从开始到失败，几乎没有一刻可以称得上众志成城。我想着并不是因为有谁是坏人，而是在团队从相聚到解散。没有困难带来的煎熬，也没有成功的喜悦，再加上匆忙拼凑带来的不协调感，凝聚力就像一捧水被洒在沙子上，慢慢地被蒸干。</p>
<p>在不合适的时间找到合适的人。在还没有定下产品方向的时候，我们就从上海将我们的技术合伙人请来。虽然被我们的诚意打动，但到来团队面对的就是长达两个月的摸索和扯皮。这位能力够得上任何一线互联网公司offer的合伙人，在百无聊赖长久之后，最终选择离开。</p>
<p>令行禁止，狠不下心。我们尝试过启动一个语言培训O2O项目来保证我们的现金流，并且为此将团队的人数扩大到11人。在付出工资的同时，我们忽略了团建和奖惩制度。我们寄希望于这些『实习生』拿着兼职的钱，却能像合伙人一样做事，然而却发现，然并卵。1*11&lt;11，这大概是一个失败的案例。</p>
<p>步调不统一，行动低效。团队成员之间团队从组建到解散，几个重要合伙人之间对以往经历依旧不了解，谈话只限于项目本身。虽然股份有大小，但是团队大多数时候处于双核心状态，没有人可以一言九鼎，又因为思维方式『太过互补』导致每一件事情的执行都要经过漫长的争论。这也是弊端之一。</p>
<h2 id="2-__u65B9_u5411"><a href="#2-__u65B9_u5411" class="headerlink" title="2. 方向"></a>2. 方向</h2><p>我们初定下的方向是做留学案例检索平台，但是经过论证之后发现成本极高，且天花板太低，最终放弃。</p>
<p>第二个方向是留学日历，主打关键时间点提醒。在这期间又有一个失败的子项目，在此略过不表<br>最终定下产品名为留学记，主打留学时间点提醒和记录功能。</p>
<p>改变方向并不是坏事，这代表项目又向可能正确的方向进了一步。但是如果每一次改变，都没有基于严谨的调查，拍脑袋做事，就一定会带来严重的后果，然而我们，就犯了这个错误。</p>
<p>第一个方向的确定，是另一个合伙人定下的，他在留学行业看到留学机构和学生之间不透明的痛点。但是当我们正着手去做的时候，解决方案却是想留学机构索要案例。因为这是现在留学案例唯一大批量来源，我们又暂时没有能力向每个独立的学生收集案例。</p>
<p>于是经过第二次拍脑袋之后，决定做留学日历。过程几乎一模一样，当我们实际去做的时候，却发现50%的潜在用户并不需要这项服务，而剩下的50%也不是强需求。于是我们希望能加上计时来满足正在准备语言考试的用户。但是也因为发现需求不足而最终砍掉。</p>
<p>在这期间我们还筹备了一个留学语言培训产品，并且将广告铺向下沙大多数高校。这是一个套着众筹壳卖课的产品，我们本希望通过这款产品打开杭州留学培训市场，但结果是，一共只有十个人报名我们的视听课。我们看到小米饥饿营销卖得不错，就是视图将iPhone用小米的方式出售，却忘了小米卖得好，究其根本，是因为便宜。</p>
<p>凝聚一个团队的可能是情怀，可能是利益，可能是某个人，我们在这些都没有的时候，还失去了方向，最终也只有解散这一条路。</p>
<h2 id="3-__u6001_u5EA6"><a href="#3-__u6001_u5EA6" class="headerlink" title="3. 态度"></a>3. 态度</h2><p>除了前两个最致命的原因，作为创始成员的自己，在做事方式上，也有很大的问题。</p>
<p><strong>举得起放不下</strong></p>
<p>有人告诉过我，创业者一定要切断自己的后路。然而切断后路需要极大的勇气和对前方的路百分之一百的信心，遗憾的是，我没有。拉不下面子，只愿意用看似高大上的手段处理事情，是其中之一。在留学语言培训产品推广的过程中，我们舍弃地推，采用公众号的推广形式。按照当时我们的说法，这是因为地推成本更加高昂，然而究其根本，是因为我们不愿『自降身份』去做事。而且在公众号的推文中，也尽可能用更加隐晦的表达方式来凸显逼格，却忘记了，对于团队最重要的事情，是活下来。</p>
<p><strong>投机和侥幸</strong></p>
<p>在项目启动之前，看到火热的创投圈，总希望能够成为那头会飞的猪。以为做产品就是画ppt做axure，却忘记了对产品本身的热爱。浮躁杀死了我们。</p>
<p>创业终究不是装逼，也不是一味的接地气。一切为了产品服务。</p>
<h2 id="4-__u5173_u4E8E_u5176_u4ED6"><a href="#4-__u5173_u4E8E_u5176_u4ED6" class="headerlink" title="4. 关于其他"></a>4. 关于其他</h2><p><strong>1. 在想到一个解决方案之后，想一下为什么别人不做。</strong></p>
<p><strong>2. 好的体验并不是UI或者UE，能用小钱快速解决的问题就不要纠结太久</strong></p>
<p>暂时脱离创业状态的我，总有一天还会回到这条路上，不为别的，就为做出一个能让『自己』爱上的产品。</p>
]]></content>
    </entry>
    
  
  
</search>
